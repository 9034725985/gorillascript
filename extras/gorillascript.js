;(function (root) {
  var GorillaScript = (function () {
    function require(path) {
      return require[path];
    }
    require['./types'] = (function () {
    var module = { exports: this };
    var exports = this;
    (function () {
      "use strict";
      var __cmp, __create, __isArray, __lt, __lte, __num, __owns, __slice, __str, __strnum, __toArray, __typeof, inspect, Type, util;
      __cmp = function (left, right) {
        var type;
        if (left === right) {
          return 0;
        } else {
          type = typeof left;
          if (type !== "number" && type !== "string") {
            throw TypeError("Cannot compare a non-number/string: " + type);
          } else if (type !== typeof right) {
            throw TypeError("Cannot compare elements of different types: " + type + " vs " + typeof right);
          } else if (left < right) {
            return -1;
          } else {
            return 1;
          }
        }
      };
      __create = typeof Object.create === "function" ? Object.create
        : function (x) {
          function F() {}
          F.prototype = x;
          return new F();
        };
      __isArray = typeof Array.isArray === "function" ? Array.isArray
        : (function () {
          var _toString;
          _toString = Object.prototype.toString;
          return function (x) {
            return _toString.call(x) === "[object Array]";
          };
        }());
      __lt = function (x, y) {
        var type;
        type = typeof x;
        if (type !== "number" && type !== "string") {
          throw TypeError("Cannot compare a non-number/string: " + type);
        } else if (type !== typeof y) {
          throw TypeError("Cannot compare elements of different types: " + type + " vs " + typeof y);
        } else {
          return x < y;
        }
      };
      __lte = function (x, y) {
        var type;
        type = typeof x;
        if (type !== "number" && type !== "string") {
          throw TypeError("Cannot compare a non-number/string: " + type);
        } else if (type !== typeof y) {
          throw TypeError("Cannot compare elements of different types: " + type + " vs " + typeof y);
        } else {
          return x <= y;
        }
      };
      __num = function (num) {
        if (typeof num !== "number") {
          throw TypeError("Expected a number, got " + __typeof(num));
        } else {
          return num;
        }
      };
      __owns = Object.prototype.hasOwnProperty;
      __slice = Array.prototype.slice;
      __str = function (str) {
        if (typeof str !== "string") {
          throw TypeError("Expected a string, got " + __typeof(str));
        } else {
          return str;
        }
      };
      __strnum = function (strnum) {
        var type;
        type = typeof strnum;
        if (type === "string") {
          return strnum;
        } else if (type === "number") {
          return String(strnum);
        } else {
          throw TypeError("Expected a string or number, got " + __typeof(strnum));
        }
      };
      __toArray = function (x) {
        if (x == null) {
          throw TypeError("Expected an object, got " + __typeof(x));
        } else if (__isArray(x)) {
          return x;
        } else if (typeof x === "string") {
          return x.split("");
        } else {
          return __slice.call(x);
        }
      };
      __typeof = (function () {
        var _toString;
        _toString = Object.prototype.toString;
        return function (o) {
          if (o === void 0) {
            return "Undefined";
          } else if (o === null) {
            return "Null";
          } else {
            return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);
          }
        };
      }());
      util = require("util");
      if (util != null) {
        inspect = util.inspect;
      }
      module.exports = Type = (function () {
        var _Type_prototype, any, AnyType, ArrayType, ComplementType, fromJSONTypes, FunctionType, getId, none, NoneType, ObjectType, SimpleType, UnionType;
        function Type() {
          var _this;
          _this = this instanceof Type ? this : __create(_Type_prototype);
          throw TypeError("Type should not be instantiated");
        }
        _Type_prototype = Type.prototype;
        Type.displayName = "Type";
        _Type_prototype.isSubsetOf = function () {
          throw Error("Not implemented: " + __strnum(this.constructor.displayName || this.constructor.name) + ".isSubsetOf()");
        };
        _Type_prototype.isSupersetOf = function (other) {
          return other.isSubsetOf(this);
        };
        _Type_prototype.overlaps = function () {
          throw Error("Not implemented: " + __strnum(this.constructor.displayName || this.constructor.name) + ".overlaps()");
        };
        _Type_prototype.compare = function () {
          throw Error("Not implemented: " + __strnum(this.constructor.displayName || this.constructor.name) + ".compare()");
        };
        _Type_prototype.equals = function () {
          throw Error("Not implemented: " + __strnum(this.constructor.displayName || this.constructor.name) + ".equals()");
        };
        _Type_prototype.union = function () {
          throw Error("Not implemented: " + __strnum(this.constructor.displayName || this.constructor.name) + ".union()");
        };
        _Type_prototype.intersect = function () {
          throw Error("Not implemented: " + __strnum(this.constructor.displayName || this.constructor.name) + ".intersect()");
        };
        _Type_prototype.complement = function () {
          throw Error("Not implemented: " + __strnum(this.constructor.displayName || this.constructor.name) + ".complement()");
        };
        _Type_prototype.array = function () {
          var _ref;
          if ((_ref = this._array) == null) {
            return this._array = ArrayType(this);
          } else {
            return _ref;
          }
        };
        _Type_prototype["function"] = function () {
          var _ref;
          if ((_ref = this._function) == null) {
            return this._function = FunctionType(this);
          } else {
            return _ref;
          }
        };
        function contains(alpha, bravo) {
          var _arr, _i, item;
          for (_arr = __toArray(alpha), _i = _arr.length; _i--; ) {
            item = _arr[_i];
            if (item.equals(bravo)) {
              return true;
            }
          }
          return false;
        }
        function union(alpha, bravo) {
          var a, alphaLen, b, bravoLen, cmp, i, j, result;
          if (alpha === bravo) {
            return alpha;
          }
          result = [];
          alphaLen = alpha.length;
          bravoLen = bravo.length;
          i = 0;
          j = 0;
          while (i < __num(alphaLen) && j < __num(bravoLen)) {
            a = alpha[i];
            b = bravo[j];
            cmp = a.compare(b);
            if (cmp === 0) {
              result.push(a);
              ++i;
              ++j;
            } else if (__num(cmp) < 0) {
              result.push(a);
              ++i;
            } else {
              result.push(b);
              ++j;
            }
          }
          for (; i < __num(alphaLen); ++i) {
            result.push(alpha[i]);
          }
          for (; j < __num(bravoLen); ++j) {
            result.push(bravo[j]);
          }
          switch (result.length) {
          case alphaLen: return alpha;
          case bravoLen: return bravo;
          default: return result;
          }
        }
        function intersect(alpha, bravo) {
          var a, alphaLen, b, bravoLen, cmp, i, j, result;
          if (alpha === bravo) {
            return alpha;
          }
          alphaLen = alpha.length;
          bravoLen = bravo.length;
          result = [];
          i = 0;
          j = 0;
          while (i < __num(alphaLen) && j < __num(bravoLen)) {
            a = alpha[i];
            b = bravo[j];
            cmp = a.compare(b);
            if (cmp === 0) {
              result.push(a);
              ++i;
              ++j;
            } else if (__num(cmp) < 0) {
              ++i;
            } else {
              ++j;
            }
          }
          switch (result.length) {
          case alphaLen: return alpha;
          case bravoLen: return bravo;
          default: return result;
          }
        }
        function relativeComplement(alpha, bravo) {
          var a, alphaLen, bravoLen, cmp, i, j, result;
          if (alpha === bravo) {
            return [];
          }
          result = [];
          alphaLen = alpha.length;
          if (alphaLen === 0) {
            return result;
          }
          bravoLen = bravo.length;
          if (bravoLen === 0) {
            return alpha;
          }
          i = 0;
          j = 0;
          while (i < __num(alphaLen) && j < __num(bravoLen)) {
            a = alpha[i];
            cmp = a.compare(bravo[j]);
            if (cmp === 0) {
              ++i;
              ++j;
            } else if (__num(cmp) < 0) {
              result.push(a);
              ++i;
            } else {
              ++j;
            }
          }
          for (; i < __num(alphaLen); ++i) {
            result.push(alpha[i]);
          }
          if (result.length === alphaLen) {
            return alpha;
          } else {
            return result;
          }
        }
        function isSubsetOf(alpha, bravo) {
          var alphaLen, bravoLen, i, j;
          if (alpha === bravo) {
            return true;
          }
          alphaLen = alpha.length;
          if (alphaLen === 0) {
            return true;
          }
          bravoLen = bravo.length;
          if (!__lte(alphaLen, bravoLen)) {
            return false;
          } else {
            i = 0;
            j = 0;
            while (j < __num(bravoLen)) {
              if (alpha[i].equals(bravo[j])) {
                ++i;
                if (i >= __num(alphaLen)) {
                  return true;
                }
                ++j;
              } else {
                ++j;
              }
            }
            return false;
          }
        }
        function overlaps(alpha, bravo) {
          var alphaLen, bravoLen, cmp, i, j;
          alphaLen = alpha.length;
          if (alpha === bravo && __num(alphaLen) > 0) {
            return true;
          }
          bravoLen = bravo.length;
          i = 0;
          j = 0;
          while (i < __num(alphaLen) && j < __num(bravoLen)) {
            cmp = alpha[i].compare(bravo[j]);
            if (cmp === 0) {
              return true;
            } else if (__num(cmp) < 0) {
              ++i;
            } else {
              ++j;
            }
          }
          return false;
        }
        function compare(alpha, bravo) {
          var c, i, len;
          if (alpha === bravo) {
            return 0;
          } else {
            len = alpha.length;
            c = __cmp(len, bravo.length);
            if (c) {
              return c;
            } else {
              for (i = 0, __num(len); i < len; ++i) {
                c = alpha[i].compare(bravo[i]);
                if (c) {
                  return c;
                }
              }
              return 0;
            }
          }
        }
        function equals(alpha, bravo) {
          var i, len;
          if (alpha === bravo) {
            return true;
          } else {
            len = alpha.length;
            if (len !== bravo.length) {
              return false;
            } else {
              for (i = 0, __num(len); i < len; ++i) {
                if (!alpha[i].equals(bravo[i])) {
                  return false;
                }
              }
              return true;
            }
          }
        }
        function typeComparer(a, b) {
          return a.compare(b);
        }
        function makeUnionType(types, needsSort) {
          switch (types.length) {
          case 0: return none;
          case 1: return types[0];
          default:
            if (needsSort) {
              types.sort(typeComparer);
            }
            return UnionType(types);
          }
        }
        fromJSONTypes = {};
        Type.fromJSON = function (x) {
          var type;
          if (!x || typeof x !== "object") {
            throw TypeError("Expected an Object, got " + typeof x);
          }
          type = x.type;
          if (typeof type !== "string") {
            throw TypeError("Unspecified type");
          } else if (!__owns.call(fromJSONTypes, type)) {
            throw TypeError("Unknown serialization type: " + __strnum(type));
          } else {
            return fromJSONTypes[type](x);
          }
        };
        getId = (function () {
          var id;
          id = -1;
          return function () {
            ++id;
            return id;
          };
        }());
        SimpleType = (function (Type) {
          var _SimpleType_prototype, _Type_prototype2;
          function SimpleType(name) {
            var _this;
            _this = this instanceof SimpleType ? this : __create(_SimpleType_prototype);
            if (typeof name !== "string") {
              throw TypeError("Expected name to be a String, got " + __typeof(name));
            }
            _this.name = name;
            _this.id = getId();
            return _this;
          }
          _Type_prototype2 = Type.prototype;
          _SimpleType_prototype = SimpleType.prototype = __create(_Type_prototype2);
          _SimpleType_prototype.constructor = SimpleType;
          SimpleType.displayName = "SimpleType";
          _SimpleType_prototype.toString = function () {
            return this.name;
          };
          _SimpleType_prototype.equals = function (other) {
            return this === other;
          };
          _SimpleType_prototype.compare = function (other) {
            if (this === other) {
              return 0;
            } else if (other instanceof SimpleType) {
              return __cmp(this.name, other.name) || __cmp(this.id, other.id);
            } else {
              return __cmp("SimpleType", other.constructor.displayName);
            }
          };
          _SimpleType_prototype.union = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof SimpleType) {
              if (this === other) {
                return this;
              } else {
                return makeUnionType(
                  [this, other],
                  true
                );
              }
            } else {
              return other.union(this);
            }
          };
          _SimpleType_prototype.intersect = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof SimpleType) {
              if (this === other) {
                return this;
              } else {
                return none;
              }
            } else {
              return other.intersect(this);
            }
          };
          _SimpleType_prototype.isSubsetOf = function (other) {
            var _this;
            _this = this;
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof SimpleType) {
              return this === other;
            } else if (other instanceof UnionType) {
              return (function () {
                var _arr, _i, type;
                for (_arr = __toArray(other.types), _i = _arr.length; _i--; ) {
                  type = _arr[_i];
                  if (_this === type) {
                    return true;
                  }
                }
                return false;
              }());
            } else if (other instanceof ComplementType) {
              return !this.isSubsetOf(other.untype);
            } else {
              return other === any;
            }
          };
          _SimpleType_prototype.overlaps = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof SimpleType) {
              return this === other;
            } else {
              return other.overlaps(this);
            }
          };
          _SimpleType_prototype.complement = function () {
            var _ref;
            if ((_ref = this._complement) == null) {
              return this._complement = ComplementType(this);
            } else {
              return _ref;
            }
          };
          _SimpleType_prototype.inspect = function () {
            var _this;
            _this = this;
            return (function () {
              var _else, k, v;
              _else = true;
              for (k in Type) {
                if (__owns.call(Type, k)) {
                  _else = false;
                  v = Type[k];
                  if (v === _this) {
                    return "Type." + k;
                  }
                }
              }
              return "Type.make(" + __strnum(inspect(_this.name)) + ")";
            }());
          };
          _SimpleType_prototype.toJSON = function () {
            var _this;
            _this = this;
            return (function () {
              var _else, k, v;
              _else = true;
              for (k in Type) {
                if (__owns.call(Type, k)) {
                  _else = false;
                  v = Type[k];
                  if (v === _this) {
                    return { type: "simple", name: k };
                  }
                }
              }
              throw Error("Cannot serialize custom type: " + String(_this));
            }());
          };
          fromJSONTypes.simple = function (_p) {
            var name;
            name = _p.name;
            return __owns.call(Type, name) && Type[name] || (function () {
              throw Error("Unknown type: " + String(name));
            }());
          };
          return SimpleType;
        }(Type));
        Type.make = function (name) {
          return SimpleType(name);
        };
        ArrayType = (function (Type) {
          var _ArrayType_prototype, _Type_prototype2;
          function ArrayType(subtype) {
            var _this;
            _this = this instanceof ArrayType ? this : __create(_ArrayType_prototype);
            if (!(subtype instanceof Type)) {
              throw TypeError("Expected subtype to be a Type, got " + __typeof(subtype));
            }
            _this.subtype = subtype;
            _this.id = getId();
            return _this;
          }
          _Type_prototype2 = Type.prototype;
          _ArrayType_prototype = ArrayType.prototype = __create(_Type_prototype2);
          _ArrayType_prototype.constructor = ArrayType;
          ArrayType.displayName = "ArrayType";
          function become(alpha, bravo) {
            if (__lt(alpha.id, bravo.id)) {
              bravo.subtype = alpha.subtype;
              bravo.id = alpha.id;
            } else {
              alpha.subtype = bravo.subtype;
              alpha.id = bravo.id;
            }
          }
          _ArrayType_prototype.toString = function () {
            var _ref;
            if ((_ref = this._name) == null) {
              return this._name = this.subtype === any ? "[]" : "[" + String(this.subtype) + "]";
            } else {
              return _ref;
            }
          };
          _ArrayType_prototype.equals = function (other) {
            if (other === this) {
              return true;
            } else if (other instanceof ArrayType) {
              if (this.id === other.id) {
                return true;
              } else if (this.subtype.equals(other.subtype)) {
                become(this, other);
                return true;
              } else {
                return false;
              }
            } else {
              return false;
            }
          };
          _ArrayType_prototype.compare = function (other) {
            if (this.equals(other)) {
              return 0;
            } else if (other instanceof ArrayType) {
              return this.subtype.compare(other.subtype);
            } else {
              return __cmp("ArrayType", other.constructor.displayName);
            }
          };
          _ArrayType_prototype.union = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof ArrayType) {
              if (this.equals(other)) {
                return this;
              } else if (this.subtype.isSubsetOf(other.subtype)) {
                return other;
              } else if (other.subtype.isSubsetOf(this.subtype)) {
                return this;
              } else {
                return makeUnionType(
                  [this, other],
                  true
                );
              }
            } else if (other instanceof SimpleType) {
              return makeUnionType(
                [this, other],
                true
              );
            } else {
              return other.union(this);
            }
          };
          _ArrayType_prototype.intersect = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof ArrayType) {
              if (this.equals(other)) {
                return this;
              } else if (this.subtype.isSubsetOf(other.subtype)) {
                return this;
              } else if (other.subtype.isSubsetOf(this.subtype)) {
                return other;
              } else {
                return none.array();
              }
            } else if (other instanceof SimpleType) {
              return none;
            } else {
              return other.intersect(this);
            }
          };
          _ArrayType_prototype.isSubsetOf = function (other) {
            var _this;
            _this = this;
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof ArrayType) {
              return this.subtype.isSubsetOf(other.subtype);
            } else if (other instanceof UnionType) {
              return (function () {
                var _arr, _i, type;
                for (_arr = __toArray(other.types), _i = _arr.length; _i--; ) {
                  type = _arr[_i];
                  if (_this.isSubsetOf(type)) {
                    return true;
                  }
                }
                return false;
              }());
            } else if (other instanceof ComplementType) {
              return !this.isSubsetOf(other.untype);
            } else {
              return other === any;
            }
          };
          _ArrayType_prototype.overlaps = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof ArrayType) {
              return this.subtype.overlaps(other.subtype);
            } else if (other instanceof SimpleType) {
              return false;
            } else {
              return other.overlaps(this);
            }
          };
          _ArrayType_prototype.complement = function () {
            var _ref;
            if ((_ref = this._complement) == null) {
              return this._complement = ComplementType(this);
            } else {
              return _ref;
            }
          };
          _ArrayType_prototype.inspect = function (depth) {
            if (this.subtype === any) {
              return "Type.array";
            } else {
              return __strnum(inspect(this.subtype, null, depth)) + ".array()";
            }
          };
          _ArrayType_prototype.toJSON = function () {
            return { type: "array", subtype: this.subtype };
          };
          fromJSONTypes.array = function (_p) {
            var subtype;
            subtype = _p.subtype;
            return Type.fromJSON(subtype).array();
          };
          return ArrayType;
        }(Type));
        ObjectType = (function (Type) {
          var _ObjectType_prototype, _Type_prototype2;
          function ObjectType(data) {
            var _this, k, pairs, v;
            _this = this instanceof ObjectType ? this : __create(_ObjectType_prototype);
            if (typeof data !== "object" || data instanceof RegExp) {
              throw TypeError("Expected an object, got " + __typeof(data));
            }
            pairs = [];
            for (k in data) {
              if (__owns.call(data, k)) {
                v = data[k];
                if (!(v instanceof Type)) {
                  throw TypeError("Expected data[" + __str(JSON.stringify(k)) + "] to be a Type, got " + __typeof(v));
                }
                if (v !== any) {
                  pairs.push([k, v]);
                }
              }
            }
            pairs.sort(function (a, b) {
              return __cmp(a[0], b[0]);
            });
            if (pairs.length === 0 && Type.object != null) {
              return Type.object;
            }
            _this.pairs = pairs;
            _this.id = getId();
            return _this;
          }
          _Type_prototype2 = Type.prototype;
          _ObjectType_prototype = ObjectType.prototype = __create(_Type_prototype2);
          _ObjectType_prototype.constructor = ObjectType;
          ObjectType.displayName = "ObjectType";
          _ObjectType_prototype.toString = function () {
            var _ref, _this;
            _this = this;
            if ((_ref = this._name) == null) {
              return this._name = "{" + __strnum((function () {
                var _arr, _arr2, _i, _len, _ref, k, v;
                for (_arr = [], _arr2 = __toArray(_this.pairs), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                  k = (_ref = _arr2[_i])[0];
                  v = _ref[1];
                  _arr.push(__strnum(k) + ": " + String(v));
                }
                return _arr;
              }()).join(", ")) + "}";
            } else {
              return _ref;
            }
          };
          function become(alpha, bravo) {
            if (__lt(alpha.id, bravo.id)) {
              bravo.pairs = alpha.pairs;
              bravo.id = alpha.id;
            } else {
              alpha.pairs = bravo.pairs;
              alpha.id = bravo.id;
            }
          }
          _ObjectType_prototype.equals = function (other) {
            var _arr, _len, i, otherPair, otherPairs, pair, pairs;
            if (other === this) {
              return true;
            } else if (other instanceof ObjectType) {
              pairs = this.pairs;
              otherPairs = other.pairs;
              if (pairs === otherPairs) {
                return true;
              } else if (pairs.length !== otherPairs.length) {
                return false;
              } else {
                for (_arr = __toArray(pairs), i = 0, _len = _arr.length; i < _len; ++i) {
                  pair = _arr[i];
                  otherPair = otherPairs[i];
                  if (pair[0] !== otherPair[0] || !pair[1].equals(otherPair[1])) {
                    return false;
                  }
                }
                become(this, other);
                return true;
              }
            } else {
              return false;
            }
          };
          _ObjectType_prototype.compare = function (other) {
            var _arr, _len, cmp, i, otherPair, otherPairs, pair, pairs;
            if (this === other) {
              return 0;
            } else if (other instanceof ObjectType) {
              pairs = this.pairs;
              otherPairs = other.pairs;
              if (pairs === otherPairs) {
                return 0;
              } else {
                cmp = __cmp(pairs.length, otherPairs.length);
                if (cmp) {
                  return cmp;
                } else {
                  for (_arr = __toArray(pairs), i = 0, _len = _arr.length; i < _len; ++i) {
                    pair = _arr[i];
                    otherPair = otherPairs[i];
                    cmp = __cmp(pair[0], otherPair[0]) || pair[1].compare(otherPair[1]);
                    if (cmp) {
                      return cmp;
                    }
                  }
                  become(this, other);
                  return 0;
                }
              }
            } else {
              return __cmp("ObjectType", other.constructor.displayName);
            }
          };
          _ObjectType_prototype.union = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof ObjectType) {
              if (this.equals(other)) {
                return this;
              } else if (this.isSubsetOf(other)) {
                return other;
              } else if (other.isSubsetOf(this)) {
                return this;
              } else {
                return makeUnionType(
                  [this, other],
                  true
                );
              }
            } else if (other instanceof SimpleType || other instanceof ArrayType) {
              return makeUnionType(
                [this, other],
                true
              );
            } else {
              return other.union(this);
            }
          };
          _ObjectType_prototype.intersect = function (other) {
            var _arr, _i, _len, _ref, k, merged, v;
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof ObjectType) {
              if (this.equals(other)) {
                return this;
              } else if (this.isSubsetOf(other)) {
                return this;
              } else if (other.isSubsetOf(this)) {
                return other;
              } else {
                merged = {};
                for (_arr = __toArray(this.pairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                  k = (_ref = _arr[_i])[0];
                  v = _ref[1];
                  merged[k] = v;
                }
                for (_arr = __toArray(other.pairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                  k = (_ref = _arr[_i])[0];
                  v = _ref[1];
                  if (__owns.call(merged, k)) {
                    merged[k] = merged[k].intersect(v);
                  } else {
                    merged[k] = v;
                  }
                }
                return ObjectType(merged);
              }
            } else if (other instanceof SimpleType || other instanceof ArrayType) {
              return none;
            } else {
              return other.intersect(this);
            }
          };
          _ObjectType_prototype.isSubsetOf = function (other) {
            var _arr, _i, _len, _ref, _this, i, len, otherK, otherPairs, otherV, pair, pairs;
            _this = this;
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof ObjectType) {
              if (this === other || other === Type.object) {
                return true;
              } else if (this === Type.object) {
                return false;
              } else {
                pairs = this.pairs;
                otherPairs = other.pairs;
                if (pairs === other.pairs) {
                  return true;
                } else {
                  i = 0;
                  len = pairs.length;
                  for (_arr = __toArray(otherPairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                    otherK = (_ref = _arr[_i])[0];
                    otherV = _ref[1];
                    for (; i <= __num(len); ++i) {
                      if (i === len) {
                        return false;
                      }
                      pair = pairs[i];
                      if (pair[0] === otherK) {
                        if (pair[1].isSubsetOf(otherV)) {
                          ++i;
                          break;
                        } else {
                          return false;
                        }
                      } else if (!__lte(pair[0], otherK)) {
                        return false;
                      }
                    }
                  }
                  if (i === len) {
                    become(this, other);
                  }
                  return true;
                }
              }
            } else if (other instanceof UnionType) {
              return (function () {
                var _arr, _i, type;
                for (_arr = __toArray(other.types), _i = _arr.length; _i--; ) {
                  type = _arr[_i];
                  if (_this.isSubsetOf(type)) {
                    return true;
                  }
                }
                return false;
              }());
            } else if (other instanceof ComplementType) {
              return !this.isSubsetOf(other.untype);
            } else {
              return other === any;
            }
          };
          _ObjectType_prototype.overlaps = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof ObjectType) {
              return true;
            } else if (other instanceof SimpleType || other instanceof ArrayType) {
              return false;
            } else {
              return other.overlaps(this);
            }
          };
          _ObjectType_prototype.complement = function () {
            var _ref;
            if ((_ref = this._complement) == null) {
              return this._complement = ComplementType(this);
            } else {
              return _ref;
            }
          };
          _ObjectType_prototype.value = function (key) {
            var _arr, _i, pair, pairKey;
            if (typeof key !== "string") {
              throw TypeError("Expected key to be a String, got " + __typeof(key));
            }
            for (_arr = __toArray(this.pairs), _i = _arr.length; _i--; ) {
              pair = _arr[_i];
              pairKey = pair[0];
              if (pairKey === key) {
                return pair[1];
              } else if (pairKey < key) {
                return Type.any;
              }
            }
            return Type.any;
          };
          _ObjectType_prototype.inspect = function (depth) {
            var _arr, _i, _len, _ref, k, obj, v;
            if (this === Type.object) {
              return "Type.object";
            } else {
              obj = {};
              for (_arr = __toArray(this.pairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                k = (_ref = _arr[_i])[0];
                v = _ref[1];
                obj[k] = v;
              }
              return "Type.makeObject(" + __strnum(inspect(obj, null, depth != null ? __num(depth) - 1 : null)) + ")";
            }
          };
          _ObjectType_prototype.toJSON = function () {
            var _arr, _i, _len, _ref, k, pairs, v;
            pairs = {};
            for (_arr = __toArray(this.pairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
              k = (_ref = _arr[_i])[0];
              v = _ref[1];
              pairs[k] = v;
            }
            return { type: "object", pairs: pairs };
          };
          fromJSONTypes.object = function (_p) {
            var deserializedPairs, k, pairs, v;
            pairs = _p.pairs;
            deserializedPairs = {};
            for (k in pairs) {
              if (__owns.call(pairs, k)) {
                v = pairs[k];
                deserializedPairs[k] = Type.fromJSON(v);
              }
            }
            return ObjectType(deserializedPairs);
          };
          return ObjectType;
        }(Type));
        Type.makeObject = function (data) {
          return ObjectType(data);
        };
        FunctionType = (function (Type) {
          var _FunctionType_prototype, _Type_prototype2;
          function FunctionType(returnType) {
            var _this;
            _this = this instanceof FunctionType ? this : __create(_FunctionType_prototype);
            if (!(returnType instanceof Type)) {
              throw TypeError("Expected returnType to be a Type, got " + __typeof(returnType));
            }
            _this.returnType = returnType;
            _this.id = getId();
            return _this;
          }
          _Type_prototype2 = Type.prototype;
          _FunctionType_prototype = FunctionType.prototype = __create(_Type_prototype2);
          _FunctionType_prototype.constructor = FunctionType;
          FunctionType.displayName = "FunctionType";
          _FunctionType_prototype.toString = function () {
            var _ref;
            if ((_ref = this._name) == null) {
              return this._name = this.returnType === any ? "->" : "-> " + String(this.returnType);
            } else {
              return _ref;
            }
          };
          function become(alpha, bravo) {
            if (__lt(alpha.id, bravo.id)) {
              bravo.returnType = alpha.returnType;
              return bravo.id = alpha.id;
            } else {
              alpha.returnType = bravo.returnType;
              return alpha.id = bravo.id;
            }
          }
          _FunctionType_prototype.equals = function (other) {
            if (other === this) {
              return true;
            } else if (other instanceof FunctionType) {
              if (this.id === other.id) {
                return true;
              } else if (this.returnType.equals(other.returnType)) {
                become(this, other);
                return true;
              } else {
                return false;
              }
            } else {
              return false;
            }
          };
          _FunctionType_prototype.compare = function (other) {
            var cmp;
            if (this === other) {
              return 0;
            } else if (other instanceof FunctionType) {
              if (this.id === other.id) {
                return 0;
              } else {
                cmp = this.returnType.compare(other.returnType);
                if (cmp === 0) {
                  become(this, other);
                }
                return cmp;
              }
            } else {
              return __cmp("FunctionType", other.constructor.displayName);
            }
          };
          _FunctionType_prototype.union = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof FunctionType) {
              if (this.equals(other)) {
                return this;
              } else if (this.returnType.isSubsetOf(other.returnType)) {
                return other;
              } else if (other.returnType.isSubsetOf(this.returnType)) {
                return this;
              } else {
                return makeUnionType(
                  [this, other],
                  true
                );
              }
            } else if (other instanceof SimpleType || other instanceof ArrayType || other instanceof ObjectType) {
              return makeUnionType(
                [this, other],
                true
              );
            } else {
              return other.union(this);
            }
          };
          _FunctionType_prototype.intersect = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof FunctionType) {
              if (this.equals(other)) {
                return this;
              } else if (this.returnType.isSubsetOf(other.returnType)) {
                return this;
              } else if (other.returnType.isSubsetOf(this.returnType)) {
                return other;
              } else {
                return none["function"]();
              }
            } else if (other instanceof SimpleType || other instanceof ArrayType || other instanceof ObjectType) {
              return none;
            } else {
              return other.intersect(this);
            }
          };
          _FunctionType_prototype.isSubsetOf = function (other) {
            var _this;
            _this = this;
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof FunctionType) {
              return this.returnType.isSubsetOf(other.returnType);
            } else if (other instanceof UnionType) {
              return (function () {
                var _arr, _i, type;
                for (_arr = __toArray(other.types), _i = _arr.length; _i--; ) {
                  type = _arr[_i];
                  if (_this.isSubsetOf(type)) {
                    return true;
                  }
                }
                return false;
              }());
            } else if (other instanceof ComplementType) {
              return !this.isSubsetOf(other.untype);
            } else {
              return other === any;
            }
          };
          _FunctionType_prototype.overlaps = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof FunctionType) {
              return this.returnType.overlaps(other.returnType);
            } else if (other instanceof SimpleType || other instanceof ArrayType || other instanceof ObjectType) {
              return false;
            } else {
              return other.overlaps(this);
            }
          };
          _FunctionType_prototype.complement = function () {
            var _ref;
            if ((_ref = this._complement) == null) {
              return this._complement = ComplementType(this);
            } else {
              return _ref;
            }
          };
          _FunctionType_prototype.inspect = function (depth) {
            if (this.returnType === any) {
              return "Type.function";
            } else {
              return __strnum(inspect(this.returnType, null, depth)) + ".function()";
            }
          };
          _FunctionType_prototype.toJSON = function () {
            return { type: "function", returnType: this.returnType };
          };
          fromJSONTypes["function"] = function (_p) {
            var returnType;
            returnType = _p.returnType;
            return Type.fromJSON(returnType)["function"]();
          };
          return FunctionType;
        }(Type));
        UnionType = (function (Type) {
          var _Type_prototype2, _UnionType_prototype;
          function UnionType(types) {
            var _i, _len, _this;
            _this = this instanceof UnionType ? this : __create(_UnionType_prototype);
            if (!__isArray(types)) {
              throw TypeError("Expected types to be an Array, got " + __typeof(types));
            } else {
              for (_i = 0, _len = types.length; _i < _len; ++_i) {
                if (!(types[_i] instanceof Type)) {
                  throw TypeError("Expected types[" + _i + "] to be a Type, got " + __typeof(types[_i]));
                }
              }
            }
            _this.types = types;
            if (types.length <= 1) {
              throw Error("Must provide at least 2 types to UnionType");
            }
            _this.id = getId();
            return _this;
          }
          _Type_prototype2 = Type.prototype;
          _UnionType_prototype = UnionType.prototype = __create(_Type_prototype2);
          _UnionType_prototype.constructor = UnionType;
          UnionType.displayName = "UnionType";
          _UnionType_prototype.toString = function () {
            var _ref;
            if ((_ref = this._name) == null) {
              return this._name = "(" + __strnum(this.types.join("|")) + ")";
            } else {
              return _ref;
            }
          };
          function become(alpha, bravo) {
            if (__lt(alpha.id, bravo.id)) {
              bravo.types = alpha.types;
              return bravo.id = alpha.id;
            } else {
              alpha.types = bravo.types;
              return alpha.id = bravo.id;
            }
          }
          _UnionType_prototype.equals = function (other) {
            if (other === this) {
              return true;
            } else if (other instanceof UnionType) {
              if (this.id === other.id) {
                return true;
              } else if (this.types === other.types || equals(this.types, other.types)) {
                become(this, other);
                return true;
              } else {
                return false;
              }
            } else {
              return false;
            }
          };
          _UnionType_prototype.compare = function (other) {
            var cmp;
            if (other === this) {
              return 0;
            } else if (other instanceof UnionType) {
              if (this.id === other.id) {
                return 0;
              } else if (this.types === other.types) {
                become(this, other);
                return 0;
              } else {
                cmp = compare(this.types, other.types);
                if (cmp === 0) {
                  become(this, other);
                }
                return cmp;
              }
            } else {
              return __cmp("UnionType", other.constructor.displayName);
            }
          };
          _UnionType_prototype.union = function (other) {
            var _arr, _i, _len, newTypes, type, types;
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof SimpleType || other instanceof ArrayType || other instanceof FunctionType) {
              types = union(this.types, [other]);
              if (types === this.types) {
                return this;
              } else {
                return makeUnionType(types);
              }
            } else if (other instanceof ObjectType) {
              if (other === Type.object) {
                newTypes = [other];
                for (_arr = __toArray(this.types), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                  type = _arr[_i];
                  if (type instanceof ObjectType) {
                    if (type === Type.object) {
                      return this;
                    }
                  } else {
                    newTypes.push(type);
                  }
                }
                return makeUnionType(newTypes);
              } else {
                newTypes = [other];
                for (_arr = __toArray(this.types), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                  type = _arr[_i];
                  if (type instanceof ObjectType) {
                    if (other.isSubsetOf(type)) {
                      return this;
                    } else if (!type.isSubsetOf(other)) {
                      newTypes.push(type);
                    }
                  } else {
                    newTypes.push(type);
                  }
                }
                return makeUnionType(newTypes);
              }
            } else if (other instanceof UnionType) {
              types = union(this.types, other.types);
              if (types === this.types) {
                return this;
              } else if (types === other.types) {
                return other;
              } else {
                return makeUnionType(types);
              }
            } else {
              return other.union(this);
            }
          };
          _UnionType_prototype.intersect = function (other) {
            var types;
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof SimpleType || other instanceof ArrayType || other instanceof ObjectType || other instanceof FunctionType) {
              return makeUnionType(intersect(this.types, [other]));
            } else if (other instanceof UnionType) {
              types = intersect(this.types, other.types);
              if (types === this.types) {
                return this;
              } else if (types === other.types) {
                return other;
              } else {
                return makeUnionType(types);
              }
            } else {
              return other.intersect(this);
            }
          };
          _UnionType_prototype.isSubsetOf = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof UnionType) {
              return isSubsetOf(this.types, other.types);
            } else if (other instanceof ComplementType) {
              return !this.overlaps(other.untype);
            } else {
              return other === any;
            }
          };
          _UnionType_prototype.overlaps = function (other) {
            var _this;
            _this = this;
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof SimpleType) {
              return contains(this.types, other);
            } else if (other instanceof ArrayType || other instanceof ObjectType || other instanceof FunctionType) {
              return (function () {
                var _arr, _i, type;
                for (_arr = __toArray(_this.types), _i = _arr.length; _i--; ) {
                  type = _arr[_i];
                  if (type.overlaps(other)) {
                    return true;
                  }
                }
                return false;
              }());
            } else if (other instanceof UnionType) {
              return overlaps(this.types, other.types);
            } else {
              return other.overlaps(this);
            }
          };
          _UnionType_prototype.complement = function () {
            var _ref;
            if ((_ref = this._complement) == null) {
              return this._complement = ComplementType(this);
            } else {
              return _ref;
            }
          };
          _UnionType_prototype.inspect = function (depth) {
            var _this;
            _this = this;
            return "(" + __strnum((function () {
              var _arr, _arr2, _i, _len, type;
              for (_arr = [], _arr2 = __toArray(_this.types), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                type = _arr2[_i];
                _arr.push(inspect(type, null, depth != null ? __num(depth) - 1 : null));
              }
              return _arr;
            }()).join(").union(")) + ")";
          };
          _UnionType_prototype.toJSON = function () {
            return { type: "union", types: this.types };
          };
          fromJSONTypes.union = function (_p) {
            var _arr, _i, current, type, types;
            types = _p.types;
            current = Type.none;
            for (_arr = __toArray(types), _i = _arr.length; _i--; ) {
              type = _arr[_i];
              current = current.union(Type.fromJSON(type));
            }
            return current;
          };
          return UnionType;
        }(Type));
        ComplementType = (function (Type) {
          var _ComplementType_prototype, _Type_prototype2;
          function ComplementType(untype) {
            var _this;
            _this = this instanceof ComplementType ? this : __create(_ComplementType_prototype);
            if (!(untype instanceof Type)) {
              throw TypeError("Expected untype to be a Type, got " + __typeof(untype));
            }
            _this.untype = untype;
            _this.id = getId();
            return _this;
          }
          _Type_prototype2 = Type.prototype;
          _ComplementType_prototype = ComplementType.prototype = __create(_Type_prototype2);
          _ComplementType_prototype.constructor = ComplementType;
          ComplementType.displayName = "ComplementType";
          _ComplementType_prototype.toString = function () {
            var _ref;
            if ((_ref = this._name) == null) {
              return this._name = "any \\ " + String(this.untype);
            } else {
              return _ref;
            }
          };
          function become(alpha, bravo) {
            if (__lt(alpha.id, bravo.id)) {
              bravo.id = alpha.id;
              return bravo.untype = alpha.untype;
            } else {
              alpha.id = bravo.id;
              return alpha.untype = bravo.untype;
            }
          }
          _ComplementType_prototype.equals = function (other) {
            if (this === other) {
              return true;
            } else if (other instanceof ComplementType) {
              if (this.id === other.id) {
                return true;
              } else if (this.untype.equals(other.untype)) {
                become(this, other);
                return true;
              } else {
                return false;
              }
            } else {
              return false;
            }
          };
          _ComplementType_prototype.compare = function (other) {
            var cmp;
            if (this === other) {
              return 0;
            } else if (other instanceof ComplementType) {
              if (this.id === other.id) {
                return 0;
              } else {
                cmp = this.untype.compare(other.untype);
                if (cmp === 0) {
                  become(this, other);
                }
                return cmp;
              }
            } else {
              return __cmp("ComplementType", other.constructor.displayName);
            }
          };
          function getUntypes(untype) {
            if (untype instanceof UnionType) {
              return untype.types;
            } else {
              return [untype];
            }
          }
          _ComplementType_prototype.union = function (other) {
            var myUntypes, untypes;
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof SimpleType || other instanceof ArrayType || other instanceof ObjectType || other instanceof FunctionType) {
              myUntypes = getUntypes(this.untype);
              untypes = relativeComplement(myUntypes, [other]);
              if (untypes === myUntypes) {
                return this;
              } else {
                return makeUnionType(untypes).complement();
              }
            } else if (other instanceof UnionType) {
              myUntypes = getUntypes(this.untype);
              untypes = relativeComplement(myUntypes, other.types);
              if (untypes === myUntypes) {
                return this;
              } else {
                return makeUnionType(untypes).complement();
              }
            } else if (other instanceof ComplementType) {
              return this.untype.intersect(other.untype).complement();
            } else {
              return other.union(this);
            }
          };
          _ComplementType_prototype.intersect = function (other) {
            var types;
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof SimpleType || other instanceof ArrayType || other instanceof ObjectType || other instanceof FunctionType) {
              if (contains(getUntypes(this.untype), other)) {
                return none;
              } else {
                return other;
              }
            } else if (other instanceof UnionType) {
              types = relativeComplement(other.types, getUntypes(this.untype));
              if (types === other.types) {
                return other;
              } else {
                return makeUnionType(types);
              }
            } else if (other instanceof ComplementType) {
              return this.untype.union(other.untype).complement();
            } else {
              return other.intersect(this);
            }
          };
          _ComplementType_prototype.isSubsetOf = function (other) {
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof ComplementType) {
              return other.untype.isSubsetOf(this.untype);
            } else {
              return other === any;
            }
          };
          _ComplementType_prototype.overlaps = function (other) {
            var _this;
            _this = this;
            if (!(other instanceof Type)) {
              throw TypeError("Expected other to be a Type, got " + __typeof(other));
            }
            if (other instanceof SimpleType || other instanceof ArrayType || other instanceof FunctionType) {
              return !this.untype.overlaps(other);
            } else if (other instanceof ObjectType) {
              return (function () {
                var _arr, _i, untype;
                for (_arr = getUntypes(_this.untype), _i = _arr.length; _i--; ) {
                  untype = _arr[_i];
                  if (untype instanceof ObjectType && other.isSubsetOf(untype)) {
                    return false;
                  }
                }
                return true;
              }());
            } else if (other instanceof UnionType) {
              return relativeComplement(other.types, getUntypes(this.untype)).length > 0;
            } else if (other instanceof ComplementType) {
              return true;
            } else {
              return other.overlaps(this);
            }
          };
          _ComplementType_prototype.complement = function () {
            return this.untype;
          };
          _ComplementType_prototype.inspect = function (depth) {
            return __strnum(this.untype.inspect(depth)) + ".complement()";
          };
          _ComplementType_prototype.toJSON = function () {
            return { type: "complement", untype: this.complement() };
          };
          fromJSONTypes.complement = function (_p) {
            var untype;
            untype = _p.untype;
            return Type.fromJSON(untype).complement();
          };
          return ComplementType;
        }(Type));
        any = Type.any = new (AnyType = (function (Type) {
          var _AnyType_prototype, _Type_prototype2;
          function AnyType() {
            var _this;
            _this = this instanceof AnyType ? this : __create(_AnyType_prototype);
            if (any) {
              throw Error("Cannot instantiate more than once");
            }
            return _this;
          }
          _Type_prototype2 = Type.prototype;
          _AnyType_prototype = AnyType.prototype = __create(_Type_prototype2);
          _AnyType_prototype.constructor = AnyType;
          AnyType.displayName = "AnyType";
          _AnyType_prototype.toString = function () {
            return "any";
          };
          _AnyType_prototype.equals = function (other) {
            return this === other;
          };
          _AnyType_prototype.compare = function (other) {
            if (this === other) {
              return 0;
            } else {
              return __cmp("AnyType", other.constructor.displayName);
            }
          };
          _AnyType_prototype.union = function (other) {
            return this;
          };
          _AnyType_prototype.intersect = function (other) {
            return other;
          };
          _AnyType_prototype.isSubsetOf = function (other) {
            return this === other;
          };
          _AnyType_prototype.overlaps = function (other) {
            return true;
          };
          _AnyType_prototype.complement = function () {
            return none;
          };
          _AnyType_prototype.inspect = function () {
            return "Type.any";
          };
          _AnyType_prototype.toJSON = function () {
            return { type: "any" };
          };
          fromJSONTypes.any = function () {
            return any;
          };
          return AnyType;
        }(Type)))();
        none = Type.none = new (NoneType = (function (Type) {
          var _NoneType_prototype, _Type_prototype2;
          function NoneType() {
            var _this;
            _this = this instanceof NoneType ? this : __create(_NoneType_prototype);
            if (none) {
              throw Error("Cannot instantiate more than once");
            }
            return _this;
          }
          _Type_prototype2 = Type.prototype;
          _NoneType_prototype = NoneType.prototype = __create(_Type_prototype2);
          _NoneType_prototype.constructor = NoneType;
          NoneType.displayName = "NoneType";
          _NoneType_prototype.toString = function () {
            return "none";
          };
          _NoneType_prototype.equals = function (other) {
            return this === other;
          };
          _NoneType_prototype.compare = function (other) {
            if (this === other) {
              return 0;
            } else {
              return __cmp("NoneType", other.constructor.displayName);
            }
          };
          _NoneType_prototype.union = function (other) {
            return other;
          };
          _NoneType_prototype.intersect = function (other) {
            return this;
          };
          _NoneType_prototype.isSubsetOf = function (other) {
            return true;
          };
          _NoneType_prototype.overlaps = function (other) {
            return false;
          };
          _NoneType_prototype.complement = function () {
            return any;
          };
          _NoneType_prototype.inspect = function () {
            return "Type.none";
          };
          _NoneType_prototype.toJSON = function () {
            return { type: "none" };
          };
          fromJSONTypes.none = function () {
            return none;
          };
          return NoneType;
        }(Type)))();
        Type["undefined"] = Type.make("undefined");
        Type["null"] = Type.make("null");
        Type.boolean = Type.make("Boolean");
        Type.string = Type.make("String");
        Type.stringArray = Type.string.array();
        Type.number = Type.make("Number");
        Type.numberArray = Type.number.array();
        Type.array = any.array();
        Type.args = Type.make("Arguments");
        Type.object = Type.makeObject({});
        Type["function"] = any["function"]();
        Type.regexp = Type.make("RegExp");
        Type.date = Type.make("Date");
        Type.error = Type.make("Error");
        Type.numeric = Type.number.union(Type["undefined"]).union(Type["null"]).union(Type.boolean);
        Type.stringOrNumber = Type.string.union(Type.number);
        Type.arrayLike = Type.array.union(Type.args);
        Type.undefinedOrNull = Type["undefined"].union(Type["null"]);
        Type.notUndefinedOrNull = Type.undefinedOrNull.complement();
        Type.primitive = Type.undefinedOrNull.union(Type.boolean).union(Type.string).union(Type.number);
        Type.nonPrimitive = Type.primitive.complement();
        Type.alwaysFalsy = Type.undefinedOrNull;
        Type.potentiallyTruthy = Type.alwaysFalsy.complement();
        Type.potentiallyFalsy = Type.alwaysFalsy.union(Type.number).union(Type.string).union(Type.boolean);
        Type.alwaysTruthy = Type.potentiallyFalsy.complement();
        return Type;
      }());
    }.call(this));
    
    return module.exports;
  }.call({}));
  require['./ast'] = (function () {
    var module = { exports: this };
    var exports = this;
    (function () {
      "use strict";
      var __create, __in, __isArray, __isObject, __lt, __lte, __num, __owns, __slice, __strnum, __toArray, __typeof, Arguments, Arr, Binary, Block, BlockExpression, BlockStatement, Break, Call, Comment, Const, Continue, Debugger, DoWhile, Eval, Expression, For, ForIn, fromJSON, Func, getIndent, Ident, If, IfExpression, IfStatement, INDENT, inspect, isAcceptableIdent, Level, Node, Noop, Obj, Regex, Return, Root, Statement, Switch, This, Throw, toJSSource, TryCatch, TryFinally, Unary, util, While;
      __create = typeof Object.create === "function" ? Object.create
        : function (x) {
          function F() {}
          F.prototype = x;
          return new F();
        };
      __in = typeof Array.prototype.indexOf === "function"
        ? (function () {
          var indexOf;
          indexOf = Array.prototype.indexOf;
          return function (child, parent) {
            return indexOf.call(parent, child) !== -1;
          };
        }())
        : function (child, parent) {
          var i, len;
          len = +parent.length;
          i = -1;
          while (++i < len) {
            if (child === parent[i] && i in parent) {
              return true;
            }
          }
          return false;
        };
      __isArray = typeof Array.isArray === "function" ? Array.isArray
        : (function () {
          var _toString;
          _toString = Object.prototype.toString;
          return function (x) {
            return _toString.call(x) === "[object Array]";
          };
        }());
      __isObject = function (x) {
        return typeof x === "object" && x !== null;
      };
      __lt = function (x, y) {
        var type;
        type = typeof x;
        if (type !== "number" && type !== "string") {
          throw TypeError("Cannot compare a non-number/string: " + type);
        } else if (type !== typeof y) {
          throw TypeError("Cannot compare elements of different types: " + type + " vs " + typeof y);
        } else {
          return x < y;
        }
      };
      __lte = function (x, y) {
        var type;
        type = typeof x;
        if (type !== "number" && type !== "string") {
          throw TypeError("Cannot compare a non-number/string: " + type);
        } else if (type !== typeof y) {
          throw TypeError("Cannot compare elements of different types: " + type + " vs " + typeof y);
        } else {
          return x <= y;
        }
      };
      __num = function (num) {
        if (typeof num !== "number") {
          throw TypeError("Expected a number, got " + __typeof(num));
        } else {
          return num;
        }
      };
      __owns = Object.prototype.hasOwnProperty;
      __slice = Array.prototype.slice;
      __strnum = function (strnum) {
        var type;
        type = typeof strnum;
        if (type === "string") {
          return strnum;
        } else if (type === "number") {
          return String(strnum);
        } else {
          throw TypeError("Expected a string or number, got " + __typeof(strnum));
        }
      };
      __toArray = function (x) {
        if (x == null) {
          throw TypeError("Expected an object, got " + __typeof(x));
        } else if (__isArray(x)) {
          return x;
        } else if (typeof x === "string") {
          return x.split("");
        } else {
          return __slice.call(x);
        }
      };
      __typeof = (function () {
        var _toString;
        _toString = Object.prototype.toString;
        return function (o) {
          if (o === void 0) {
            return "Undefined";
          } else if (o === null) {
            return "Null";
          } else {
            return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);
          }
        };
      }());
      util = require("util");
      if (util != null) {
        inspect = util.inspect;
      }
      Level = (function () {
        this.block = 1;
        this.insideParentheses = 2;
        this.sequence = 3;
        this.assignment = 4;
        this.inlineCondition = 5;
        this.logicalOr = 6;
        this.logicalAnd = 7;
        this.bitwiseOr = 8;
        this.bitwiseAnd = 9;
        this.bitwiseXor = 10;
        this.equality = 11;
        this.relational = 12;
        this.bitwiseShift = 13;
        this.addition = 14;
        this.multiplication = 15;
        this.unary = 16;
        this.increment = 17;
        this.callOrAccess = 18;
        this.newCall = 19;
        return this;
      }.call({}));
      INDENT = "  ";
      function incIndent(options) {
        var clone;
        clone = __create(options);
        clone.indent = __num(clone.indent) + 1;
        return clone;
      }
      getIndent = (function () {
        var cache;
        cache = [""];
        return function (indent) {
          var i, result;
          if (__num(indent) >= cache.length) {
            result = cache[cache.length - 1];
            for (i = cache.length, __num(indent); i <= indent; ++i) {
              result = __strnum(result) + INDENT;
              cache.push(result);
            }
          }
          return cache[indent];
        };
      }());
      function StringWriter(callback) {
        function sw(item) {
          callback(item);
        }
        sw.indent = function (count) {
          callback(getIndent(count));
        };
        return sw;
      }
      function StringBuilder() {
        var data;
        data = [];
        function sb(item) {
          data.push(item);
        }
        sb.indent = function (count) {
          data.push(getIndent(count));
        };
        sb.toString = function () {
          var text;
          switch (data.length) {
          case 0: return "";
          case 1: return data[0];
          default:
            text = data.join("");
            data.splice(0, data.length, text);
            return text;
          }
        };
        return sb;
      }
      function isNegative(value) {
        return __num(value) < 0 || 1 / __num(value) < 0;
      }
      function unicodeReplacer(m) {
        var num;
        num = m.charCodeAt(0).toString(16);
        switch (num.length) {
        case 1: return "\\u000" + __strnum(num);
        case 2: return "\\u00" + __strnum(num);
        case 3: return "\\u0" + __strnum(num);
        case 4: return "\\u" + __strnum(num);
        default: throw Error();
        }
      }
      toJSSource = (function () {
        var toJSSourceTypes;
        toJSSourceTypes = {
          "undefined": function () {
            return "void 0";
          },
          number: function (value) {
            if (value === 0) {
              if (isNegative(value)) {
                return "-0";
              } else {
                return "0";
              }
            } else if (isFinite(value)) {
              return String(value);
            } else if (value !== value) {
              return "0/0";
            } else if (__num(value) > 0) {
              return "1/0";
            } else {
              return "-1/0";
            }
          },
          string: (function () {
            var DOUBLE_QUOTE_REGEX, SINGLE_QUOTE_REGEX;
            function escapeHelper(m) {
              switch (m) {
              case "\b": return "\\b";
              case "\t": return "\\t";
              case "\n": return "\\n";
              case "\f": return "\\f";
              case "\r": return "\\r";
              case "\n": return "\\n";
              case '"': return '\\"';
              case "'": return "\\'";
              case "\\": return "\\\\";
              default: return unicodeReplacer(m);
              }
            }
            DOUBLE_QUOTE_REGEX = /[\u0000-\u001f"\\\u0080-\uffff]/g;
            SINGLE_QUOTE_REGEX = /[\u0000-\u001f'\\\u0080-\uffff]/g;
            return function (value) {
              if (value.indexOf('"') === -1 || value.indexOf("'") !== -1) {
                return '"' + __strnum(value.replace(DOUBLE_QUOTE_REGEX, escapeHelper)) + '"';
              } else {
                return "'" + __strnum(value.replace(SINGLE_QUOTE_REGEX, escapeHelper)) + "'";
              }
            };
          }()),
          boolean: function (value) {
            if (value) {
              return "true";
            } else {
              return "false";
            }
          },
          object: function (value) {
            if (value === null) {
              return "null";
            } else {
              throw Error();
            }
          }
        };
        return function (value) {
          var _ref, f;
          if (__owns.call(toJSSourceTypes, _ref = typeof value)) {
            f = toJSSourceTypes[_ref];
          }
          if (!f) {
            throw TypeError("Cannot compile const " + __typeof(value));
          }
          return f(value);
        };
      }());
      isAcceptableIdent = exports.isAcceptableIdent = (function () {
        var IDENTIFIER_REGEX, IDENTIFIER_UNICODE_REGEX, RESERVED;
        IDENTIFIER_REGEX = /^[a-zA-Z_\$][a-zA-Z_\$0-9]*$/;
        IDENTIFIER_UNICODE_REGEX = /^[a-zA-Z_\$\u00a0-\uffff][a-zA-Z_\$0-9\u00a0-\uffff]*$/;
        RESERVED = [
          "arguments",
          "break",
          "case",
          "catch",
          "class",
          "const",
          "continue",
          "debugger",
          "default",
          "delete",
          "do",
          "else",
          "enum",
          "export",
          "extends",
          "eval",
          "false",
          "finally",
          "for",
          "function",
          "if",
          "implements",
          "import",
          "in",
          "Infinity",
          "instanceof",
          "interface",
          "let",
          "NaN",
          "new",
          "null",
          "package",
          "private",
          "protected",
          "public",
          "return",
          "static",
          "super",
          "switch",
          "this",
          "throw",
          "true",
          "try",
          "typeof",
          "undefined",
          "var",
          "void",
          "while",
          "with",
          "yield"
        ];
        return function (name, allowUnicode) {
          var regex;
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (allowUnicode == null) {
            allowUnicode = false;
          } else if (typeof allowUnicode !== "boolean") {
            throw TypeError("Expected allowUnicode to be a Boolean, got " + __typeof(allowUnicode));
          }
          if (allowUnicode) {
            regex = IDENTIFIER_UNICODE_REGEX;
          } else {
            regex = IDENTIFIER_REGEX;
          }
          return regex.test(name) && !__in(name, RESERVED);
        };
      }());
      exports.Node = Node = (function () {
        var _Node_prototype;
        function Node() {
          var _this;
          _this = this instanceof Node ? this : __create(_Node_prototype);
          throw Error("Node cannot be instantiated directly");
        }
        _Node_prototype = Node.prototype;
        Node.displayName = "Node";
        _Node_prototype.toString = function () {
          var sb;
          sb = StringBuilder();
          this.compileAsStatement(
            { indent: 0, bare: true },
            true,
            sb
          );
          return sb.toString();
        };
        _Node_prototype.toFunction = function () {
          return new Function(this.toString());
        };
        _Node_prototype.compile = function () {
          throw Error("compile not implemented: " + __strnum(this.constructor.name));
        };
        _Node_prototype.maybeToStatement = function () {
          if (typeof this.toStatement === "function") {
            return this.toStatement();
          } else {
            return this;
          }
        };
        _Node_prototype.isConst = function () {
          return false;
        };
        _Node_prototype.isNoop = function () {
          return false;
        };
        _Node_prototype.constValue = function () {
          throw Error(__strnum(this.constructor.name) + " has no const value");
        };
        _Node_prototype.isLarge = function () {
          return true;
        };
        _Node_prototype.isSmall = function () {
          return !this.isLarge();
        };
        _Node_prototype.mutateLast = function () {
          return this;
        };
        _Node_prototype.exitType = function () {
          return null;
        };
        _Node_prototype.last = function () {
          return this;
        };
        return Node;
      }());
      exports.Expression = Expression = (function (Node) {
        var _Expression_prototype, _Node_prototype;
        function Expression() {
          var _this;
          _this = this instanceof Expression ? this : __create(_Expression_prototype);
          throw Error("Expression cannot be instantiated directly");
        }
        _Node_prototype = Node.prototype;
        _Expression_prototype = Expression.prototype = __create(_Node_prototype);
        _Expression_prototype.constructor = Expression;
        Expression.displayName = "Expression";
        _Expression_prototype.compileAsBlock = function (options, level, lineStart, sb) {
          this.compile(options, level, lineStart, sb);
        };
        _Expression_prototype.compileAsStatement = function (options, lineStart, sb) {
          if (typeof this.toStatement === "function") {
            this.toStatement().compileAsStatement(options, lineStart, sb);
          } else {
            this.compile(options, Level.block, lineStart, sb);
            sb(";");
          }
        };
        _Expression_prototype.isLarge = function () {
          return false;
        };
        _Expression_prototype.mutateLast = function (func) {
          return func(this);
        };
        return Expression;
      }(Node));
      exports.Statement = Statement = (function (Node) {
        var _Node_prototype, _Statement_prototype;
        function Statement() {
          var _this;
          _this = this instanceof Statement ? this : __create(_Statement_prototype);
          throw Error("Expression cannot be instantiated directly");
        }
        _Node_prototype = Node.prototype;
        _Statement_prototype = Statement.prototype = __create(_Node_prototype);
        _Statement_prototype.constructor = Statement;
        Statement.displayName = "Statement";
        _Statement_prototype.compileAsStatement = function (options, lineStart, sb) {
          return this.compile(options, Level.block, lineStart, sb);
        };
        return Statement;
      }(Node));
      exports.Access = function (parent) {
        var _i, _len, child, children, current;
        children = __slice.call(arguments, 1);
        current = parent;
        for (_i = 0, _len = children.length; _i < _len; ++_i) {
          child = children[_i];
          current = Binary(current, ".", child);
        }
        return current;
      };
      exports.Arguments = Arguments = (function (Expression) {
        var _Arguments_prototype, _Expression_prototype;
        function Arguments() {
          var _this;
          _this = this instanceof Arguments ? this : __create(_Arguments_prototype);
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _Arguments_prototype = Arguments.prototype = __create(_Expression_prototype);
        _Arguments_prototype.constructor = Arguments;
        Arguments.displayName = "Arguments";
        _Arguments_prototype.compile = function (options, level, lineStart, sb) {
          sb("arguments");
        };
        _Arguments_prototype.compileAsBlock = function (options, level, lineStart, sb) {
          Noop().compileAsBlock(options, level, lineStart, sb);
        };
        _Arguments_prototype.walk = function () {
          return this;
        };
        _Arguments_prototype.isNoop = function () {
          return true;
        };
        _Arguments_prototype.inspect = function (depth) {
          return "Arguments()";
        };
        _Arguments_prototype.toJSON = function () {
          return { type: "Arguments" };
        };
        Arguments.fromJSON = function () {
          return Arguments();
        };
        return Arguments;
      }(Expression));
      function walkArray(array, walker) {
        var _arr, _i, _len, changed, item, newItem, result;
        if (!__isArray(array)) {
          throw TypeError("Expected array to be an Array, got " + __typeof(array));
        }
        if (typeof walker !== "function") {
          throw TypeError("Expected walker to be a Function, got " + __typeof(walker));
        }
        changed = false;
        for (_arr = [], _i = 0, _len = array.length; _i < _len; ++_i) {
          item = array[_i];
          newItem = walker(item);
          if (newItem == null) {
            newItem = item.walk(walker);
          }
          if (item !== newItem) {
            changed = true;
          }
          _arr.push(newItem);
        }
        result = _arr;
        if (changed) {
          return result;
        } else {
          return array;
        }
      }
      function decDepth(depth) {
        if (depth != null) {
          return __num(depth) - 1;
        } else {
          return null;
        }
      }
      function inspectHelper(depth, name) {
        var _arr, _i, _len, arg, args, d, found, hasLarge, parts;
        args = __slice.call(arguments, 2);
        d = decDepth(depth);
        found = false;
        for (_i = args.length; _i--; ) {
          arg = args[_i];
          if (!arg || arg instanceof Noop || __isArray(arg) && arg.length === 0) {
            args.pop();
          } else {
            break;
          }
        }
        for (_arr = [], _i = 0, _len = args.length; _i < _len; ++_i) {
          arg = args[_i];
          _arr.push(inspect(arg, null, d));
        }
        parts = _arr;
        hasLarge = (function () {
          var _i, _len, part;
          for (_i = 0, _len = parts.length; _i < _len; ++_i) {
            part = parts[_i];
            if (parts.length > 50 || part.indexOf("\n") !== -1) {
              return true;
            }
          }
          return false;
        }());
        if (hasLarge) {
          parts = (function () {
            var _arr, _i, _len, part;
            for (_arr = [], _i = 0, _len = parts.length; _i < _len; ++_i) {
              part = parts[_i];
              _arr.push("  " + __strnum(part.split("\n").join("\n  ")));
            }
            return _arr;
          }());
          return __strnum(name) + "(\n" + __strnum(parts.join(",\n")) + ")";
        } else {
          return __strnum(name) + "(" + __strnum(parts.join(", ")) + ")";
        }
      }
      function simplify(obj) {
        if (Array.isArray(obj)) {
          if (obj.length === 0) {
            return;
          } else {
            return obj;
          }
        } else if (obj instanceof Noop) {
          return;
        } else {
          return obj;
        }
      }
      exports.Arr = Arr = (function (Expression) {
        var _Arr_prototype, _Expression_prototype;
        function Arr(elements) {
          var _i, _len, _this;
          _this = this instanceof Arr ? this : __create(_Arr_prototype);
          if (elements == null) {
            elements = [];
          } else if (!__isArray(elements)) {
            throw TypeError("Expected elements to be an Array, got " + __typeof(elements));
          } else {
            for (_i = 0, _len = elements.length; _i < _len; ++_i) {
              if (!(elements[_i] instanceof Expression)) {
                throw TypeError("Expected elements[" + _i + "] to be an Expression, got " + __typeof(elements[_i]));
              }
            }
          }
          _this.elements = elements;
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _Arr_prototype = Arr.prototype = __create(_Expression_prototype);
        _Arr_prototype.constructor = Arr;
        Arr.displayName = "Arr";
        function compileLarge(elements, options, level, lineStart, sb) {
          var _arr, childOptions, i, item, len;
          childOptions = incIndent(options);
          for (_arr = __toArray(elements), i = 0, len = _arr.length; i < len; ++i) {
            item = _arr[i];
            sb("\n");
            sb.indent(childOptions.indent);
            item.compile(childOptions, Level.sequence, false, sb);
            if (i < len - 1) {
              sb(",");
            }
          }
          sb("\n");
          sb.indent(options.indent);
        }
        function compileSmall(elements, options, level, lineStart, sb) {
          var _arr, _len, i, item;
          if (elements.length) {
            for (_arr = __toArray(elements), i = 0, _len = _arr.length; i < _len; ++i) {
              item = _arr[i];
              if (i > 0) {
                sb(", ");
              }
              item.compile(options, Level.sequence, false, sb);
            }
          }
        }
        _Arr_prototype.compile = function (options, level, lineStart, sb) {
          var f;
          sb("[");
          if (this.shouldCompileLarge()) {
            f = compileLarge;
          } else {
            f = compileSmall;
          }
          f(
            this.elements,
            options,
            level,
            lineStart,
            sb
          );
          sb("]");
        };
        _Arr_prototype.compileAsBlock = function (options, level, lineStart, sb) {
          return BlockExpression(this.elements).compileAsBlock(options, level, lineStart, sb);
        };
        _Arr_prototype.compileAsStatement = function (options, lineStart, sb) {
          BlockStatement(this.elements).compile(options, lineStart, sb);
        };
        _Arr_prototype.shouldCompileLarge = function () {
          switch (this.elements.length) {
          case 0: return false;
          case 1: return this.elements[0].isLarge();
          default: return this.isLarge();
          }
        };
        _Arr_prototype.isSmall = function () {
          switch (this.elements.length) {
          case 0: return true;
          case 1: return this.elements[0].isSmall();
          default: return false;
          }
        };
        _Arr_prototype.isLarge = function () {
          var _ref, _this;
          _this = this;
          if ((_ref = this._isLarge) == null) {
            return this._isLarge = __num(this.elements.length) > 4 || (function () {
              var _arr, _i, element;
              for (_arr = __toArray(_this.elements), _i = _arr.length; _i--; ) {
                element = _arr[_i];
                if (!element.isSmall()) {
                  return true;
                }
              }
              return false;
            }());
          } else {
            return _ref;
          }
        };
        _Arr_prototype.isNoop = function () {
          var _ref, _this;
          _this = this;
          if ((_ref = this._isNoop) == null) {
            return this._isNoop = (function () {
              var _arr, _i, element;
              for (_arr = __toArray(_this.elements), _i = _arr.length; _i--; ) {
                element = _arr[_i];
                if (!element.isNoop()) {
                  return false;
                }
              }
              return true;
            }());
          } else {
            return _ref;
          }
        };
        _Arr_prototype.walk = function (walker) {
          var elements;
          elements = walkArray(this.elements, walker);
          if (this.elements !== elements) {
            return Arr(elements);
          } else {
            return this;
          }
        };
        _Arr_prototype.inspect = function (depth) {
          return inspectHelper(depth, "Arr", this.elements);
        };
        _Arr_prototype.toJSON = function () {
          return { type: "Arr", elements: simplify(this.elements) };
        };
        Arr.fromJSON = function (_p) {
          var elements;
          elements = _p.elements;
          return Arr(arrayFromJSON(elements));
        };
        return Arr;
      }(Expression));
      exports.Assign = function (left, right) {
        return Binary(left, "=", right);
      };
      exports.BinaryChain = function (op) {
        var _i, _len, arg, args, current, i, left, right;
        args = __slice.call(arguments, 1);
        if (op === "+") {
          for (i = args.length - 2; i >= 0; --i) {
            left = args[i];
            right = args[i + 1];
            if ((typeof left === "string" || left instanceof Const && typeof left.value === "string") && (typeof right === "string" || right instanceof Const && typeof right.value === "string")) {
              args.splice(i, 2, __strnum(typeof left === "string" ? left : left.value) + __strnum(typeof right === "string" ? right : right.value));
            }
          }
        }
        current = args[0];
        for (_i = 1, _len = args.length; _i < _len; ++_i) {
          arg = args[_i];
          current = Binary(current, op, arg);
        }
        return current;
      };
      exports.And = function () {
        var _end, args, current, i;
        args = __slice.call(arguments);
        if (args.length === 0) {
          return Const(true);
        } else {
          current = args[0];
          for (i = 1, _end = args.length; i < _end; ++i) {
            current = Binary(current, "&&", args[i]);
          }
          return current;
        }
      };
      exports.Or = function () {
        var _end, args, current, i;
        args = __slice.call(arguments);
        if (args.length === 0) {
          return Const(false);
        } else {
          current = args[0];
          for (i = 1, _end = args.length; i < _end; ++i) {
            current = Binary(current, "||", args[i]);
          }
          return current;
        }
      };
      exports.Binary = Binary = (function (Expression) {
        var _Binary_prototype, _Expression_prototype, _o, ASSIGNMENT_OPS, LEVEL_TO_ASSOCIATIVITY, OPERATOR_PRECEDENCE;
        function Binary(left, op, right) {
          var _this;
          _this = this instanceof Binary ? this : __create(_Binary_prototype);
          if (left == null) {
            left = Noop();
          }
          if (typeof op !== "string") {
            throw TypeError("Expected op to be a String, got " + __typeof(op));
          }
          _this.op = op;
          if (right == null) {
            right = Noop();
          }
          if (!__owns.call(OPERATOR_PRECEDENCE, op)) {
            throw Error("Unknown binary operator: " + toJSSource(op));
          }
          if (!(left instanceof Expression)) {
            left = toConst(left);
          }
          if (!(right instanceof Expression)) {
            right = toConst(right);
          }
          _this.left = left;
          _this.right = right;
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _Binary_prototype = Binary.prototype = __create(_Expression_prototype);
        _Binary_prototype.constructor = Binary;
        Binary.displayName = "Binary";
        function compileAccess(op, left, right, options, level, lineStart, sb) {
          var dotAccess, stringLeft, wrap;
          dotAccess = right instanceof Const && typeof right.value === "string" && isAcceptableIdent(right.value);
          wrap = !__lte(level, Level.callOrAccess);
          if (wrap) {
            sb("(");
          }
          if (left instanceof Const && typeof left.value === "number") {
            stringLeft = toJSSource(left.value);
            if (isNegative(left.value) || !isFinite(left.value)) {
              sb("(");
              sb(stringLeft);
              sb(")");
            } else {
              sb(stringLeft);
              if (dotAccess && stringLeft.indexOf("e") === -1 && stringLeft.indexOf(".") === -1) {
                sb(".");
              }
            }
          } else if (left.isConst() && left.constValue() === void 0) {
            sb("(");
            (left instanceof Const ? left : Const(void 0)).compile(options, Level.insideParentheses, false, sb);
            sb(")");
          } else {
            left.compile(options, Level.callOrAccess, lineStart, sb);
          }
          if (dotAccess) {
            sb(".");
            sb(right.value);
          } else {
            sb("[");
            right.compile(options, Level.insideParentheses, false, sb);
            sb("]");
          }
          if (wrap) {
            sb(")");
          }
        }
        function compileOther(op, left, right, options, level, lineStart, sb) {
          var associativity, opLevel, wrap;
          opLevel = OPERATOR_PRECEDENCE[op];
          associativity = LEVEL_TO_ASSOCIATIVITY[opLevel];
          if (associativity === "paren") {
            wrap = !__lt(level, opLevel);
          } else {
            wrap = !__lte(level, opLevel);
          }
          if (wrap) {
            sb("(");
          }
          left.compile(
            options,
            associativity === "right" && left instanceof Binary && OPERATOR_PRECEDENCE[left.op] === opLevel ? __num(opLevel) + 1 : opLevel,
            lineStart && !wrap,
            sb
          );
          sb(" ");
          sb(op);
          sb(" ");
          right.compile(
            options,
            associativity === "left" && right instanceof Binary && OPERATOR_PRECEDENCE[right.op] === opLevel ? __num(opLevel) + 1 : opLevel,
            false,
            sb
          );
          if (wrap) {
            sb(")");
          }
        }
        _Binary_prototype.compile = function (options, level, lineStart, sb) {
          var f;
          if (this.op === ".") {
            f = compileAccess;
          } else {
            f = compileOther;
          }
          f(
            this.op,
            this.left,
            this.right,
            options,
            level,
            lineStart,
            sb
          );
        };
        _Binary_prototype.compileAsBlock = function (options, level, lineStart, sb) {
          var _ref;
          if (__owns.call(ASSIGNMENT_OPS, this.op) || (_ref = this.op) === "&&" || _ref === "||") {
            _Expression_prototype.compileAsBlock.call(
              this,
              options,
              level,
              lineStart,
              sb
            );
          } else {
            BlockExpression([this.left, this.right]).compileAsBlock(options, level, lineStart, sb);
          }
        };
        _Binary_prototype.compileAsStatement = function (options, lineStart, sb) {
          var left, op;
          left = this.left;
          op = this.op;
          if (__owns.call(ASSIGNMENT_OPS, op)) {
            if (left instanceof Ident && typeof this.right.toStatement === "function" && false) {
              this.right.toStatement().mutateLast(
                function (node) {
                  return Binary(left, op, node);
                },
                true
              ).compileAsStatement(options, lineStart, sb);
            } else {
              _Expression_prototype.compileAsStatement.call(this, options, lineStart, sb);
            }
          } else {
            BlockStatement([this.left, this.right]).compileAsStatement(options, lineStart, sb);
          }
        };
        ASSIGNMENT_OPS = {
          "=": true,
          "+=": true,
          "-=": true,
          "*=": true,
          "/=": true,
          "%=": true,
          "<<=": true,
          ">>=": true,
          ">>>=": true,
          "&=": true,
          "^=": true,
          "|=": true
        };
        OPERATOR_PRECEDENCE = {
          ".": Level.callOrAccess,
          "*": Level.multiplication,
          "/": Level.multiplication,
          "%": Level.multiplication,
          "+": Level.addition,
          "-": Level.addition,
          "<<": Level.bitwiseShift,
          ">>": Level.bitwiseShift,
          ">>>": Level.bitwiseShift,
          "<": Level.relational,
          "<=": Level.relational,
          ">": Level.relational,
          ">=": Level.relational,
          "in": Level.relational,
          "instanceof": Level.relational,
          "==": Level.equality,
          "!=": Level.equality,
          "===": Level.equality,
          "!==": Level.equality,
          "&": Level.bitwiseAnd,
          "^": Level.bitwiseXor,
          "|": Level.bitwiseOr,
          "&&": Level.logicalAnd,
          "||": Level.logicalOr,
          "=": Level.assignment,
          "+=": Level.assignment,
          "-=": Level.assignment,
          "*=": Level.assignment,
          "/=": Level.assignment,
          "%=": Level.assignment,
          "<<=": Level.assignment,
          ">>=": Level.assignment,
          ">>>=": Level.assignment,
          "&=": Level.assignment,
          "^=": Level.assignment,
          "|=": Level.assignment
        };
        LEVEL_TO_ASSOCIATIVITY = (_o = {}, _o[Level.equality] = "paren", _o[Level.relational] = "paren", _o[Level.addition] = "left", _o[Level.multiplication] = "left", _o[Level.bitwiseAnd] = "none", _o[Level.bitwiseOr] = "none", _o[Level.bitwiseXor] = "none", _o[Level.bitwiseShift] = "left", _o[Level.assignment] = "right", _o);
        _Binary_prototype.isLarge = function () {
          var _ref;
          if ((_ref = this._isLarge) == null) {
            return this._isLarge = !this.left.isSmall() || !this.right.isSmall();
          } else {
            return _ref;
          }
        };
        _Binary_prototype.isSmall = function () {
          var _ref;
          if ((_ref = this._isSmall) == null) {
            return this._isSmall = this.left.isSmall() && this.right.isSmall();
          } else {
            return _ref;
          }
        };
        _Binary_prototype.isNoop = function () {
          var _ref;
          if ((_ref = this._isNoop) == null) {
            return this._isNoop = !__owns.call(ASSIGNMENT_OPS, this.op) && this.left.isNoop() && this.right.isNoop();
          } else {
            return _ref;
          }
        };
        _Binary_prototype.walk = function (walker) {
          var _ref, changed, left, right;
          changed = false;
          if ((_ref = walker(this.left)) != null) {
            left = _ref;
          } else {
            left = this.left.walk(walker);
          }
          if ((_ref = walker(this.right)) != null) {
            right = _ref;
          } else {
            right = this.right.walk(walker);
          }
          if (this.left !== left || this.right !== right) {
            return Binary(left, this.op, right);
          } else {
            return this;
          }
        };
        _Binary_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "Binary",
            this.left,
            this.op,
            this.right
          );
        };
        _Binary_prototype.toJSON = function () {
          return { type: "Binary", left: simplify(this.left), op: this.op, right: simplify(this.right) };
        };
        Binary.fromJSON = function (_p) {
          var left, op, right;
          left = _p.left;
          op = _p.op;
          right = _p.right;
          return Binary(fromJSON(left), op, fromJSON(right));
        };
        return Binary;
      }(Expression));
      exports.BlockStatement = BlockStatement = (function (Statement) {
        var _BlockStatement_prototype, _Statement_prototype;
        function BlockStatement(body, label) {
          var _i, _len, _this, item, result, statement;
          _this = this instanceof BlockStatement ? this : __create(_BlockStatement_prototype);
          if (body == null) {
            body = [];
          } else if (!__isArray(body)) {
            throw TypeError("Expected body to be an Array, got " + __typeof(body));
          } else {
            for (_i = 0, _len = body.length; _i < _len; ++_i) {
              if (!(body[_i] instanceof Node)) {
                throw TypeError("Expected body[" + _i + "] to be a Node, got " + __typeof(body[_i]));
              }
            }
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof Ident)) {
            throw TypeError("Expected label to be an Ident or null, got " + __typeof(label));
          }
          _this.label = label;
          result = [];
          for (_i = 0, _len = body.length; _i < _len; ++_i) {
            item = body[_i];
            statement = item.maybeToStatement();
            if (statement instanceof BlockStatement && !statement.label) {
              result.push.apply(result, __toArray(statement.body));
            } else if (!(statement instanceof Noop)) {
              result.push(statement);
            }
            if (statement.exitType() != null) {
              break;
            }
          }
          switch (result.length) {
          case 0: return Noop();
          case 1: return result[0];
          }
          _this.body = result;
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _BlockStatement_prototype = BlockStatement.prototype = __create(_Statement_prototype);
        _BlockStatement_prototype.constructor = BlockStatement;
        BlockStatement.displayName = "BlockStatement";
        _BlockStatement_prototype.compile = function (options, level, lineStart, sb) {
          var _arr, _arr2, _i, _len, childOptions, i, item, node, nodes;
          if (level !== Level.block) {
            throw Error("Cannot compile a statement except on the Block level");
          }
          for (_arr = [], _arr2 = __toArray(this.body), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
            node = _arr2[_i];
            if (!node.isNoop()) {
              _arr.push(node);
            }
          }
          nodes = _arr;
          if (this.label != null) {
            childOptions = incIndent(options);
          } else {
            childOptions = options;
          }
          if (this.label != null) {
            this.label.compile(options, level, lineStart, sb);
            sb(": {\n");
            sb.indent(childOptions.indent);
          }
          for (i = 0, _len = nodes.length; i < _len; ++i) {
            item = nodes[i];
            if (i > 0) {
              sb("\n");
              sb.indent(childOptions.indent);
            }
            item.compileAsStatement(childOptions, true, sb);
          }
          if (this.label != null) {
            sb("\n");
            sb.indent(options.indent);
            sb("}");
          }
        };
        _BlockStatement_prototype.walk = function (walker) {
          var _ref, body, label;
          body = walkArray(this.body, walker);
          if (this.label != null) {
            if ((_ref = walker(this.label)) != null) {
              label = _ref;
            } else {
              label = this.label.walk(walker);
            }
          } else {
            label = this.label;
          }
          if (this.body !== body || this.label !== label) {
            return Block(body, label);
          } else {
            return this;
          }
        };
        _BlockStatement_prototype.mutateLast = function (func, includeNoop) {
          var body, last, newLast;
          last = this.last();
          newLast = last.mutateLast(func, includeNoop);
          if (last !== newLast) {
            body = __slice.call(this.body, 0, -1);
            body.push(newLast);
            return Block(body);
          } else {
            return this;
          }
        };
        _BlockStatement_prototype.exitType = function () {
          return this.last().exitType();
        };
        _BlockStatement_prototype.last = function () {
          var _ref;
          return (_ref = this.body)[__num(_ref.length) - 1];
        };
        _BlockStatement_prototype.isNoop = function () {
          var _ref, _this;
          _this = this;
          if ((_ref = this._isNoop) == null) {
            return this._isNoop = (function () {
              var _arr, _i, node;
              for (_arr = __toArray(_this.body), _i = _arr.length; _i--; ) {
                node = _arr[_i];
                if (!node.isNoop()) {
                  return false;
                }
              }
              return true;
            }());
          } else {
            return _ref;
          }
        };
        _BlockStatement_prototype.inspect = function (depth) {
          return inspectHelper(depth, "BlockStatement", this.body, this.label);
        };
        _BlockStatement_prototype.toJSON = function () {
          var _ref;
          return {
            type: "BlockStatement",
            body: this.body,
            label: (_ref = this.label) != null ? _ref : void 0
          };
        };
        BlockStatement.fromJSON = function (_p) {
          var body, label;
          body = _p.body;
          label = _p.label;
          return BlockStatement(arrayFromJSON(body), label != null ? fromJSON(label) : null);
        };
        return BlockStatement;
      }(Statement));
      exports.BlockExpression = BlockExpression = (function (Expression) {
        var _BlockExpression_prototype, _Expression_prototype;
        function BlockExpression(body) {
          var _i, _len, _this, i, item, len, result;
          _this = this instanceof BlockExpression ? this : __create(_BlockExpression_prototype);
          if (body == null) {
            body = [];
          } else if (!__isArray(body)) {
            throw TypeError("Expected body to be an Array, got " + __typeof(body));
          } else {
            for (_i = 0, _len = body.length; _i < _len; ++_i) {
              if (!(body[_i] instanceof Expression)) {
                throw TypeError("Expected body[" + _i + "] to be an Expression, got " + __typeof(body[_i]));
              }
            }
          }
          result = [];
          for (i = 0, len = body.length; i < len; ++i) {
            item = body[i];
            if (i === len - 1 || !(!item instanceof Noop)) {
              if (item instanceof BlockExpression) {
                result.push.apply(result, __toArray(item.body));
                if (i < len - 1 && result[result.length - 1] instanceof Noop) {
                  result.pop();
                }
              } else if (!(item instanceof Noop)) {
                result.push(item);
              }
            }
          }
          switch (result.length) {
          case 0: return Noop();
          case 1: return result[0];
          }
          _this.body = result;
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _BlockExpression_prototype = BlockExpression.prototype = __create(_Expression_prototype);
        _BlockExpression_prototype.constructor = BlockExpression;
        BlockExpression.displayName = "BlockExpression";
        _BlockExpression_prototype.toStatement = function () {
          return BlockStatement(this.body);
        };
        _BlockExpression_prototype.compile = function (options, level, lineStart, sb) {
          var _arr, _arr2, _len, i, item, len, node, nodes, wrap;
          if (level === Level.block) {
            this.toStatement().compile(options, level, lineStart, sb);
          } else {
            for (_arr = [], _arr2 = __toArray(this.body), i = 0, len = _arr2.length; i < len; ++i) {
              node = _arr2[i];
              if (!node.isNoop() || i === len - 1) {
                _arr.push(node);
              }
            }
            nodes = _arr;
            wrap = !__lte(level, Level.insideParentheses) && nodes.length > 1;
            if (wrap) {
              sb("(");
            }
            for (i = 0, _len = nodes.length; i < _len; ++i) {
              item = nodes[i];
              if (i > 0) {
                sb(", ");
              }
              item.compile(
                options,
                wrap ? Level.sequence : level,
                false,
                sb
              );
            }
            if (wrap) {
              sb(")");
            }
          }
        };
        _BlockExpression_prototype.compileAsBlock = function (options, level, lineStart, sb) {
          var _arr, _arr2, _len, i, item, len, node, nodes, wrap;
          if (level === Level.block) {
            this.compile(options, level, lineStart, sb);
          } else {
            for (_arr = [], _arr2 = __toArray(this.body), i = 0, len = _arr2.length; i < len; ++i) {
              node = _arr2[i];
              if (!node.isNoop()) {
                _arr.push(node);
              }
            }
            nodes = _arr;
            wrap = !__lte(level, Level.insideParentheses) && nodes.length > 1;
            if (wrap) {
              sb("(");
            }
            for (i = 0, _len = nodes.length; i < _len; ++i) {
              item = nodes[i];
              if (i > 0) {
                sb(", ");
              }
              item.compileAsBlock(
                options,
                wrap ? Level.sequence : level,
                false,
                sb
              );
            }
            if (wrap) {
              sb(")");
            }
          }
        };
        _BlockExpression_prototype.isLarge = function () {
          var _ref, _this;
          _this = this;
          if ((_ref = this._isLarge) == null) {
            return this._isLarge = __num(this.body.length) > 4 || (function () {
              var _arr, _i, part;
              for (_arr = __toArray(_this.body), _i = _arr.length; _i--; ) {
                part = _arr[_i];
                if (part.isLarge()) {
                  return true;
                }
              }
              return false;
            }());
          } else {
            return _ref;
          }
        };
        _BlockExpression_prototype.isSmall = function () {
          return false;
        };
        _BlockExpression_prototype.isNoop = function () {
          var _ref, _this;
          _this = this;
          if ((_ref = this._isNoop) == null) {
            return this._isNoop = (function () {
              var _arr, _i, node;
              for (_arr = __toArray(_this.body), _i = _arr.length; _i--; ) {
                node = _arr[_i];
                if (!node.isNoop()) {
                  return false;
                }
              }
              return true;
            }());
          } else {
            return _ref;
          }
        };
        _BlockExpression_prototype.walk = BlockStatement.prototype.walk;
        _BlockExpression_prototype.last = function () {
          var _ref;
          return (_ref = this.body)[__num(_ref.length) - 1];
        };
        _BlockExpression_prototype.inspect = function (depth) {
          return inspectHelper(depth, "BlockExpression", this.body);
        };
        _BlockExpression_prototype.toJSON = function () {
          return { type: "BlockExpression", body: this.body };
        };
        BlockExpression.fromJSON = function (_p) {
          var body;
          body = _p.body;
          return BlockExpression(arrayFromJSON(body));
        };
        return BlockExpression;
      }(Expression));
      Block = exports.Block = function (body, label) {
        var _i, _len;
        if (body == null) {
          body = [];
        } else if (!__isArray(body)) {
          throw TypeError("Expected body to be an Array, got " + __typeof(body));
        } else {
          for (_i = 0, _len = body.length; _i < _len; ++_i) {
            if (!(body[_i] instanceof Node)) {
              throw TypeError("Expected body[" + _i + "] to be a Node, got " + __typeof(body[_i]));
            }
          }
        }
        if (label == null) {
          label = null;
        } else if (!(label instanceof Ident)) {
          throw TypeError("Expected label to be an Ident or null, got " + __typeof(label));
        }
        if (body.length === 0) {
          return Noop();
        } else if (!label && (function () {
          var _i, item;
          for (_i = body.length; _i--; ) {
            item = body[_i];
            if (!(item instanceof Expression)) {
              return false;
            }
          }
          return true;
        }())) {
          return BlockExpression(body);
        } else {
          return BlockStatement(body, label);
        }
      };
      exports.Break = Break = (function (Statement) {
        var _Break_prototype, _Statement_prototype;
        function Break(label) {
          var _this;
          _this = this instanceof Break ? this : __create(_Break_prototype);
          if (label == null) {
            label = null;
          } else if (!(label instanceof Ident)) {
            throw TypeError("Expected label to be an Ident or null, got " + __typeof(label));
          }
          _this.label = label;
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _Break_prototype = Break.prototype = __create(_Statement_prototype);
        _Break_prototype.constructor = Break;
        Break.displayName = "Break";
        _Break_prototype.compile = function (options, level, lineStart, sb) {
          if (level !== Level.block) {
            throw Error("Cannot compile a statement except on the Block level");
          }
          sb("break");
          if (this.label != null) {
            sb(" ");
            this.label.compile(options, Level.insideParentheses, false, sb);
          }
          sb(";");
        };
        _Break_prototype.walk = function () {
          return this;
        };
        _Break_prototype.exitType = function () {
          return "break";
        };
        _Break_prototype.walk = function (walker) {
          var _ref, label;
          if (this.label != null) {
            if ((_ref = walker(this.label)) != null) {
              label = _ref;
            } else {
              label = this.label.walk(walker);
            }
          } else {
            label = this.label;
          }
          if (label !== this.label) {
            return Break(label);
          } else {
            return this;
          }
        };
        _Break_prototype.inspect = function (depth) {
          return inspectHelper(depth, "Break", this.label);
        };
        _Break_prototype.isLarge = function () {
          return false;
        };
        _Break_prototype.toJSON = function () {
          var _ref;
          return {
            type: "Break",
            label: (_ref = this.label) != null ? _ref : void 0
          };
        };
        Break.fromJSON = function (_p) {
          var label;
          label = _p.label;
          return Break(label ? fromJSON(label) : null);
        };
        return Break;
      }(Statement));
      exports.Call = Call = (function (Expression) {
        var _Call_prototype, _Expression_prototype;
        function Call(func, args, isNew) {
          var _i, _len, _this;
          _this = this instanceof Call ? this : __create(_Call_prototype);
          if (func == null) {
            func = Noop();
          } else if (!(func instanceof Expression)) {
            throw TypeError("Expected func to be an Expression, got " + __typeof(func));
          }
          _this.func = func;
          if (args == null) {
            args = [];
          } else if (!__isArray(args)) {
            throw TypeError("Expected args to be an Array, got " + __typeof(args));
          } else {
            for (_i = 0, _len = args.length; _i < _len; ++_i) {
              if (!(args[_i] instanceof Expression)) {
                throw TypeError("Expected args[" + _i + "] to be an Expression, got " + __typeof(args[_i]));
              }
            }
          }
          _this.args = args;
          if (isNew == null) {
            isNew = false;
          } else if (typeof isNew !== "boolean") {
            throw TypeError("Expected isNew to be a Boolean, got " + __typeof(isNew));
          }
          _this.isNew = isNew;
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _Call_prototype = Call.prototype = __create(_Expression_prototype);
        _Call_prototype.constructor = Call;
        Call.displayName = "Call";
        function compileLarge(args, options, level, lineStart, sb) {
          var _arr, childOptions, i, item, len;
          sb("(");
          childOptions = incIndent(options);
          for (_arr = __toArray(args), i = 0, len = _arr.length; i < len; ++i) {
            item = _arr[i];
            sb("\n");
            sb.indent(childOptions.indent);
            item.compile(childOptions, Level.sequence, false, sb);
            if (i < len - 1) {
              sb(",");
            }
          }
          sb("\n");
          sb.indent(options.indent);
          sb(")");
        }
        function compileSmall(args, options, level, lineStart, sb) {
          var _arr, _len, arg, i;
          sb("(");
          for (_arr = __toArray(args), i = 0, _len = _arr.length; i < _len; ++i) {
            arg = _arr[i];
            if (i > 0) {
              sb(", ");
            }
            arg.compile(options, Level.sequence, false, sb);
          }
          sb(")");
        }
        _Call_prototype.compile = function (options, level, lineStart, sb) {
          var f, wrap;
          wrap = !__lte(level, Level.callOrAccess) || !this.isNew && (this.func instanceof Func || this.func instanceof Binary && this.func.op === "." && this.func.left instanceof Func);
          if (wrap) {
            sb("(");
          }
          if (this.isNew) {
            sb("new ");
          }
          this.func.compile(
            options,
            this.isNew ? Level.newCall : Level.callOrAccess,
            lineStart && !wrap && !this.isNew,
            sb
          );
          if (this.shouldCompileLarge()) {
            f = compileLarge;
          } else {
            f = compileSmall;
          }
          f(
            this.args,
            options,
            level,
            lineStart,
            sb
          );
          if (wrap) {
            sb(")");
          }
        };
        _Call_prototype.shouldCompileLarge = function () {
          var _this;
          _this = this;
          if (__num(this.args.length) > 4) {
            return true;
          } else {
            return (function () {
              var _arr, _i, _len, arg;
              for (_arr = __toArray(_this.args), _len = _arr.length, _i = _len - 2; _i >= 0; --_i) {
                arg = _arr[_i];
                if (!arg.isSmall()) {
                  return true;
                }
              }
              return false;
            }());
          }
        };
        _Call_prototype.hasLargeArgs = function () {
          var _ref, _this;
          _this = this;
          if ((_ref = this._hasLargeArgs) == null) {
            return this._hasLargeArgs = __num(this.args.length) > 4 ? true
              : (function () {
                var _arr, _i, arg;
                for (_arr = __toArray(_this.args), _i = _arr.length; _i--; ) {
                  arg = _arr[_i];
                  if (!arg.isSmall()) {
                    return true;
                  }
                }
                return false;
              }());
          } else {
            return _ref;
          }
        };
        _Call_prototype.isLarge = function () {
          return this.func.isLarge() || this.hasLargeArgs();
        };
        _Call_prototype.isSmall = function () {
          var _ref, _this;
          _this = this;
          if ((_ref = this._isSmall) == null) {
            return this._isSmall = !this.func.isSmall() ? false
              : (function () {
                switch (_this.args.length) {
                case 0: return true;
                case 1: return _this.args[0].isSmall();
                default: return false;
                }
              }());
          } else {
            return _ref;
          }
        };
        _Call_prototype.walk = function (walker) {
          var _ref, args, func;
          if ((_ref = walker(this.func)) != null) {
            func = _ref;
          } else {
            func = this.func.walk(walker);
          }
          args = walkArray(this.args, walker);
          if (this.func !== func || this.args !== args) {
            return Call(func, args, this.isNew);
          } else {
            return this;
          }
        };
        _Call_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "Call",
            this.func,
            this.args,
            this.isNew
          );
        };
        _Call_prototype.toJSON = function () {
          return { type: "Call", func: simplify(this.func), args: simplify(this.args), isNew: this.isNew || void 0 };
        };
        Call.fromJSON = function (_p) {
          var args, func, isNew;
          func = _p.func;
          args = _p.args;
          isNew = _p.isNew;
          return Call(fromJSON(func), arrayFromJSON(args), isNew);
        };
        return Call;
      }(Expression));
      function toConst(value) {
        if (value instanceof Node) {
          throw Error("Cannot convert " + __typeof(value) + " to a Const");
        } else if (__isArray(value)) {
          return Arr((function () {
            var _arr, _arr2, _i, _len, item;
            for (_arr = [], _arr2 = __toArray(value), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
              item = _arr2[_i];
              _arr.push(toConst(item));
            }
            return _arr;
          }()));
        } else if (value instanceof RegExp) {
          return Regex(value.source, value.flags);
        } else if (__isObject(value)) {
          return Obj((function () {
            var _arr, k, v;
            _arr = [];
            for (k in value) {
              if (__owns.call(value, k)) {
                v = value[k];
                _arr.push(Obj.Pair(k, toConst(v)));
              }
            }
            return _arr;
          }()));
        } else {
          return Const(value);
        }
      }
      exports.Comment = Comment = (function (Statement) {
        var _Comment_prototype, _Statement_prototype;
        function Comment(text) {
          var _this;
          _this = this instanceof Comment ? this : __create(_Comment_prototype);
          if (typeof text !== "string") {
            throw TypeError("Expected text to be a String, got " + __typeof(text));
          }
          _this.text = text;
          if (text.substring(0, 2) !== "/*") {
            throw Error("Expected text to start with '/*'");
          }
          if (text.slice(-2) !== "*/") {
            throw Error("Expected text to end with '*/'");
          }
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _Comment_prototype = Comment.prototype = __create(_Statement_prototype);
        _Comment_prototype.constructor = Comment;
        Comment.displayName = "Comment";
        _Comment_prototype.compile = function (options, level, lineStart, sb) {
          var _arr, _len, i, line, lines;
          lines = this.text.split("\n");
          for (_arr = __toArray(lines), i = 0, _len = _arr.length; i < _len; ++i) {
            line = _arr[i];
            if (i > 0) {
              sb("\n");
              sb.indent(options.indent);
            }
            sb(line);
          }
        };
        _Comment_prototype.isConst = function () {
          return true;
        };
        _Comment_prototype.constValue = function () {
          return;
        };
        _Comment_prototype.isNoop = function () {
          return false;
        };
        _Comment_prototype.walk = function () {
          return this;
        };
        _Comment_prototype.inspect = function (depth) {
          return inspectHelper("Comment", this.text);
        };
        _Comment_prototype.toJSON = function () {
          return { type: "Comment", text: this.text };
        };
        Comment.fromJSON = function (_p) {
          var text;
          text = _p.text;
          return Comment(text);
        };
        return Comment;
      }(Statement));
      exports.Const = Const = (function (Expression) {
        var _Const_prototype, _Expression_prototype;
        function Const(value) {
          var _this;
          _this = this instanceof Const ? this : __create(_Const_prototype);
          if (value != void 0 && typeof value !== "boolean" && typeof value !== "number" && typeof value !== "string") {
            throw TypeError("Expected value to be an undefined or null or Boolean or Number or String, got " + __typeof(value));
          }
          _this.value = value;
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _Const_prototype = Const.prototype = __create(_Expression_prototype);
        _Const_prototype.constructor = Const;
        Const.displayName = "Const";
        _Const_prototype.compile = function (options, level, lineStart, sb) {
          var value, wrap;
          value = this.value;
          if (value === void 0 && options.undefinedName != null) {
            sb(options.undefinedName);
          } else {
            wrap = !__lt(level, Level.increment) && (value === void 0 || typeof value === "number" && !isFinite(value));
            if (wrap) {
              sb("(");
            }
            sb(toJSSource(value));
            if (wrap) {
              sb(")");
            }
          }
        };
        _Const_prototype.compileAsBlock = function (options, level, lineStart, sb) {
          Noop().compileAsBlock(options, level, lineStart, sb);
        };
        _Const_prototype.isConst = function () {
          return true;
        };
        _Const_prototype.isNoop = Const.prototype.isConst;
        _Const_prototype.constValue = function () {
          return this.value;
        };
        _Const_prototype.walk = function () {
          return this;
        };
        _Const_prototype.inspect = function (depth) {
          return "Const(" + __strnum(inspect(this.value, null, decDepth(depth))) + ")";
        };
        _Const_prototype.toJSON = function () {
          var _ref;
          if (this.value === 1/0) {
            return { type: "Const", infinite: true, value: 1 };
          } else if (this.value === -1/0) {
            return { type: "Const", infinite: true, value: -1 };
          } else if ((_ref = this.value) !== _ref) {
            return { type: "Const", infinite: true, value: 0 };
          } else if (this.value === 0) {
            return {
              type: "Const",
              value: this.value,
              sign: isNegative(this.value) ? -1 : 1
            };
          } else {
            return { type: "Const", value: this.value };
          }
        };
        Const.fromJSON = function (obj) {
          if (obj.infinite) {
            return Const(__num(obj.value) / 0);
          } else if (obj.value === 0) {
            if (obj.sign && __num(obj.sign) < 0) {
              return Const(-0);
            } else {
              return Const(0);
            }
          } else {
            return Const(obj.value);
          }
        };
        return Const;
      }(Expression));
      exports.Continue = Continue = (function (Statement) {
        var _Continue_prototype, _Statement_prototype;
        function Continue(label) {
          var _this;
          _this = this instanceof Continue ? this : __create(_Continue_prototype);
          if (label == null) {
            label = null;
          } else if (!(label instanceof Ident)) {
            throw TypeError("Expected label to be an Ident or null, got " + __typeof(label));
          }
          _this.label = label;
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _Continue_prototype = Continue.prototype = __create(_Statement_prototype);
        _Continue_prototype.constructor = Continue;
        Continue.displayName = "Continue";
        _Continue_prototype.compile = function (options, level, lineStart, sb) {
          if (level !== Level.block) {
            throw Error("Cannot compile a statement except on the Block level");
          }
          sb("continue");
          if (this.label != null) {
            sb(" ");
            this.label.compile(options, Level.insideParentheses, false, sb);
          }
          return sb(";");
        };
        _Continue_prototype.walk = function () {
          return this;
        };
        _Continue_prototype.exitType = function () {
          return "continue";
        };
        _Continue_prototype.isLarge = function () {
          return false;
        };
        _Continue_prototype.walk = function (walker) {
          var _ref, label;
          if (this.label != null) {
            if ((_ref = walker(this.label)) != null) {
              label = _ref;
            } else {
              label = this.label.walk(walker);
            }
          } else {
            label = this.label;
          }
          if (label !== this.label) {
            return Continue(label);
          } else {
            return this;
          }
        };
        _Continue_prototype.inspect = function (depth) {
          return inspectHelper(depth, "Continue", this.label);
        };
        _Continue_prototype.toJSON = function () {
          var _ref;
          return {
            type: "Continue",
            label: (_ref = this.label) != null ? _ref : void 0
          };
        };
        Continue.fromJSON = function (_p) {
          var label;
          label = _p.label;
          return Continue(label ? fromJSON(label) : null);
        };
        return Continue;
      }(Statement));
      exports.Debugger = Debugger = (function (Statement) {
        var _Debugger_prototype, _Statement_prototype;
        function Debugger() {
          var _this;
          _this = this instanceof Debugger ? this : __create(_Debugger_prototype);
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _Debugger_prototype = Debugger.prototype = __create(_Statement_prototype);
        _Debugger_prototype.constructor = Debugger;
        Debugger.displayName = "Debugger";
        _Debugger_prototype.compile = function (options, level, lineStart, sb) {
          if (level !== Level.block) {
            throw Error("Cannot compile a statement except on the Block level");
          }
          return sb("debugger;");
        };
        _Debugger_prototype.walk = function () {
          return this;
        };
        _Debugger_prototype.isLarge = function () {
          return false;
        };
        _Debugger_prototype.inspect = function () {
          return "Debugger()";
        };
        _Debugger_prototype.toJSON = function () {
          return { type: "Debugger" };
        };
        Debugger.fromJSON = function () {
          return Debugger();
        };
        return Debugger;
      }(Statement));
      exports.DoWhile = DoWhile = (function (Statement) {
        var _DoWhile_prototype, _Statement_prototype;
        function DoWhile(body, test, label) {
          var _this;
          _this = this instanceof DoWhile ? this : __create(_DoWhile_prototype);
          if (body == null) {
            body = Noop();
          } else if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          if (test == null) {
            test = Noop();
          } else if (!(test instanceof Expression)) {
            throw TypeError("Expected test to be an Expression, got " + __typeof(test));
          }
          _this.test = test;
          if (label == null) {
            label = null;
          } else if (!(label instanceof Ident)) {
            throw TypeError("Expected label to be an Ident or null, got " + __typeof(label));
          }
          _this.label = label;
          _this.body = body.maybeToStatement();
          if (test.isConst() && !test.constValue()) {
            return Block([_this.body], label);
          }
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _DoWhile_prototype = DoWhile.prototype = __create(_Statement_prototype);
        _DoWhile_prototype.constructor = DoWhile;
        DoWhile.displayName = "DoWhile";
        _DoWhile_prototype.compile = function (options, level, lineStart, sb) {
          if (level !== Level.block) {
            throw Error("Cannot compile a statement except on the Block level");
          }
          if (this.label != null) {
            this.label.compile(options, level, lineStart, sb);
            sb(": ");
          }
          sb("do");
          if (this.body.isNoop()) {
            sb(";");
          } else {
            sb(" {\n");
            sb.indent(__num(options.indent) + 1);
            this.body.compileAsStatement(incIndent(options), true, sb);
            sb("\n");
            sb.indent(options.indent);
            sb("}");
          }
          sb(" while (");
          this.test.compile(options, Level.insideParentheses, false, sb);
          sb(");");
        };
        _DoWhile_prototype.walk = function (walker) {
          var _ref, body, label, test;
          if ((_ref = walker(this.body)) != null) {
            body = _ref;
          } else {
            body = this.body.walk(walker);
          }
          if ((_ref = walker(this.test)) != null) {
            test = _ref;
          } else {
            test = this.test.walk(walker);
          }
          if (this.label != null) {
            if ((_ref = walker(this.label)) != null) {
              label = _ref;
            } else {
              label = this.label.walk(walker);
            }
          } else {
            label = this.label;
          }
          if (body !== this.body || test !== this.test || label !== this.label) {
            return DoWhile(body, test, label);
          } else {
            return this;
          }
        };
        _DoWhile_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "DoWhile",
            this.body,
            this.test,
            this.label
          );
        };
        _DoWhile_prototype.toJSON = function () {
          var _ref;
          return {
            type: "DoWhile",
            body: simplify(this.body),
            test: simplify(this.test),
            label: (_ref = this.label) != null ? _ref : void 0
          };
        };
        DoWhile.fromJSON = function (_p) {
          var body, label, test;
          body = _p.body;
          test = _p.test;
          label = _p.label;
          return DoWhile(fromJSON(body), fromJSON(test), label != null ? fromJSON(label) : null);
        };
        return DoWhile;
      }(Statement));
      exports.Eval = Eval = (function (Expression) {
        var _Eval_prototype, _Expression_prototype;
        function Eval(code) {
          var _this;
          _this = this instanceof Eval ? this : __create(_Eval_prototype);
          if (code == null) {
            code = Noop();
          }
          if (!(code instanceof Expression)) {
            code = toConst(code);
          }
          _this.code = code;
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _Eval_prototype = Eval.prototype = __create(_Expression_prototype);
        _Eval_prototype.constructor = Eval;
        Eval.displayName = "Eval";
        _Eval_prototype.compile = function (options, level, lineStart, sb) {
          if (this.code instanceof Const) {
            sb(String(this.code.value));
          } else {
            sb("eval(");
            this.code.compile(options, Level.sequence, false, sb);
            sb(")");
          }
        };
        _Eval_prototype.walk = function (walker) {
          var _ref, code;
          if ((_ref = walker(this.code)) != null) {
            code = _ref;
          } else {
            code = this.code.walk(walker);
          }
          if (code !== this.code) {
            return Eval(code);
          } else {
            return this;
          }
        };
        _Eval_prototype.inspect = function (depth) {
          return inspectHelper(depth, "Eval", this.code);
        };
        _Eval_prototype.toJSON = function () {
          return { type: "Eval", code: simplify(this.code) };
        };
        Eval.fromJSON = function (_p) {
          var code;
          code = _p.code;
          return Eval(fromJSON(code));
        };
        return Eval;
      }(Expression));
      exports.For = For = (function (Statement) {
        var _For_prototype, _Statement_prototype;
        function For(init, test, step, body, label) {
          var _this;
          _this = this instanceof For ? this : __create(_For_prototype);
          if (init == null) {
            init = Noop();
          } else if (!(init instanceof Expression)) {
            throw TypeError("Expected init to be an Expression, got " + __typeof(init));
          }
          _this.init = init;
          if (test == null) {
            test = Const(true);
          }
          if (step == null) {
            step = Noop();
          } else if (!(step instanceof Expression)) {
            throw TypeError("Expected step to be an Expression, got " + __typeof(step));
          }
          _this.step = step;
          if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof Ident)) {
            throw TypeError("Expected label to be an Ident or null, got " + __typeof(label));
          }
          _this.label = label;
          if (!(test instanceof Expression)) {
            test = toConst(test);
          }
          if (test.isConst() && !test.constValue()) {
            return init;
          }
          _this.test = test;
          _this.body = body.maybeToStatement();
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _For_prototype = For.prototype = __create(_Statement_prototype);
        _For_prototype.constructor = For;
        For.displayName = "For";
        _For_prototype.compile = function (options, level, lineStart, sb) {
          var test;
          if (level !== Level.block) {
            throw Error("Cannot compile a statement except on the Block level");
          }
          if (this.test.isConst() && typeof this.test.constValue() !== "boolean") {
            test = Const(!!this.test.constValue());
          } else {
            test = this.test;
          }
          if (this.label != null) {
            this.label.compile(options, level, lineStart, sb);
            sb(": ");
          }
          if (this.init.isNoop() && this.step.isNoop()) {
            sb("while (");
            test.compile(options, Level.insideParentheses, false, sb);
          } else {
            sb("for (");
            if (!this.init.isNoop()) {
              this.init.compileAsBlock(options, Level.insideParentheses, false, sb);
            }
            sb("; ");
            if (!test.isConst() || !test.constValue()) {
              test.compile(options, Level.insideParentheses, false, sb);
            }
            sb("; ");
            if (!this.step.isNoop()) {
              this.step.compileAsBlock(options, Level.insideParentheses, false, sb);
            }
          }
          sb(")");
          if (this.body.isNoop()) {
            sb(";");
          } else {
            sb(" {\n");
            sb.indent(__num(options.indent) + 1);
            this.body.compileAsStatement(incIndent(options), true, sb);
            sb("\n");
            sb.indent(options.indent);
            sb("}");
          }
        };
        _For_prototype.walk = function (walker) {
          var _ref, body, init, label, step, test;
          if ((_ref = walker(this.init)) != null) {
            init = _ref;
          } else {
            init = this.init.walk(walker);
          }
          if ((_ref = walker(this.test)) != null) {
            test = _ref;
          } else {
            test = this.test.walk(walker);
          }
          if ((_ref = walker(this.step)) != null) {
            step = _ref;
          } else {
            step = this.step.walk(walker);
          }
          if ((_ref = walker(this.body)) != null) {
            body = _ref;
          } else {
            body = this.body.walk(walker);
          }
          if (this.label != null) {
            if ((_ref = walker(this.label)) != null) {
              label = _ref;
            } else {
              label = this.label.walk(walker);
            }
          } else {
            label = this.label;
          }
          if (init !== this.init || test !== this.test || step !== this.step || body !== this.body || label !== this.label) {
            return For(
              init,
              test,
              step,
              body,
              label
            );
          } else {
            return this;
          }
        };
        _For_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "For",
            this.init,
            this.test,
            this.step,
            this.body,
            this.label
          );
        };
        _For_prototype.toJSON = function () {
          var _ref;
          return {
            type: "For",
            init: simplify(this.init),
            test: simplify(this.test),
            step: simplify(this.step),
            body: simplify(this.body),
            label: (_ref = this.label) != null ? _ref : void 0
          };
        };
        For.fromJSON = function (_p) {
          var body, init, label, step, test;
          init = _p.init;
          test = _p.test;
          step = _p.step;
          body = _p.body;
          label = _p.label;
          return For(
            fromJSON(init),
            fromJSON(test),
            fromJSON(step),
            fromJSON(body),
            label != null ? fromJSON(label) : null
          );
        };
        return For;
      }(Statement));
      exports.ForIn = ForIn = (function (Statement) {
        var _ForIn_prototype, _Statement_prototype;
        function ForIn(key, object, body, label) {
          var _this;
          _this = this instanceof ForIn ? this : __create(_ForIn_prototype);
          if (!(key instanceof Ident)) {
            throw TypeError("Expected key to be an Ident, got " + __typeof(key));
          }
          _this.key = key;
          if (object == null) {
            object = Noop();
          } else if (!(object instanceof Expression)) {
            throw TypeError("Expected object to be an Expression, got " + __typeof(object));
          }
          _this.object = object;
          if (body == null) {
            body = Noop();
          } else if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof Ident)) {
            throw TypeError("Expected label to be an Ident or null, got " + __typeof(label));
          }
          _this.label = label;
          _this.body = body.maybeToStatement();
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _ForIn_prototype = ForIn.prototype = __create(_Statement_prototype);
        _ForIn_prototype.constructor = ForIn;
        ForIn.displayName = "ForIn";
        _ForIn_prototype.compile = function (options, level, lineStart, sb) {
          if (level !== Level.block) {
            throw Error("Cannot compile a statement except on the Block level");
          }
          if (this.label != null) {
            this.label.compile(options, level, lineStart, sb);
            sb(": ");
          }
          sb("for (");
          this.key.compile(options, Level.insideParentheses, false, sb);
          sb(" in ");
          this.object.compile(options, Level.insideParentheses, false, sb);
          sb(")");
          if (this.body.isNoop()) {
            sb(";");
          } else {
            sb(" {\n");
            sb.indent(__num(options.indent) + 1);
            this.body.compileAsStatement(incIndent(options), true, sb);
            sb("\n");
            sb.indent(options.indent);
            sb("}");
          }
        };
        _ForIn_prototype.walk = function (walker) {
          var _ref, body, key, label, object;
          if ((_ref = walker(this.key)) != null) {
            key = _ref;
          } else {
            key = this.key.walk(walker);
          }
          if ((_ref = walker(this.object)) != null) {
            object = _ref;
          } else {
            object = this.object.walk(walker);
          }
          if ((_ref = walker(this.body)) != null) {
            body = _ref;
          } else {
            body = this.body.walk(walker);
          }
          if (this.label != null) {
            if ((_ref = walker(this.label)) != null) {
              label = _ref;
            } else {
              label = this.label.walk(walker);
            }
          } else {
            label = this.label;
          }
          if (key !== this.key || object !== this.object || body !== this.body || label !== this.label) {
            return ForIn(key, object, body);
          } else {
            return this;
          }
        };
        _ForIn_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "ForIn",
            this.key,
            this.object,
            this.body,
            this.label
          );
        };
        _ForIn_prototype.toJSON = function () {
          var _ref;
          return {
            type: "ForIn",
            key: this.key,
            object: simplify(this.object),
            body: simplify(this.body),
            label: (_ref = this.label) != null ? _ref : void 0
          };
        };
        ForIn.fromJSON = function (_p) {
          var body, key, label, object;
          key = _p.key;
          object = _p.object;
          body = _p.body;
          label = _p.label;
          return ForIn(fromJSON(key), fromJSON(object), fromJSON(body), label != null ? fromJSON(label) : null);
        };
        return ForIn;
      }(Statement));
      function validateFuncParamsAndVariables(params, variables) {
        var _arr, _i, names, param, variable;
        names = [];
        for (_arr = __toArray(params), _i = _arr.length; _i--; ) {
          param = _arr[_i];
          if (__in(param.name, names)) {
            throw Error("Duplicate parameter: " + __strnum(param.name));
          }
          names.push(param.name);
        }
        for (_arr = __toArray(variables), _i = _arr.length; _i--; ) {
          variable = _arr[_i];
          if (__in(variable, names)) {
            throw Error("Duplicate variable: " + __strnum(variable));
          }
          names.push(variable);
        }
      }
      function compileFuncBody(options, sb, declarations, variables, body) {
        var _arr, _i, _len, declaration, i, variable;
        for (_arr = __toArray(declarations), _i = 0, _len = _arr.length; _i < _len; ++_i) {
          declaration = _arr[_i];
          sb.indent(options.indent);
          sb(toJSSource(declaration));
          sb(";\n");
        }
        if (__num(variables.length) > 0) {
          sb.indent(options.indent);
          sb("var ");
          for (_arr = __toArray(variables), i = 0, _len = _arr.length; i < _len; ++i) {
            variable = _arr[i];
            if (i > 0) {
              sb(", ");
            }
            Ident(variables[i], true).compile(options, Level.insideParentheses, false, sb);
          }
          sb(";\n");
        }
        if (!body.isNoop()) {
          sb.indent(options.indent);
          body.compileAsStatement(options, true, sb);
          sb("\n");
        }
      }
      function compileFunc(options, sb, name, params, declarations, variables, body) {
        var _arr, _len, i, param;
        sb("function ");
        if (name != null) {
          name.compile(options, Level.insideParentheses, false, sb);
        }
        sb("(");
        for (_arr = __toArray(params), i = 0, _len = _arr.length; i < _len; ++i) {
          param = _arr[i];
          if (i > 0) {
            sb(", ");
          }
          param.compile(options, Level.insideParentheses, false, sb);
        }
        sb(") {");
        if (variables.length || declarations.length || !body.isNoop()) {
          sb("\n");
          compileFuncBody(
            incIndent(options),
            sb,
            declarations,
            variables,
            body
          );
          sb.indent(options.indent);
        }
        return sb("}");
      }
      exports.Func = Func = (function (Expression) {
        var _Expression_prototype, _Func_prototype;
        function Func(name, params, variables, body, declarations) {
          var _i, _len, _this;
          _this = this instanceof Func ? this : __create(_Func_prototype);
          if (name == null) {
            name = null;
          } else if (!(name instanceof Ident)) {
            throw TypeError("Expected name to be a null or Ident, got " + __typeof(name));
          }
          _this.name = name;
          if (params == null) {
            params = [];
          } else if (!__isArray(params)) {
            throw TypeError("Expected params to be an Array, got " + __typeof(params));
          } else {
            for (_i = 0, _len = params.length; _i < _len; ++_i) {
              if (!(params[_i] instanceof Ident)) {
                throw TypeError("Expected params[" + _i + "] to be an Ident, got " + __typeof(params[_i]));
              }
            }
          }
          _this.params = params;
          if (variables == null) {
            variables = [];
          } else if (!__isArray(variables)) {
            throw TypeError("Expected variables to be an Array, got " + __typeof(variables));
          } else {
            for (_i = 0, _len = variables.length; _i < _len; ++_i) {
              if (typeof variables[_i] !== "string") {
                throw TypeError("Expected variables[" + _i + "] to be a String, got " + __typeof(variables[_i]));
              }
            }
          }
          _this.variables = variables;
          if (body == null) {
            body = Noop();
          } else if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          _this.body = body;
          if (declarations == null) {
            declarations = [];
          } else if (!__isArray(declarations)) {
            throw TypeError("Expected declarations to be an Array, got " + __typeof(declarations));
          } else {
            for (_i = 0, _len = declarations.length; _i < _len; ++_i) {
              if (typeof declarations[_i] !== "string") {
                throw TypeError("Expected declarations[" + _i + "] to be a String, got " + __typeof(declarations[_i]));
              }
            }
          }
          _this.declarations = declarations;
          validateFuncParamsAndVariables(params, variables);
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _Func_prototype = Func.prototype = __create(_Expression_prototype);
        _Func_prototype.constructor = Func;
        Func.displayName = "Func";
        _Func_prototype.compile = function (options, level, lineStart, sb) {
          var wrap;
          wrap = lineStart && !this.name;
          if (wrap) {
            sb("(");
          }
          compileFunc(
            options,
            sb,
            this.name,
            this.params,
            this.declarations,
            this.variables,
            this.body
          );
          if (wrap) {
            sb(")");
          }
        };
        _Func_prototype.compileAsStatement = function (options, lineStart, sb) {
          this.compile(options, Level.block, lineStart, sb);
          if (!lineStart || !this.name) {
            sb(";");
          }
        };
        _Func_prototype.isLarge = function () {
          return true;
        };
        _Func_prototype.isNoop = function () {
          return this.name == null;
        };
        _Func_prototype.walk = function (walker) {
          var _ref, body, name, params;
          if (this.name) {
            if ((_ref = walker(this.name)) != null) {
              name = _ref;
            } else {
              name = this.name.walk(walker);
            }
          } else {
            name = this.name;
          }
          params = walkArray(this.params, walker);
          body = this.body.walk(walker);
          if (name !== this.name || params !== this.params || body !== this.body) {
            return Func(
              name,
              params,
              this.variables,
              body,
              this.declarations,
              this.meta
            );
          } else {
            return this;
          }
        };
        _Func_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "Func",
            this.name,
            this.params,
            this.variables,
            this.body,
            this.declarations,
            this.meta
          );
        };
        _Func_prototype.toJSON = function () {
          return {
            type: "Func",
            name: this.name || void 0,
            params: simplify(this.params),
            variables: simplify(this.variables),
            body: simplify(this.body),
            declarations: simplify(this.declarations)
          };
        };
        Func.fromJSON = function (_p) {
          var body, declarations, name, params, variables;
          name = _p.name;
          params = _p.params;
          variables = _p.variables;
          body = _p.body;
          declarations = _p.declarations;
          return Func(
            name ? fromJSON(name) : void 0,
            arrayFromJSON(params),
            variables,
            fromJSON(body),
            declarations
          );
        };
        return Func;
      }(Expression));
      exports.Ident = Ident = (function (Expression) {
        var _Expression_prototype, _Ident_prototype;
        function Ident(name, allowUnacceptable) {
          var _this;
          _this = this instanceof Ident ? this : __create(_Ident_prototype);
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          _this.name = name;
          if (allowUnacceptable == null) {
            allowUnacceptable = false;
          } else if (typeof allowUnacceptable !== "boolean") {
            throw TypeError("Expected allowUnacceptable to be a Boolean, got " + __typeof(allowUnacceptable));
          }
          if (!allowUnacceptable && !isAcceptableIdent(name, true)) {
            throw Error("Not an acceptable identifier name: " + name);
          }
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _Ident_prototype = Ident.prototype = __create(_Expression_prototype);
        _Ident_prototype.constructor = Ident;
        Ident.displayName = "Ident";
        _Ident_prototype.compile = function (options, level, lineStart, sb) {
          sb(this.name.replace(/[\u0000-\u001f\u0080-\uffff]/g, unicodeReplacer));
        };
        _Ident_prototype.compileAsBlock = function (options, level, lineStart, sb) {
          Noop().compileAsBlock(options, level, lineStart, sb);
        };
        _Ident_prototype.walk = function () {
          return this;
        };
        _Ident_prototype.inspect = function (depth) {
          return inspectHelper(depth, "Ident", this.name);
        };
        _Ident_prototype.isNoop = function () {
          return true;
        };
        _Ident_prototype.toJSON = function () {
          return { type: "Ident", name: this.name };
        };
        Ident.fromJSON = function (_p) {
          var name;
          name = _p.name;
          return Ident(name);
        };
        return Ident;
      }(Expression));
      exports.IfStatement = IfStatement = (function (Statement) {
        var _IfStatement_prototype, _Statement_prototype;
        function IfStatement(test, whenTrue, whenFalse, label) {
          var _this;
          _this = this instanceof IfStatement ? this : __create(_IfStatement_prototype);
          if (test == null) {
            test = Noop();
          } else if (!(test instanceof Expression)) {
            throw TypeError("Expected test to be an Expression, got " + __typeof(test));
          }
          if (whenTrue == null) {
            whenTrue = Noop();
          } else if (!(whenTrue instanceof Node)) {
            throw TypeError("Expected whenTrue to be a Node, got " + __typeof(whenTrue));
          }
          if (whenFalse == null) {
            whenFalse = Noop();
          } else if (!(whenFalse instanceof Node)) {
            throw TypeError("Expected whenFalse to be a Node, got " + __typeof(whenFalse));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof Ident)) {
            throw TypeError("Expected label to be an Ident or null, got " + __typeof(label));
          }
          _this.label = label;
          if (test instanceof Unary && test.op === "!" && test.node instanceof Unary && test.node.op === "!") {
            test = test.node.node;
          }
          if (test.isConst()) {
            if (test.constValue()) {
              return Block([whenTrue], label);
            } else {
              return Block([whenFalse], label);
            }
          } else {
            whenTrue = whenTrue.maybeToStatement();
            whenFalse = whenFalse.maybeToStatement();
            if (whenTrue instanceof Noop) {
              if (whenFalse instanceof Noop) {
                return test.maybeToStatement();
              } else {
                return IfStatement.call(
                  _this,
                  Unary("!", test),
                  whenFalse,
                  whenTrue,
                  label
                );
              }
            } else if (whenFalse instanceof Noop && whenTrue instanceof IfStatement && whenTrue.whenFalse instanceof Noop && whenTrue.label == null) {
              _this.test = Binary(test, "&&", whenTrue.test);
              _this.whenTrue = whenTrue.whenTrue;
              _this.whenFalse = whenFalse;
            } else {
              _this.test = test;
              _this.whenTrue = whenTrue;
              _this.whenFalse = whenFalse;
            }
          }
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _IfStatement_prototype = IfStatement.prototype = __create(_Statement_prototype);
        _IfStatement_prototype.constructor = IfStatement;
        IfStatement.displayName = "IfStatement";
        _IfStatement_prototype.compile = function (options, level, lineStart, sb) {
          var childOptions, whenFalse;
          if (level !== Level.block) {
            throw Error("Cannot compile a statement except on the Block level");
          }
          if (this.whenTrue.isNoop()) {
            if (this.whenFalse.isNoop()) {
              this.test.compileAsStatement(options, true, sb);
            } else {
              IfStatement(
                Unary("!", this.test),
                this.whenFalse,
                this.whenTrue,
                this.label
              ).compile(options, level, lineStart, sb);
            }
          } else {
            if (this.label != null) {
              this.label.compile(options, level, lineStart, sb);
              sb(": ");
            }
            sb("if (");
            this.test.compile(options, Level.insideParentheses, false, sb);
            sb(") {\n");
            childOptions = incIndent(options);
            sb.indent(childOptions.indent);
            this.whenTrue.compileAsStatement(childOptions, true, sb);
            sb("\n");
            sb.indent(options.indent);
            sb("}");
            whenFalse = this.whenFalse;
            if (!whenFalse.isNoop()) {
              sb(" else ");
              if (whenFalse instanceof IfStatement && whenFalse.label == null) {
                whenFalse.compile(options, level, false, sb);
              } else {
                sb("{\n");
                sb.indent(childOptions.indent);
                whenFalse.compileAsStatement(childOptions, true, sb);
                sb("\n");
                sb.indent(options.indent);
                sb("}");
              }
            }
          }
        };
        _IfStatement_prototype.walk = function (walker) {
          var _ref, label, test, whenFalse, whenTrue;
          if ((_ref = walker(this.test)) != null) {
            test = _ref;
          } else {
            test = this.test.walk(walker);
          }
          if ((_ref = walker(this.whenTrue)) != null) {
            whenTrue = _ref;
          } else {
            whenTrue = this.whenTrue.walk(walker);
          }
          if ((_ref = walker(this.whenFalse)) != null) {
            whenFalse = _ref;
          } else {
            whenFalse = this.whenFalse.walk(walker);
          }
          if (this.label != null) {
            if ((_ref = walker(this.label)) != null) {
              label = _ref;
            } else {
              label = this.label.walk(walker);
            }
          } else {
            label = this.label;
          }
          if (test !== this.test || whenTrue !== this.whenTrue || whenFalse !== this.whenFalse || label !== this.label) {
            return If(test, whenTrue, whenFalse, label);
          } else {
            return this;
          }
        };
        _IfStatement_prototype.mutateLast = function (func, includeNoop) {
          var whenFalse, whenTrue;
          whenTrue = this.whenTrue.mutateLast(func, includeNoop);
          whenFalse = this.whenFalse.mutateLast(func, includeNoop);
          if (whenTrue !== this.whenTrue || whenFalse !== this.whenFalse) {
            return If(this.test, whenTrue, whenFalse, this.label);
          } else {
            return this;
          }
        };
        _IfStatement_prototype.exitType = function () {
          var falseExit, trueExit;
          if (this._exitType === void 0) {
            trueExit = this.whenTrue.exitType();
            falseExit = this.whenFalse.exitType();
            return this._exitType = trueExit === falseExit ? trueExit : null;
          } else {
            return this._exitType;
          }
        };
        _IfStatement_prototype.isNoop = function () {
          var _ref;
          if ((_ref = this._isNoop) == null) {
            return this._isNoop = this.test.isNoop() && this.whenTrue.isNoop() && this.whenFalse.isNoop();
          } else {
            return _ref;
          }
        };
        _IfStatement_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "IfStatement",
            this.test,
            this.whenTrue,
            this.whenFalse
          );
        };
        _IfStatement_prototype.toJSON = function () {
          var _ref;
          return {
            type: "IfStatement",
            test: simplify(this.test),
            whenTrue: simplify(this.whenTrue),
            whenFalse: simplify(this.whenFalse),
            label: (_ref = this.label) != null ? _ref : void 0
          };
        };
        IfStatement.fromJSON = function (_p) {
          var label, test, whenFalse, whenTrue;
          test = _p.test;
          whenTrue = _p.whenTrue;
          whenFalse = _p.whenFalse;
          label = _p.label;
          return IfStatement(fromJSON(test), fromJSON(whenTrue), fromJSON(whenFalse), label != null ? fromJSON(label) : null);
        };
        return IfStatement;
      }(Statement));
      exports.IfExpression = IfExpression = (function (Expression) {
        var _Expression_prototype, _IfExpression_prototype;
        function IfExpression(test, whenTrue, whenFalse) {
          var _this;
          _this = this instanceof IfExpression ? this : __create(_IfExpression_prototype);
          if (test == null) {
            test = Noop();
          } else if (!(test instanceof Expression)) {
            throw TypeError("Expected test to be an Expression, got " + __typeof(test));
          }
          if (whenTrue == null) {
            whenTrue = Noop();
          }
          if (whenFalse == null) {
            whenFalse = Noop();
          }
          if (!(whenTrue instanceof Expression)) {
            whenTrue = toConst(whenTrue);
          }
          if (!(whenFalse instanceof Expression)) {
            whenFalse = toConst(whenFalse);
          }
          if (test instanceof Unary && test.op === "!" && test.node instanceof Unary && test.node.op === "!") {
            test = test.node.node;
          }
          if (test.isConst()) {
            if (test.constValue()) {
              return whenTrue;
            } else {
              return whenFalse;
            }
          } else if (whenFalse instanceof Noop && whenTrue instanceof IfExpression && whenTrue.whenFalse instanceof Noop) {
            _this.test = Binary(test, "&&", whenTrue.test);
            _this.whenTrue = whenTrue.whenTrue;
            _this.whenFalse = whenFalse;
          } else {
            _this.test = test;
            _this.whenTrue = whenTrue;
            _this.whenFalse = whenFalse;
          }
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _IfExpression_prototype = IfExpression.prototype = __create(_Expression_prototype);
        _IfExpression_prototype.constructor = IfExpression;
        IfExpression.displayName = "IfExpression";
        _IfExpression_prototype.toStatement = function () {
          return IfStatement(this.test, this.whenTrue, this.whenFalse);
        };
        function compileSmall(test, whenTrue, whenFalse, options, lineStart, sb) {
          test.compile(options, Level.inlineCondition, lineStart, sb);
          sb(" ? ");
          whenTrue.compile(options, Level.inlineCondition, false, sb);
          sb(" : ");
          whenFalse.compile(options, Level.inlineCondition, false, sb);
        }
        function compileLarge(test, whenTrue, whenFalse, options, lineStart, sb) {
          var childOptions, largeWhenTrue, wrapTest, wrapWhenTrue;
          childOptions = incIndent(options);
          wrapTest = test instanceof IfExpression;
          if (wrapTest) {
            sb("(");
          }
          test.compile(
            childOptions,
            wrapTest ? Level.insideParentheses : Level.inlineCondition,
            lineStart && !wrapTest,
            sb
          );
          if (wrapTest) {
            sb(")");
          }
          largeWhenTrue = whenTrue.isLarge();
          if (largeWhenTrue) {
            sb("\n");
            sb.indent(childOptions.indent);
            sb("? ");
          } else {
            sb(" ? ");
          }
          wrapWhenTrue = whenTrue instanceof IfExpression;
          if (wrapWhenTrue) {
            sb("(");
          }
          whenTrue.compile(
            childOptions,
            wrapWhenTrue ? Level.insideParentheses : Level.inlineCondition,
            false,
            sb
          );
          if (wrapWhenTrue) {
            sb(")");
          }
          sb("\n");
          sb.indent(childOptions.indent);
          sb(": ");
          if (whenFalse instanceof IfExpression) {
            compileLarge(
              whenFalse.test,
              whenFalse.whenTrue,
              whenFalse.whenFalse,
              options,
              false,
              sb
            );
          } else {
            whenFalse.compile(childOptions, Level.inlineCondition, false, sb);
          }
        }
        _IfExpression_prototype.compile = function (options, level, lineStart, sb) {
          var f, wrap;
          if (level === Level.block) {
            this.toStatement().compile(options, level, lineStart, sb);
          } else {
            wrap = !__lte(level, Level.inlineCondition);
            if (wrap) {
              sb("(");
            }
            if (this.whenTrue.isLarge() || this.whenFalse.isLarge()) {
              f = compileLarge;
            } else {
              f = compileSmall;
            }
            f(
              this.test,
              this.whenTrue,
              this.whenFalse,
              options,
              !wrap && lineStart,
              sb
            );
            if (wrap) {
              sb(")");
            }
          }
        };
        _IfExpression_prototype.compileAsBlock = function (options, level, lineStart, sb) {
          if (this.whenTrue.isNoop()) {
            if (this.whenFalse.isNoop()) {
              this.test.compileAsBlock(options, level, lineStart, sb);
            } else {
              Binary(this.test, "||", this.whenFalse).compileAsBlock(options, level, lineStart, sb);
            }
          } else if (this.whenFalse.isNoop()) {
            Binary(this.test, "&&", this.whenTrue).compileAsBlock(options, level, lineStart, sb);
          } else {
            this.compile(options, level, lineStart, sb);
          }
        };
        _IfExpression_prototype.isLarge = function () {
          var _ref;
          if ((_ref = this._isLarge) == null) {
            return this._isLarge = !this.test.isSmall() || !this.whenTrue.isSmall() || !this.whenFalse.isSmall();
          } else {
            return _ref;
          }
        };
        _IfExpression_prototype.isSmall = function () {
          return false;
        };
        _IfExpression_prototype.isNoop = function () {
          var _ref;
          if ((_ref = this._isNoop) == null) {
            return this._isNoop = this.test.isNoop() && this.whenTrue.isNoop() && this.whenFalse.isNoop();
          } else {
            return _ref;
          }
        };
        _IfExpression_prototype.walk = IfStatement.prototype.walk;
        _IfExpression_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "IfExpression",
            this.test,
            this.whenTrue,
            this.whenFalse
          );
        };
        _IfExpression_prototype.toJSON = function () {
          return { type: "IfExpression", test: simplify(this.test), whenTrue: simplify(this.whenTrue), whenFalse: simplify(this.whenFalse) };
        };
        IfExpression.fromJSON = function (_p) {
          var test, whenFalse, whenTrue;
          test = _p.test;
          whenTrue = _p.whenTrue;
          whenFalse = _p.whenFalse;
          return IfExpression(fromJSON(test), fromJSON(whenTrue), fromJSON(whenFalse));
        };
        return IfExpression;
      }(Expression));
      If = exports.If = function (test, whenTrue, whenFalse, label) {
        if (whenTrue instanceof Statement || whenFalse instanceof Statement || label != null) {
          return IfStatement(test, whenTrue, whenFalse, label);
        } else {
          return IfExpression(test, whenTrue, whenFalse);
        }
      };
      exports.Noop = Noop = (function (Expression) {
        var _Expression_prototype, _Noop_prototype;
        function Noop() {
          var _this;
          _this = this instanceof Noop ? this : __create(_Noop_prototype);
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _Noop_prototype = Noop.prototype = __create(_Expression_prototype);
        _Noop_prototype.constructor = Noop;
        Noop.displayName = "Noop";
        _Noop_prototype.compileAsStatement = function () {};
        _Noop_prototype.compile = function (options, level, lineStart, sb) {
          if (!__lte(level, Level.block)) {
            Const(void 0).compile(options, level, lineStart, sb);
          }
        };
        _Noop_prototype.isConst = function () {
          return true;
        };
        _Noop_prototype.isNoop = Noop.prototype.isConst;
        _Noop_prototype.constValue = function () {
          return;
        };
        _Noop_prototype.walk = function () {
          return this;
        };
        _Noop_prototype.mutateLast = function (func, includeNoop) {
          if (includeNoop) {
            return func(this);
          } else {
            return this;
          }
        };
        _Noop_prototype.inspect = function () {
          return "Noop()";
        };
        _Noop_prototype.toJSON = function () {
          return { type: "Noop" };
        };
        Noop.fromJSON = function () {
          return Noop();
        };
        return Noop;
      }(Expression));
      exports.Obj = Obj = (function (Expression) {
        var _Expression_prototype, _Obj_prototype, ObjPair;
        function Obj(elements) {
          var _i, _len, _this;
          _this = this instanceof Obj ? this : __create(_Obj_prototype);
          if (elements == null) {
            elements = [];
          } else if (!__isArray(elements)) {
            throw TypeError("Expected elements to be an Array, got " + __typeof(elements));
          } else {
            for (_i = 0, _len = elements.length; _i < _len; ++_i) {
              if (!(elements[_i] instanceof ObjPair)) {
                throw TypeError("Expected elements[" + _i + "] to be an ObjPair, got " + __typeof(elements[_i]));
              }
            }
          }
          _this.elements = elements;
          validateUniqueKeys(elements);
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _Obj_prototype = Obj.prototype = __create(_Expression_prototype);
        _Obj_prototype.constructor = Obj;
        Obj.displayName = "Obj";
        function validateUniqueKeys(elements) {
          var _arr, _i, key, keys, pair;
          keys = [];
          for (_arr = __toArray(elements), _i = _arr.length; _i--; ) {
            pair = _arr[_i];
            key = pair.key;
            if (__in(key, keys)) {
              throw Error("Found duplicate key: " + toJSSource(key));
            }
            keys.push(key);
          }
        }
        function toSafeKey(key) {
          var num;
          if (isAcceptableIdent(key)) {
            return key;
          } else {
            num = Number(key);
            if (num === num && String(num) === key) {
              return key;
            } else {
              return toJSSource(key);
            }
          }
        }
        function compileLarge(elements, options, sb) {
          var _arr, childOptions, element, i, key, len;
          childOptions = incIndent(options);
          for (_arr = __toArray(elements), i = 0, len = _arr.length; i < len; ++i) {
            element = _arr[i];
            sb("\n");
            sb.indent(childOptions.indent);
            key = element.key;
            sb(toSafeKey(key));
            sb(": ");
            element.value.compile(childOptions, Level.sequence, false, sb);
            if (i < len - 1) {
              sb(",");
            }
          }
          sb("\n");
          sb.indent(options.indent);
        }
        function compileSmall(elements, options, sb) {
          var _arr, _len, element, i, key;
          if (elements.length) {
            sb(" ");
            for (_arr = __toArray(elements), i = 0, _len = _arr.length; i < _len; ++i) {
              element = _arr[i];
              if (i > 0) {
                sb(", ");
              }
              key = element.key;
              sb(toSafeKey(key));
              sb(": ");
              element.value.compile(options, Level.sequence, false, sb);
            }
            sb(" ");
          }
        }
        _Obj_prototype.compile = function (options, level, lineStart, sb) {
          var f;
          if (lineStart) {
            sb("(");
          }
          sb("{");
          if (this.shouldCompileLarge()) {
            f = compileLarge;
          } else {
            f = compileSmall;
          }
          f(this.elements, options, sb);
          sb("}");
          if (lineStart) {
            sb(")");
          }
        };
        _Obj_prototype.compileAsBlock = function (options, level, lineStart, sb) {
          var _this;
          _this = this;
          BlockExpression((function () {
            var _arr, _arr2, _i, _len, element;
            for (_arr = [], _arr2 = __toArray(_this.elements), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
              element = _arr2[_i];
              _arr.push(element.value);
            }
            return _arr;
          }())).compileAsBlock(options, level, lineStart, sb);
        };
        _Obj_prototype.compileAsStatement = function (options, lineStart, sb) {
          var _this;
          _this = this;
          BlockStatement((function () {
            var _arr, _arr2, _i, _len, element;
            for (_arr = [], _arr2 = __toArray(_this.elements), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
              element = _arr2[_i];
              _arr.push(element.value);
            }
            return _arr;
          }())).compileAsStatement(options, lineStart, sb);
        };
        _Obj_prototype.shouldCompileLarge = function () {
          switch (this.elements.length) {
          case 0: return false;
          case 1: return this.elements[0].isLarge();
          default: return this.isLarge();
          }
        };
        _Obj_prototype.isSmall = function () {
          switch (this.elements.length) {
          case 0: return true;
          case 1: return this.elements[0].isSmall();
          default: return false;
          }
        };
        _Obj_prototype.isLarge = function () {
          var _ref, _this;
          _this = this;
          if ((_ref = this._isLarge) == null) {
            return this._isLarge = __num(this.elements.length) > 4 || (function () {
              var _arr, _i, element;
              for (_arr = __toArray(_this.elements), _i = _arr.length; _i--; ) {
                element = _arr[_i];
                if (!element.isSmall()) {
                  return true;
                }
              }
              return false;
            }());
          } else {
            return _ref;
          }
        };
        _Obj_prototype.isNoop = function () {
          var _ref, _this;
          _this = this;
          if ((_ref = this._isNoop) == null) {
            return this._isNoop = (function () {
              var _arr, _i, element;
              for (_arr = __toArray(_this.elements), _i = _arr.length; _i--; ) {
                element = _arr[_i];
                if (!element.isNoop()) {
                  return false;
                }
              }
              return true;
            }());
          } else {
            return _ref;
          }
        };
        _Obj_prototype.walk = function (walker) {
          var elements;
          elements = walkArray(this.elements, walker);
          if (elements !== this.elements) {
            return Obj(elements);
          } else {
            return this;
          }
        };
        _Obj_prototype.inspect = function (depth) {
          return inspectHelper(depth, "Obj", this.elements);
        };
        _Obj_prototype.toJSON = function () {
          var _this;
          _this = this;
          return {
            type: "Obj",
            pairs: simplify((function () {
              var _arr, _arr2, _i, _len, pair;
              for (_arr = [], _arr2 = __toArray(_this.pairs), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                pair = _arr2[_i];
                _arr.push({ key: pair.key, value: simplify(pair.value) });
              }
              return _arr;
            }()))
          };
        };
        Obj.fromJSON = function (_p) {
          var _arr, _i, _len, pair, pairs, resultPairs;
          pairs = _p.pairs;
          resultPairs = [];
          for (_arr = __toArray(pairs || []), _i = 0, _len = _arr.length; _i < _len; ++_i) {
            pair = _arr[_i];
            if (!pair || typeof pair !== "object") {
              throw Error("Expecting an object with a key and value");
            }
            resultPairs.push(ObjPair(pair.key, fromJSON(pair.value)));
          }
          return Obj(resultPairs);
        };
        Obj.Pair = ObjPair = (function () {
          var _ObjPair_prototype;
          function ObjPair(key, value) {
            var _this;
            _this = this instanceof ObjPair ? this : __create(_ObjPair_prototype);
            if (typeof key !== "string") {
              throw TypeError("Expected key to be a String, got " + __typeof(key));
            }
            _this.key = key;
            if (value == null) {
              value = Noop();
            }
            if (!(value instanceof Expression)) {
              value = toConst(value);
            }
            _this.value = value;
            return _this;
          }
          _ObjPair_prototype = ObjPair.prototype;
          ObjPair.displayName = "ObjPair";
          _ObjPair_prototype.isSmall = function () {
            return this.value.isSmall();
          };
          _ObjPair_prototype.isLarge = function () {
            return this.value.isLarge();
          };
          _ObjPair_prototype.isNoop = function () {
            return this.value.isNoop();
          };
          _ObjPair_prototype.walk = function (walker) {
            var _ref, value;
            if ((_ref = walker(this.value)) != null) {
              value = _ref;
            } else {
              value = this.value.walk(walker);
            }
            if (value !== this.value) {
              return ObjPair(this.key, value);
            } else {
              return this;
            }
          };
          _ObjPair_prototype.inspect = function (depth) {
            return inspectHelper(depth, "Pair", this.key, this.value);
          };
          return ObjPair;
        }());
        return Obj;
      }(Expression));
      exports.Regex = Regex = (function (Expression) {
        var _Expression_prototype, _Regex_prototype;
        function Regex(source, flags) {
          var _this;
          _this = this instanceof Regex ? this : __create(_Regex_prototype);
          if (typeof source !== "string") {
            throw TypeError("Expected source to be a String, got " + __typeof(source));
          }
          _this.source = source;
          if (flags == null) {
            flags = "";
          } else if (typeof flags !== "string") {
            throw TypeError("Expected flags to be a String, got " + __typeof(flags));
          }
          _this.flags = flags;
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _Regex_prototype = Regex.prototype = __create(_Expression_prototype);
        _Regex_prototype.constructor = Regex;
        Regex.displayName = "Regex";
        _Regex_prototype.compile = function (options, level, lineStart, sb) {
          sb("/");
          sb(this.source.replace(/(\\\\)*\\?\//g, "$1\\/") || "(?:)");
          sb("/");
          sb(this.flags);
        };
        _Regex_prototype.compileAsBlock = function (options, level, lineStart, sb) {
          Noop().compileAsBlock(options, level, lineStart, sb);
        };
        _Regex_prototype.isNoop = function () {
          return true;
        };
        _Regex_prototype.walk = function () {
          return this;
        };
        _Regex_prototype.inspect = function (depth) {
          return inspectHelper(depth, "Regex", this.source, this.flags);
        };
        _Regex_prototype.toJSON = function () {
          return { type: "Regex", source: this.source, flags: this.flags };
        };
        Regex.fromJSON = function (_p) {
          var flags, source;
          source = _p.source;
          flags = _p.flags;
          return Regex(source, flags);
        };
        return Regex;
      }(Expression));
      exports.Return = Return = (function (Statement) {
        var _Return_prototype, _Statement_prototype;
        function Return(node) {
          var _this;
          _this = this instanceof Return ? this : __create(_Return_prototype);
          if (node == null) {
            node = Noop();
          } else if (!(node instanceof Expression)) {
            throw TypeError("Expected node to be an Expression, got " + __typeof(node));
          }
          _this.node = node;
          if (typeof node.toStatement === "function") {
            return node.toStatement().mutateLast(Return);
          }
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _Return_prototype = Return.prototype = __create(_Statement_prototype);
        _Return_prototype.constructor = Return;
        Return.displayName = "Return";
        _Return_prototype.compile = function (options, level, lineStart, sb) {
          sb("return");
          if (!this.node.isConst() || this.node.constValue() !== void 0) {
            sb(" ");
            this.node.compile(options, Level.insideParentheses, false, sb);
          }
          sb(";");
        };
        _Return_prototype.walk = function (walker) {
          var _ref, node;
          if ((_ref = walker(this.node)) != null) {
            node = _ref;
          } else {
            node = this.node.walk(walker);
          }
          if (node !== this.node) {
            return Return(node);
          } else {
            return this;
          }
        };
        _Return_prototype.exitType = function () {
          return "return";
        };
        _Return_prototype.isSmall = function () {
          return this.node.isSmall();
        };
        _Return_prototype.isLarge = function () {
          return this.node.isLarge();
        };
        _Return_prototype.inspect = function (depth) {
          return inspectHelper(depth, "Return", this.node);
        };
        _Return_prototype.toJSON = function () {
          return { type: "Return", node: simplify(this.node) };
        };
        Return.fromJSON = function (_p) {
          var node;
          node = _p.node;
          return Return(fromJSON(node));
        };
        return Return;
      }(Statement));
      exports.Root = Root = (function () {
        var _Root_prototype;
        function Root(body, variables, declarations) {
          var _i, _len, _this;
          _this = this instanceof Root ? this : __create(_Root_prototype);
          if (body == null) {
            body = Noop();
          } else if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          _this.body = body;
          if (variables == null) {
            variables = [];
          } else if (!__isArray(variables)) {
            throw TypeError("Expected variables to be an Array, got " + __typeof(variables));
          } else {
            for (_i = 0, _len = variables.length; _i < _len; ++_i) {
              if (typeof variables[_i] !== "string") {
                throw TypeError("Expected variables[" + _i + "] to be a String, got " + __typeof(variables[_i]));
              }
            }
          }
          _this.variables = variables;
          if (declarations == null) {
            declarations = [];
          } else if (!__isArray(declarations)) {
            throw TypeError("Expected declarations to be an Array, got " + __typeof(declarations));
          } else {
            for (_i = 0, _len = declarations.length; _i < _len; ++_i) {
              if (typeof declarations[_i] !== "string") {
                throw TypeError("Expected declarations[" + _i + "] to be a String, got " + __typeof(declarations[_i]));
              }
            }
          }
          _this.declarations = declarations;
          validateFuncParamsAndVariables([], variables);
          return _this;
        }
        _Root_prototype = Root.prototype;
        Root.displayName = "Root";
        _Root_prototype.compile = function (options) {
          var code, endCompileTime, endUglifyTime, sb, startTime, writer;
          if (options == null) {
            options = {};
          }
          if (!options.indent) {
            options.indent = 0;
          }
          if (!options.uglify && typeof options.writer === "function") {
            writer = options.writer;
          }
          if (writer) {
            sb = StringWriter(writer);
          } else {
            sb = StringBuilder();
          }
          startTime = new Date().getTime();
          compileFuncBody(
            options,
            sb,
            this.declarations,
            this.variables,
            this.body
          );
          endCompileTime = new Date().getTime();
          if (typeof options.progress === "function") {
            options.progress("compile", __num(endCompileTime) - __num(startTime));
          }
          endUglifyTime = 0;
          if (writer == null) {
            code = sb.toString();
            if (options.uglify) {
              code = require("uglify-js").minify(code, { fromString: true }).code;
              endUglifyTime = new Date().getTime();
              if (typeof options.progress === "function") {
                options.progress("uglify", endUglifyTime - __num(endCompileTime));
              }
            }
            if (typeof options.writer === "function") {
              options.writer(code);
              code = "";
            }
          }
          return {
            compileTime: __num(endCompileTime) - __num(startTime),
            uglifyTime: options.uglify ? endUglifyTime - __num(endCompileTime) : void 0,
            code: code || ""
          };
        };
        _Root_prototype.toString = function () {
          return this.compile().code;
        };
        _Root_prototype.toFunction = Node.prototype.toFunction;
        _Root_prototype.isLarge = function () {
          return true;
        };
        _Root_prototype.walk = function (walker) {
          var body;
          body = this.body.walk(walker);
          if (body !== this.body) {
            return Root(body, this.variables, this.declarations);
          } else {
            return this;
          }
        };
        _Root_prototype.mutateLast = function (func, includeNoop) {
          var body;
          body = this.body.mutateLast(func, includeNoop);
          if (body !== this.body) {
            return Root(body, this.variables, this.declarations);
          } else {
            return this;
          }
        };
        _Root_prototype.exitType = function () {
          return this.last().exitType();
        };
        _Root_prototype.last = function () {
          var _ref;
          return (_ref = this.body)[__num(_ref.length) - 1];
        };
        _Root_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "Root",
            this.body,
            this.variables,
            this.declarations
          );
        };
        _Root_prototype.toJSON = function () {
          return { type: "Root", body: simplify(this.body), variables: simplify(this.variables), declarations: simplify(this.declarations) };
        };
        Root.fromJSON = function (_p) {
          var body, declarations, variables;
          body = _p.body;
          variables = _p.variables;
          declarations = _p.declarations;
          return Root(fromJSON(body), variables, declarations);
        };
        return Root;
      }());
      exports.This = This = (function (Expression) {
        var _Expression_prototype, _This_prototype;
        function This() {
          var _this;
          _this = this instanceof This ? this : __create(_This_prototype);
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _This_prototype = This.prototype = __create(_Expression_prototype);
        _This_prototype.constructor = This;
        This.displayName = "This";
        _This_prototype.compile = function (options, level, lineStart, sb) {
          sb("this");
        };
        _This_prototype.compileAsBlock = function (options, level, lineStart, sb) {
          Noop().compileAsBlock(options, level, lineStart, sb);
        };
        _This_prototype.isNoop = function () {
          return true;
        };
        _This_prototype.walk = function () {
          return this;
        };
        _This_prototype.inspect = function () {
          return "This()";
        };
        _This_prototype.toJSON = function () {
          return { type: "This" };
        };
        This.fromJSON = function () {
          return This();
        };
        return This;
      }(Expression));
      exports.Throw = Throw = (function (Statement) {
        var _Statement_prototype, _Throw_prototype;
        function Throw(node) {
          var _this;
          _this = this instanceof Throw ? this : __create(_Throw_prototype);
          if (node == null) {
            node = Noop();
          } else if (!(node instanceof Expression)) {
            throw TypeError("Expected node to be an Expression, got " + __typeof(node));
          }
          _this.node = node;
          if (typeof node.toStatement === "function") {
            return node.toStatement().mutateLast(Throw, true);
          }
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _Throw_prototype = Throw.prototype = __create(_Statement_prototype);
        _Throw_prototype.constructor = Throw;
        Throw.displayName = "Throw";
        _Throw_prototype.compile = function (options, level, lineStart, sb) {
          sb("throw ");
          this.node.compile(options, Level.insideParentheses, false, sb);
          return sb(";");
        };
        _Throw_prototype.walk = function (walker) {
          var _ref, node;
          if ((_ref = walker(this.node)) != null) {
            node = _ref;
          } else {
            node = this.node.walk(walker);
          }
          if (node !== this.node) {
            return Throw(node);
          } else {
            return this;
          }
        };
        _Throw_prototype.exitType = function () {
          return "throw";
        };
        _Throw_prototype.isSmall = function () {
          return this.node.isSmall();
        };
        _Throw_prototype.isLarge = function () {
          return this.node.isLarge();
        };
        _Throw_prototype.inspect = function (depth) {
          return inspectHelper(depth, "Throw", this.node);
        };
        _Throw_prototype.toJSON = function () {
          return { type: "Throw", node: simplify(this.node) };
        };
        Throw.fromJSON = function (_p) {
          var node;
          node = _p.node;
          return Throw(fromJSON(node));
        };
        return Throw;
      }(Statement));
      exports.Switch = Switch = (function (Statement) {
        var _Statement_prototype, _Switch_prototype, SwitchCase;
        function Switch(node, cases, defaultCase, label) {
          var _i, _len, _this;
          _this = this instanceof Switch ? this : __create(_Switch_prototype);
          if (node == null) {
            node = Noop();
          }
          if (cases == null) {
            cases = [];
          } else if (!__isArray(cases)) {
            throw TypeError("Expected cases to be an Array, got " + __typeof(cases));
          } else {
            for (_i = 0, _len = cases.length; _i < _len; ++_i) {
              if (!(cases[_i] instanceof SwitchCase)) {
                throw TypeError("Expected cases[" + _i + "] to be a SwitchCase, got " + __typeof(cases[_i]));
              }
            }
          }
          _this.cases = cases;
          if (defaultCase == null) {
            defaultCase = Noop();
          } else if (!(defaultCase instanceof Node)) {
            throw TypeError("Expected defaultCase to be a Node, got " + __typeof(defaultCase));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof Ident)) {
            throw TypeError("Expected label to be an Ident or null, got " + __typeof(label));
          }
          _this.label = label;
          if (!(node instanceof Expression)) {
            node = toConst(node);
          }
          _this.node = node;
          _this.defaultCase = defaultCase.maybeToStatement();
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _Switch_prototype = Switch.prototype = __create(_Statement_prototype);
        _Switch_prototype.constructor = Switch;
        Switch.displayName = "Switch";
        _Switch_prototype.compile = function (options, level, lineStart, sb) {
          var _arr, _i, _len, case_, childOptions;
          if (level !== Level.block) {
            throw Error("Cannot compile a statement except on the Block level");
          }
          if (this.label != null) {
            this.label.compile(options, level, lineStart, sb);
            sb(": ");
          }
          sb("switch (");
          this.node.compile(options, Level.insideParentheses, false, sb);
          sb(") {");
          childOptions = incIndent(options);
          for (_arr = __toArray(this.cases), _i = 0, _len = _arr.length; _i < _len; ++_i) {
            case_ = _arr[_i];
            sb("\n");
            sb.indent(options.indent);
            sb("case ");
            case_.node.compile(options, Level.insideParentheses, false, sb);
            sb(":");
            if (!case_.body.isNoop()) {
              if (case_.node.isSmall() && case_.body.isSmall()) {
                sb(" ");
                case_.body.compileAsStatement(options, true, sb);
              } else {
                sb("\n");
                sb.indent(childOptions.indent);
                case_.body.compileAsStatement(childOptions, true, sb);
              }
            }
          }
          if (!this.defaultCase.isNoop()) {
            sb("\n");
            sb.indent(options.indent);
            sb("default:");
            if (this.defaultCase.isSmall()) {
              sb(" ");
              this.defaultCase.compileAsStatement(options, true, sb);
            } else {
              sb("\n");
              sb.indent(childOptions.indent);
              this.defaultCase.compileAsStatement(childOptions, true, sb);
            }
          }
          sb("\n");
          sb.indent(options.indent);
          sb("}");
        };
        _Switch_prototype.walk = function (walker) {
          var _ref, cases, defaultCase, label, node;
          if ((_ref = walker(this.node)) != null) {
            node = _ref;
          } else {
            node = this.node.walk(walker);
          }
          cases = walkArray(this.cases, walker);
          if ((_ref = walker(this.defaultCase)) != null) {
            defaultCase = _ref;
          } else {
            defaultCase = this.defaultCase.walk(walker);
          }
          if (this.label != null) {
            if ((_ref = walker(this.label)) != null) {
              label = _ref;
            } else {
              label = this.label.walk(walker);
            }
          } else {
            label = this.label;
          }
          if (node !== this.node || cases !== this.cases || defaultCase !== this.defaultCase || label !== this.label) {
            return Switch(node, cases, defaultCase, label);
          } else {
            return this;
          }
        };
        _Switch_prototype.inspect = function (depth) {
          return this.inspectHelper(
            depth,
            "Switch",
            this.node,
            this.cases,
            this.defaultCase,
            this.label
          );
        };
        _Switch_prototype.toJSON = function () {
          var _ref, _this;
          _this = this;
          return {
            type: "Switch",
            node: simplify(this.node),
            cases: simplify((function () {
              var _arr, _arr2, _i, _len, case_;
              for (_arr = [], _arr2 = __toArray(_this.cases), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                case_ = _arr2[_i];
                _arr.push({ node: simplify(case_.node), body: simplify(case_.body) });
              }
              return _arr;
            }())),
            defaultCase: simplify(this.defaultCase),
            label: (_ref = this.label) != null ? _ref : void 0
          };
        };
        Switch.fromJSON = function (_p) {
          var _arr, _i, _len, case_, cases, defaultCase, label, node, resultCases;
          node = _p.node;
          cases = _p.cases;
          defaultCase = _p.defaultCase;
          label = _p.label;
          resultCases = [];
          for (_arr = __toArray(cases || []), _i = 0, _len = _arr.length; _i < _len; ++_i) {
            case_ = _arr[_i];
            if (!case_ || typeof case_ !== "object") {
              throw Error("Expected an object with a node and body");
            }
            resultCases.push(SwitchCase(fromJSON(case_.node), fromJSON(case_.body)));
          }
          return Switch(fromJSON(node), resultCases, fromJSON(defaultCase), label != null ? fromJSON(label) : null);
        };
        Switch.Case = SwitchCase = (function () {
          var _SwitchCase_prototype;
          function SwitchCase(node, body) {
            var _this;
            _this = this instanceof SwitchCase ? this : __create(_SwitchCase_prototype);
            if (node == null) {
              node = Noop();
            }
            if (body == null) {
              body = Noop();
            } else if (!(body instanceof Node)) {
              throw TypeError("Expected body to be a Node, got " + __typeof(body));
            }
            if (!(node instanceof Expression)) {
              node = toConst(node);
            }
            _this.node = node;
            _this.body = body.maybeToStatement();
            return _this;
          }
          _SwitchCase_prototype = SwitchCase.prototype;
          SwitchCase.displayName = "SwitchCase";
          _SwitchCase_prototype.isLarge = function () {
            return true;
          };
          _SwitchCase_prototype.isSmall = function () {
            return false;
          };
          _SwitchCase_prototype.walk = function (walker) {
            var _ref, body, node;
            if ((_ref = walker(this.node)) != null) {
              node = _ref;
            } else {
              node = this.node.walk(walker);
            }
            if ((_ref = walker(this.body)) != null) {
              body = _ref;
            } else {
              body = this.body.walk(walker);
            }
            if (node !== this.node || body !== this.body) {
              return SwitchCase(node, body);
            } else {
              return this;
            }
          };
          _SwitchCase_prototype.inspect = function (depth) {
            return inspectHelper(depth, "Case", this.node, this.body);
          };
          return SwitchCase;
        }());
        return Switch;
      }(Statement));
      exports.TryCatch = TryCatch = (function (Statement) {
        var _Statement_prototype, _TryCatch_prototype;
        function TryCatch(tryBody, catchIdent, catchBody, label) {
          var _this;
          _this = this instanceof TryCatch ? this : __create(_TryCatch_prototype);
          if (tryBody == null) {
            tryBody = Noop();
          } else if (!(tryBody instanceof Node)) {
            throw TypeError("Expected tryBody to be a Node, got " + __typeof(tryBody));
          }
          if (!(catchIdent instanceof Ident)) {
            throw TypeError("Expected catchIdent to be an Ident, got " + __typeof(catchIdent));
          }
          _this.catchIdent = catchIdent;
          if (catchBody == null) {
            catchBody = Noop();
          } else if (!(catchBody instanceof Node)) {
            throw TypeError("Expected catchBody to be a Node, got " + __typeof(catchBody));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof Ident)) {
            throw TypeError("Expected label to be an Ident or null, got " + __typeof(label));
          }
          _this.label = label;
          _this.tryBody = tryBody.maybeToStatement();
          if (_this.tryBody.isNoop()) {
            return _this.tryBody;
          }
          _this.catchBody = catchBody.maybeToStatement();
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _TryCatch_prototype = TryCatch.prototype = __create(_Statement_prototype);
        _TryCatch_prototype.constructor = TryCatch;
        TryCatch.displayName = "TryCatch";
        _TryCatch_prototype.compile = function (options, level, lineStart, sb) {
          var childOptions;
          if (level !== Level.block) {
            throw Error("Cannot compile a statement except on the Block level");
          }
          if (this.label != null) {
            this.label.compile(options, level, lineStart, sb);
            sb(": ");
          }
          sb("try {\n");
          childOptions = incIndent(options);
          sb.indent(childOptions.indent);
          this.tryBody.compileAsStatement(childOptions, true, sb);
          sb("\n");
          sb.indent(options.indent);
          sb("} catch (");
          this.catchIdent.compile(options, Level.insideParentheses, false, sb);
          sb(") {");
          if (!this.catchBody.isNoop()) {
            sb("\n");
            sb.indent(childOptions.indent);
            this.catchBody.compileAsStatement(childOptions, true, sb);
            sb("\n");
            sb.indent(options.indent);
          }
          sb("}");
        };
        _TryCatch_prototype.walk = function (walker) {
          var _ref, catchBody, catchIdent, label, tryBody;
          if ((_ref = walker(this.tryBody)) != null) {
            tryBody = _ref;
          } else {
            tryBody = this.tryBody.walk(walker);
          }
          if ((_ref = walker(this.catchIdent)) != null) {
            catchIdent = _ref;
          } else {
            catchIdent = this.catchIdent.walk(walker);
          }
          if ((_ref = walker(this.catchBody)) != null) {
            catchBody = _ref;
          } else {
            catchBody = this.catchBody.walk(walker);
          }
          if (this.label != null) {
            if ((_ref = walker(this.label)) != null) {
              label = _ref;
            } else {
              label = this.label.walk(walker);
            }
          } else {
            label = this.label;
          }
          if (tryBody !== this.tryBody || catchIdent !== this.catchIdent || catchBody !== this.catchBody || label !== this.label) {
            return TryCatch(tryBody, catchIdent, catchBody, label);
          } else {
            return this;
          }
        };
        _TryCatch_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "TryCatch",
            this.tryBody,
            this.catchIdent,
            this.catchBody,
            this.label
          );
        };
        _TryCatch_prototype.toJSON = function () {
          var _ref;
          return {
            type: "TryCatch",
            tryBody: simplify(this.tryBody),
            catchIdent: this.catchIdent,
            catchBody: simplify(this.catchBody),
            label: (_ref = this.label) != null ? _ref : void 0
          };
        };
        TryCatch.fromJSON = function (_p) {
          var catchBody, catchIdent, label, tryBody;
          tryBody = _p.tryBody;
          catchIdent = _p.catchIdent;
          catchBody = _p.catchBody;
          label = _p.label;
          return TryCatch(fromJSON(tryBody), fromJSON(catchIdent), fromJSON(catchBody), label != null ? fromJSON(label) : null);
        };
        return TryCatch;
      }(Statement));
      exports.TryFinally = TryFinally = (function (Statement) {
        var _Statement_prototype, _TryFinally_prototype;
        function TryFinally(tryBody, finallyBody, label) {
          var _this;
          _this = this instanceof TryFinally ? this : __create(_TryFinally_prototype);
          if (tryBody == null) {
            tryBody = Noop();
          } else if (!(tryBody instanceof Node)) {
            throw TypeError("Expected tryBody to be a Node, got " + __typeof(tryBody));
          }
          if (finallyBody == null) {
            finallyBody = Noop();
          } else if (!(finallyBody instanceof Node)) {
            throw TypeError("Expected finallyBody to be a Node, got " + __typeof(finallyBody));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof Ident)) {
            throw TypeError("Expected label to be an Ident or null, got " + __typeof(label));
          }
          _this.label = label;
          _this.tryBody = tryBody.maybeToStatement();
          _this.finallyBody = finallyBody.maybeToStatement();
          if (label == null) {
            if (_this.tryBody.isNoop()) {
              return _this.finallyBody;
            } else if (_this.finallyBody.isNoop()) {
              return _this.tryBody;
            }
          }
          return _this;
        }
        _Statement_prototype = Statement.prototype;
        _TryFinally_prototype = TryFinally.prototype = __create(_Statement_prototype);
        _TryFinally_prototype.constructor = TryFinally;
        TryFinally.displayName = "TryFinally";
        _TryFinally_prototype.compile = function (options, level, lineStart, sb) {
          var childOptions;
          if (level !== Level.block) {
            throw Error("Cannot compile a statement except on the Block level");
          }
          if (this.label != null) {
            this.label.compile(options, level, lineStart, sb);
            sb(": ");
          }
          sb("try {\n");
          childOptions = incIndent(options);
          sb.indent(childOptions.indent);
          if (this.tryBody instanceof TryCatch && this.tryBody.label == null) {
            this.tryBody.tryBody.compileAsStatement(childOptions, true, sb);
            sb("\n");
            sb.indent(options.indent);
            sb("} catch (");
            this.tryBody.catchIdent.compile(options, Level.insideParentheses, false, sb);
            sb(") {");
            if (!this.tryBody.catchBody.isNoop()) {
              sb("\n");
              sb.indent(childOptions.indent);
              this.tryBody.catchBody.compileAsStatement(childOptions, true, sb);
              sb("\n");
              sb.indent(options.indent);
            }
          } else {
            this.tryBody.compileAsStatement(childOptions, true, sb);
            sb("\n");
            sb.indent(options.indent);
          }
          sb("} finally {\n");
          sb.indent(childOptions.indent);
          this.finallyBody.compileAsStatement(childOptions, true, sb);
          sb("\n");
          sb.indent(options.indent);
          sb("}");
        };
        _TryFinally_prototype.walk = function (walker) {
          var _ref, finallyBody, label, tryBody;
          if ((_ref = walker(this.tryBody)) != null) {
            tryBody = _ref;
          } else {
            tryBody = this.tryBody.walk(walker);
          }
          if ((_ref = walker(this.finallyBody)) != null) {
            finallyBody = _ref;
          } else {
            finallyBody = this.finallyBody.walk(walker);
          }
          if (this.label != null) {
            if ((_ref = walker(this.label)) != null) {
              label = _ref;
            } else {
              label = this.label.walk(walker);
            }
          } else {
            label = this.label;
          }
          if (tryBody !== this.tryBody || finallyBody !== this.finallyBody || label !== this.label) {
            return TryFinally(tryBody, finallyBody, label);
          } else {
            return this;
          }
        };
        _TryFinally_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "TryFinally",
            this.tryBody,
            this.finallyBody,
            this.label
          );
        };
        _TryFinally_prototype.toJSON = function () {
          var _ref;
          return {
            type: "TryFinally",
            tryBody: simplify(this.tryBody),
            finallyBody: simplify(this.finallyBody),
            label: (_ref = this.label) != null ? _ref : void 0
          };
        };
        TryFinally.fromJSON = function (_p) {
          var finallyBody, label, tryBody;
          tryBody = _p.tryBody;
          finallyBody = _p.finallyBody;
          label = _p.label;
          return TryFinally(fromJSON(tryBody), fromJSON(finallyBody), label != null ? fromJSON(label) : null);
        };
        return TryFinally;
      }(Statement));
      exports.Unary = Unary = (function (Expression) {
        var _Expression_prototype, _Unary_prototype, ASSIGNMENT_OPERATORS, KNOWN_OPERATORS;
        function Unary(op, node) {
          var _this;
          _this = this instanceof Unary ? this : __create(_Unary_prototype);
          if (typeof op !== "string") {
            throw TypeError("Expected op to be a String, got " + __typeof(op));
          }
          _this.op = op;
          if (node == null) {
            node = Noop();
          }
          if (!__in(op, KNOWN_OPERATORS)) {
            throw Error("Unknown unary operator: " + op);
          }
          if (!(node instanceof Expression)) {
            node = toConst(node);
          }
          if (op === "delete" && (!(node instanceof Binary) || node.op !== ".")) {
            throw Error("Cannot use delete operator on a non-access");
          }
          _this.node = node;
          return _this;
        }
        _Expression_prototype = Expression.prototype;
        _Unary_prototype = Unary.prototype = __create(_Expression_prototype);
        _Unary_prototype.constructor = Unary;
        Unary.displayName = "Unary";
        _Unary_prototype.compile = function (options, level, lineStart, sb) {
          var op;
          op = this.op;
          if (op === "++post" || op === "--post") {
            this.node.compile(options, Level.unary, false, sb);
            sb(op.substring(0, 2));
          } else {
            sb(op);
            if (op === "typeof" || op === "void" || op === "delete" || (op === "+" || op === "-" || op === "++" || op === "--") && (this.node instanceof Unary && (op === "+" || op === "-" || op === "++" || op === "--") || this.node instanceof Const && typeof this.node.value === "number" && isNegative(this.node.value))) {
              sb(" ");
            }
            this.node.compile(options, Level.unary, false, sb);
          }
        };
        _Unary_prototype.compileAsBlock = function (options, level, lineStart, sb) {
          var op;
          op = this.op;
          if (__owns.call(ASSIGNMENT_OPERATORS, op)) {
            this.compile(options, level, lineStart, sb);
          } else {
            this.node.compileAsBlock(options, level, lineStart, sb);
          }
        };
        _Unary_prototype.compileAsStatement = function (options, lineStart, sb) {
          var op;
          op = this.op;
          if (__owns.call(ASSIGNMENT_OPERATORS, op)) {
            _Expression_prototype.compileAsStatement.call(this, options, lineStart, sb);
          } else {
            this.node.compileAsStatement(options, lineStart, sb);
          }
        };
        KNOWN_OPERATORS = [
          "++",
          "--",
          "++post",
          "--post",
          "!",
          "~",
          "+",
          "-",
          "typeof",
          "void",
          "delete"
        ];
        ASSIGNMENT_OPERATORS = {
          "++": true,
          "--": true,
          "++post": true,
          "--post": true,
          "delete": true
        };
        _Unary_prototype.isLarge = function () {
          return this.node.isLarge();
        };
        _Unary_prototype.isSmall = function () {
          return this.node.isSmall();
        };
        _Unary_prototype.isNoop = function () {
          var _ref;
          if ((_ref = this._isNoop) == null) {
            return this._isNoop = !__owns.call(ASSIGNMENT_OPERATORS, this.op) && this.node.isNoop();
          } else {
            return _ref;
          }
        };
        _Unary_prototype.walk = function (walker) {
          var _ref, node;
          if ((_ref = walker(this.node)) != null) {
            node = _ref;
          } else {
            node = this.node.walk(walker);
          }
          if (node !== this.node) {
            return Unary(this.op, node);
          } else {
            return this;
          }
        };
        _Unary_prototype.inspect = function (depth) {
          return inspectHelper(depth, "Unary", this.op, this.node);
        };
        _Unary_prototype.toJSON = function () {
          return { type: "Unary", op: this.op, node: simplify(this.node) };
        };
        Unary.fromJSON = function (_p) {
          var node, op;
          op = _p.op;
          node = _p.node;
          return Unary(op, fromJSON(node));
        };
        return Unary;
      }(Expression));
      While = exports.While = function (test, body, label) {
        return For(
          null,
          test,
          null,
          body,
          label
        );
      };
      fromJSON = exports.fromJSON = function (obj) {
        if (obj == null) {
          return Noop();
        }
        if (typeof obj !== "object") {
          throw TypeError("Must provide an object to deserialize");
        }
        if (Array.isArray(obj)) {
          throw TypeError("Not expecting an array");
        }
        if (typeof obj.type !== "string") {
          throw Error("Expected an object with a string 'type' key");
        }
        if (!__owns.call(exports, obj.type)) {
          throw Error("Unknown node type: " + __strnum(obj.type));
        }
        return exports[obj.type].fromJSON(obj);
      };
      function arrayFromJSON(array) {
        var _arr, _arr2, _i, _len, item;
        if (array == null) {
          return [];
        } else if (Array.isArray(array)) {
          for (_arr = [], _arr2 = __toArray(array), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
            item = _arr2[_i];
            _arr.push(fromJSON(item));
          }
          return _arr;
        } else {
          throw Error("Expected an array, got " + __typeof(array));
        }
      }
    }.call(this));
    
    return module.exports;
  }.call({}));
  require['./parser'] = (function () {
    var module = { exports: this };
    var exports = this;
    (function (GLOBAL) {
      "use strict";
      var __async, __asyncResult, __bind, __cmp, __create, __in, __isArray, __isObject, __lt, __lte, __num, __once, __owns, __slice, __str, __strnum, __toArray, __typeof, _asterixAsArrayLength, _Block, _FunctionBody, _inAst, _inFunctionTypeParams, _inGenerator, _inMacro, _Name, _NameOrSymbol, _position, _preventUnclosedObjectLiteral, _Space, _Symbol, AccessMultiNode, AccessNode, Advance, AnyArrayLiteral, AnyChar, AnyObjectLiteral, ArgsNode, ArgumentsLiteral, ArrayLiteral, ArrayNode, ArrayParameter, ArrayType, Assignment, AssignmentAsExpression, AssignNode, Ast, Asterix, asterixAsArrayLength, AstExpression, AstExpressionToken, AsToken, AstStatement, AstToken, AtSign, Backslash, BackslashEscapeSequence, BackslashStringLiteral, BasicInvocationOrAccess, BinaryDigit, BinaryNode, BinaryNumber, Block, BlockNode, Body, BOM, BracketedObjectKey, BreakNode, CallNode, CheckIndent, CheckStop, CloseCurlyBrace, ClosedArguments, CloseParenthesis, CloseSquareBracket, Colon, ColonChar, Comma, CommaOrNewline, CommaOrNewlineWithCheckIndent, CommentNode, ComplexAssignable, ConstantLiteral, ConstNode, ConstObjectKey, ContinueNode, convertInvocationOrAccess, CountIndent, CURRENT_ARRAY_LENGTH_NAME, CustomAssignment, CustomBinaryOperator, CustomOperatorCloseParenthesis, CustomPostfixUnary, CustomPrefixUnary, DebuggerNode, DecimalDigit, DecimalNumber, DeclareEqualSymbol, DedentedBody, DefineHelper, DefineHelperStart, DefineMacro, DefineOperator, DefineOperatorStart, DefineSyntax, DefineSyntaxStart, DefNode, DirectAssignment, DollarSign, DoubleColon, DoubleQuote, DoubleStringArrayLiteral, DoubleStringLiteral, DoubleStringLiteralInner, DualObjectKey, EmptyLine, EmptyLines, Eval, EvalNode, EvalToken, Expression, ExpressionAsStatement, ExpressionOrAssignment, FailureManager, FalseLiteral, ForInNode, ForNode, freeze, fromCharCode, FunctionBody, FunctionDeclaration, FunctionLiteral, FunctionNode, FunctionType, generateCacheKey, GeneratorFunctionBody, getTmpId, getUseCustomBinaryOperator, HashSign, HexDigit, HexEscapeSequence, HexNumber, Identifier, IdentifierNameConst, IdentifierNameConstOrNumberLiteral, IdentifierOrAccess, IdentifierOrAccessPart, IdentifierOrAccessStart, IdentifierOrSimpleAccess, IdentifierOrSimpleAccessPart, IdentifierOrSimpleAccessStart, IdentifierParameter, IdentNode, IfNode, inAst, IndentedUnclosedArrayLiteral, IndentedUnclosedArrayLiteralInner, IndentedUnclosedObjectLiteral, IndentedUnclosedObjectLiteralInner, INDENTS, Index, inExpression, InfinityLiteral, inFunctionTypeParams, inMacro, inspect, inStatement, InvocationArguments, InvocationOrAccess, InvocationOrAccessPart, KeyValuePair, KvpParameter, Letter, LicenseComment, Line, Literal, Logic, LowerR, LowerU, LowerX, MacroAccessNode, MacroBody, MacroError, MacroHelper, MacroHolder, MacroName, MacroNames, MacroOptions, MacroSyntax, MacroSyntaxChoiceParameters, MacroSyntaxParameter, MacroSyntaxParameters, MacroSyntaxParameterType, MacroToken, MaybeAdvance, MaybeAsType, MaybeComma, MaybeCommaOrNewline, MaybeComment, MaybeExclamationPointNoSpace, MaybeExistentialSymbolNoSpace, MaybeNotToken, MaybeSpreadToken, Minus, Name, NameChar, NamePart, NameStart, NaNLiteral, Newline, NewlineWithCheckIndent, nextTick, Node, nodeToType, NonUnionType, NoSpace, NotColon, NOTHING, Nothing, NothingNode, notInFunctionTypeParams, NullLiteral, NumberChar, NumberLiteral, ObjectKey, ObjectKeyColon, ObjectLiteral, ObjectNode, ObjectParameter, ObjectType, ObjectTypePair, OctalDigit, OctalNumber, OpenCurlyBrace, OpenParenthesis, OpenSquareBracket, OpenSquareBracketChar, ParamDualObjectKey, Parameter, ParameterOrNothing, Parameters, ParameterSequence, ParamNode, ParamSingularObjectKey, Parenthetical, ParserError, PercentSign, PercentSignDoubleQuote, PercentSignTripleDoubleQuote, Period, Pipe, Plus, PlusOrMinus, PopIndent, preventUnclosedObjectLiteral, PrimaryExpression, PropertyDualObjectKey, PropertyObjectKeyColon, PropertyOrDualObjectKey, PushFakeIndent, PushIndent, RadixNumber, RegexComment, RegexDoubleToken, RegexFlags, RegexLiteral, RegexpNode, RegexSingleToken, RegexTripleDoubleToken, RegexTripleSingleToken, RESERVED_IDENTS, ReturnNode, RootNode, Scope, Semicolon, Shebang, SHORT_CIRCUIT, SimpleAssignable, SimpleConstantLiteral, SingleEscapeCharacter, SingleQuote, SingleStringLiteral, SingularObjectKey, SomeEmptyLines, SomeEmptyLinesWithCheckIndent, Space, SpaceChar, SpreadNode, SpreadOrExpression, Stack, State, Statement, StringIndent, StringInterpolation, StringLiteral, SuperInvocation, SuperNode, SuperToken, SwitchNode, Symbol, SymbolChar, SyntaxChoiceNode, SyntaxManyNode, SyntaxParamNode, SyntaxSequenceNode, SyntaxToken, ThisLiteral, ThisNode, ThisOrShorthandLiteral, ThisOrShorthandLiteralPeriod, ThisShorthandLiteral, ThrowNode, TmpNode, TmpWrapperNode, TripleDoubleQuote, TripleDoubleStringArrayLiteral, TripleDoubleStringLine, TripleDoubleStringLiteral, TripleSingleQuote, TripleSingleStringLine, TripleSingleStringLiteral, TrueLiteral, TryCatchNode, TryFinallyNode, Type, TypeArrayNode, TypeFunctionNode, TypeObjectNode, TypeReference, TypeUnionNode, UnaryNode, UnclosedArguments, UnclosedArrayLiteralElement, UnclosedObjectLiteral, Underscore, UnicodeEscapeSequence, UseMacro, util, VarNode, VoidLiteral, YieldNode, Zero;
      __async = function (limit, length, onValue, onComplete) {
        var broken, index, slotsUsed, sync;
        if (length <= 0) {
          return onComplete(null);
        }
        if (limit < 1 || limit !== limit) {
          limit = 1/0;
        }
        broken = null;
        slotsUsed = 0;
        sync = false;
        function onValueCallback(err) {
          --slotsUsed;
          if (err != null && broken == null) {
            broken = err;
          }
          if (!sync) {
            return next();
          }
        }
        index = 0;
        function next() {
          var f, i;
          while (broken == null && slotsUsed < limit && index < length) {
            ++slotsUsed;
            i = index;
            ++index;
            sync = true;
            onValue(i, __once(onValueCallback));
            sync = false;
          }
          if (broken != null || slotsUsed === 0) {
            f = onComplete;
            onComplete = void 0;
            if (f) {
              return f(broken);
            }
          }
        }
        return next();
      };
      __asyncResult = function (limit, length, onValue, onComplete) {
        var broken, index, result, slotsUsed, sync;
        if (length <= 0) {
          return onComplete(null, []);
        }
        if (limit < 1 || limit !== limit) {
          limit = 1/0;
        }
        broken = null;
        slotsUsed = 0;
        sync = false;
        result = [];
        function onValueCallback(err, value) {
          --slotsUsed;
          if (err != null && broken == null) {
            broken = err;
          }
          if (broken == null && arguments.length > 1) {
            result.push(value);
          }
          if (!sync) {
            return next();
          }
        }
        index = 0;
        function next() {
          var f, i;
          while (broken == null && slotsUsed < limit && index < length) {
            ++slotsUsed;
            i = index;
            ++index;
            sync = true;
            onValue(i, __once(onValueCallback));
            sync = false;
          }
          if (broken != null || slotsUsed === 0) {
            f = onComplete;
            onComplete = void 0;
            if (f) {
              if (broken != null) {
                return f(broken);
              } else {
                return f(null, result);
              }
            }
          }
        }
        return next();
      };
      __bind = function (parent, child) {
        var func;
        if (parent == null) {
          throw TypeError("Expected parent to be an object, got " + __typeof(parent));
        }
        func = parent[child];
        if (typeof func !== "function") {
          throw Error("Trying to bind child '" + String(child) + "' which is not a function");
        }
        return function () {
          return func.apply(parent, arguments);
        };
      };
      __cmp = function (left, right) {
        var type;
        if (left === right) {
          return 0;
        } else {
          type = typeof left;
          if (type !== "number" && type !== "string") {
            throw TypeError("Cannot compare a non-number/string: " + type);
          } else if (type !== typeof right) {
            throw TypeError("Cannot compare elements of different types: " + type + " vs " + typeof right);
          } else if (left < right) {
            return -1;
          } else {
            return 1;
          }
        }
      };
      __create = typeof Object.create === "function" ? Object.create
        : function (x) {
          function F() {}
          F.prototype = x;
          return new F();
        };
      __in = typeof Array.prototype.indexOf === "function"
        ? (function () {
          var indexOf;
          indexOf = Array.prototype.indexOf;
          return function (child, parent) {
            return indexOf.call(parent, child) !== -1;
          };
        }())
        : function (child, parent) {
          var i, len;
          len = +parent.length;
          i = -1;
          while (++i < len) {
            if (child === parent[i] && i in parent) {
              return true;
            }
          }
          return false;
        };
      __isArray = typeof Array.isArray === "function" ? Array.isArray
        : (function () {
          var _toString;
          _toString = Object.prototype.toString;
          return function (x) {
            return _toString.call(x) === "[object Array]";
          };
        }());
      __isObject = function (x) {
        return typeof x === "object" && x !== null;
      };
      __lt = function (x, y) {
        var type;
        type = typeof x;
        if (type !== "number" && type !== "string") {
          throw TypeError("Cannot compare a non-number/string: " + type);
        } else if (type !== typeof y) {
          throw TypeError("Cannot compare elements of different types: " + type + " vs " + typeof y);
        } else {
          return x < y;
        }
      };
      __lte = function (x, y) {
        var type;
        type = typeof x;
        if (type !== "number" && type !== "string") {
          throw TypeError("Cannot compare a non-number/string: " + type);
        } else if (type !== typeof y) {
          throw TypeError("Cannot compare elements of different types: " + type + " vs " + typeof y);
        } else {
          return x <= y;
        }
      };
      __num = function (num) {
        if (typeof num !== "number") {
          throw TypeError("Expected a number, got " + __typeof(num));
        } else {
          return num;
        }
      };
      __once = function (func) {
        if (typeof func !== "function") {
          throw Error("Expected func to be a Function, got " + __typeof(func));
        }
        return function () {
          var f;
          if (func) {
            f = func;
            func = null;
            return f.apply(this, arguments);
          } else {
            throw Error("Attempted to call function more than once");
          }
        };
      };
      __owns = Object.prototype.hasOwnProperty;
      __slice = Array.prototype.slice;
      __str = function (str) {
        if (typeof str !== "string") {
          throw TypeError("Expected a string, got " + __typeof(str));
        } else {
          return str;
        }
      };
      __strnum = function (strnum) {
        var type;
        type = typeof strnum;
        if (type === "string") {
          return strnum;
        } else if (type === "number") {
          return String(strnum);
        } else {
          throw TypeError("Expected a string or number, got " + __typeof(strnum));
        }
      };
      __toArray = function (x) {
        if (x == null) {
          throw TypeError("Expected an object, got " + __typeof(x));
        } else if (__isArray(x)) {
          return x;
        } else if (typeof x === "string") {
          return x.split("");
        } else {
          return __slice.call(x);
        }
      };
      __typeof = (function () {
        var _toString;
        _toString = Object.prototype.toString;
        return function (o) {
          if (o === void 0) {
            return "Undefined";
          } else if (o === null) {
            return "Null";
          } else {
            return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);
          }
        };
      }());
      Type = require("./types");
      util = require("util");
      if (util != null) {
        inspect = util.inspect;
      }
      if (typeof Object.freeze === "function") {
        freeze = Object.freeze;
      } else {
        freeze = function (o) {
          return o;
        };
      }
      if (typeof process !== "undefined" && typeof process.nextTick === "function") {
        nextTick = process.nextTick;
      } else {
        nextTick = function (f) {
          return setTimeout(f, 0);
        };
      }
      SHORT_CIRCUIT = freeze({
        toString: function () {
          return "short-circuit";
        }
      });
      NOTHING = freeze({
        toString: function () {
          return "";
        }
      });
      generateCacheKey = (function () {
        var id;
        id = -1;
        return function () {
          return ++id;
        };
      }());
      function copy(o) {
        var k, result, v;
        if (!__isObject(o)) {
          throw TypeError("Expected o to be an Object, got " + __typeof(o));
        }
        result = {};
        for (k in o) {
          if (__owns.call(o, k)) {
            v = o[k];
            result[k] = v;
          }
        }
        return result;
      }
      function assert(value) {
        if (!value) {
          throw Error("Assertion failed: " + String(value));
        }
        return value;
      }
      function named(name, func) {
        if (name == null) {
          name = null;
        } else if (typeof name !== "string") {
          throw TypeError("Expected name to be a null or String, got " + __typeof(name));
        }
        if (typeof func !== "function") {
          throw TypeError("Expected func to be a Function, got " + __typeof(func));
        }
        if (name) {
          func.parserName = name;
        }
        return func;
      }
      function identity(x) {
        return x;
      }
      function retThis() {
        return this;
      }
      getTmpId = (function () {
        var id;
        id = -1;
        return function () {
          return ++id;
        };
      }());
      function cache(rule, dontCache) {
        var cacheKey;
        if (typeof rule !== "function") {
          throw TypeError("Expected rule to be a Function, got " + __typeof(rule));
        }
        if (dontCache == null) {
          dontCache = false;
        } else if (typeof dontCache !== "boolean") {
          throw TypeError("Expected dontCache to be a Boolean, got " + __typeof(dontCache));
        }
        if (dontCache) {
          return rule;
        } else {
          cacheKey = generateCacheKey();
          return named(rule.parserName, function (o) {
            var _ref, _ref2, cache, indent, indentCache, index, inner, item, result;
            cache = o.cache;
            index = o.index;
            indent = o.indent.peek();
            if ((_ref = cache[_ref2 = indent - 1]) != null) {
              indentCache = _ref;
            } else {
              indentCache = cache[_ref2] = [];
            }
            if ((_ref = indentCache[_ref2 = index % 16]) != null) {
              inner = _ref;
            } else {
              inner = indentCache[_ref2] = [];
            }
            item = inner[cacheKey];
            if (item && item[0] === index) {
              o.index = item[1];
              o.line = item[2];
              return item[3];
            } else {
              result = rule(o);
              if (o.indent.peek() !== indent) {
                throw Error("Changed indent during cache process: from " + __strnum(indent) + " to " + __strnum(o.indent.peek()));
              }
              inner[cacheKey] = [index, o.index, o.line, result];
              return result;
            }
          });
        }
      }
      function sequential(array, mutator, dontCache) {
        var _len, i, item, key, mapping, name, rule, ruleName, rules, shouldWrapName;
        if (!__isArray(array)) {
          throw TypeError("Expected array to be an Array, got " + __typeof(array));
        }
        if (dontCache == null) {
          dontCache = false;
        } else if (typeof dontCache !== "boolean") {
          throw TypeError("Expected dontCache to be a Boolean, got " + __typeof(dontCache));
        }
        if (array.length === 0) {
          throw Error("Cannot provide an empty array");
        }
        name = [];
        rules = [];
        mapping = [];
        shouldWrapName = false;
        for (i = 0, _len = array.length; i < _len; ++i) {
          item = array[i];
          key = void 0;
          rule = void 0;
          if (__isArray(item)) {
            if (item.length !== 2) {
              throw Error("Found an array with " + __strnum(item.length) + " length at index #" + i);
            }
            if (typeof item[0] !== "string") {
              throw TypeError("Array in index #" + i + " has an improper key: " + __typeof(item[0]));
            }
            if (typeof item[1] !== "function") {
              throw TypeError("Array in index #" + i + " has an improper rule: " + __typeof(item[1]));
            }
            key = item[0];
            rule = item[1];
          } else if (typeof item === "function") {
            rule = item;
          } else {
            throw TypeError("Found a non-array, non-function in index #" + i + ": " + __typeof(item));
          }
          rules.push(rule);
          mapping.push(key);
          ruleName = rule.parserName || "<unknown>";
          if (i > 0 && name[name.length - 1].slice(-1) === '"' && ruleName.charCodeAt(0) === 34 && ruleName.slice(-1) === '"') {
            name[name.length - 1] = name[name.length - 1].substring(0, __num(name[name.length - 1].length) - 1);
            name.push(ruleName.substring(1));
          } else {
            if (i > 0) {
              name.push(" ");
              shouldWrapName = true;
            }
            name.push(ruleName);
          }
        }
        if (shouldWrapName) {
          name.splice(0, 0, "(");
          name.push(")");
        }
        name = name.join("");
        return (function () {
          var _rule;
          _rule = named(name, function (o) {
            var _len, clone, i, item, key, result, rule;
            clone = o.clone();
            result = {};
            for (i = 0, _len = rules.length; i < _len; ++i) {
              rule = rules[i];
              item = rule(clone);
              if (!item) {
                return false;
              }
              key = mapping[i];
              if (key) {
                if (key === "this") {
                  result = item;
                } else {
                  result[key] = item;
                }
              }
            }
            o.update(clone);
            return result;
          });
          return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule(o);
            if (!result) {
              return false;
            } else if (typeof mutator === "function") {
              return mutator(result, o, index, line);
            } else if (mutator !== void 0) {
              return mutator;
            } else {
              return result;
            }
          });
        }());
      }
      function ruleEqual(rule, text, mutator) {
        var failureMessage;
        failureMessage = JSON.stringify(text);
        return (function () {
          var _rule;
          _rule = (function () {
            var _rule2;
            _rule2 = named(failureMessage, function (o) {
              var clone, result;
              clone = o.clone();
              result = rule(clone);
              if (result === text) {
                o.update(clone);
                return result;
              } else {
                o.fail(failureMessage);
                return false;
              }
            });
            return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule2(o);
              if (!result) {
                return false;
              } else if (typeof mutator === "function") {
                return mutator(result, o, index, line);
              } else if (mutator !== void 0) {
                return mutator;
              } else {
                return result;
              }
            });
          }());
          return function (o) {
            var clone, result;
            clone = o.clone();
            clone.preventFail();
            result = _rule(clone);
            clone.unpreventFail();
            if (result) {
              o.update(clone);
              return result;
            } else {
              o.fail(failureMessage);
              return false;
            }
          };
        }());
      }
      function word(text, mutator) {
        return ruleEqual(Name, text, mutator);
      }
      function symbol(text, mutator) {
        return ruleEqual(Symbol, text, mutator);
      }
      function wordOrSymbol(text, mutator) {
        var parts;
        parts = [Space];
        parts.push.apply(parts, (function () {
          var _arr, _arr2, _len, i, part;
          for (_arr = [], _arr2 = __toArray(text.split(/([a-z]+)/ig)), i = 0, _len = _arr2.length; i < _len; ++i) {
            part = _arr2[i];
            if (part) {
              if (i % 2 === 0) {
                _arr.push(ruleEqual(_Symbol, part));
              } else {
                _arr.push(ruleEqual(_Name, part));
              }
            }
          }
          return _arr;
        }()));
        return sequential(parts, mutator || text);
      }
      function macroName(text, mutator) {
        var failureMessage;
        failureMessage = JSON.stringify(text);
        return (function () {
          var _rule;
          _rule = named(failureMessage, function (o) {
            var clone, result;
            clone = o.clone();
            result = MacroName(clone);
            if (result === text) {
              o.update(clone);
              return result;
            } else {
              o.fail(failureMessage);
              return false;
            }
          });
          return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule(o);
            if (!result) {
              return false;
            } else if (typeof mutator === "function") {
              return mutator(result, o, index, line);
            } else if (mutator !== void 0) {
              return mutator;
            } else {
              return result;
            }
          });
        }());
      }
      function getFuncName(func) {
        var match;
        if (typeof func !== "function") {
          throw TypeError("Expected func to be a Function, got " + __typeof(func));
        }
        if (func.displayName) {
          return func.displayName;
        } else if (func.name) {
          return func.name;
        } else {
          match = RegExp("^function\\s*(.*?)").exec(func.toString());
          return match && match[1] || func.parserName || "(anonymous)";
        }
      }
      function wrap(func, name) {
        var id;
        if (typeof func !== "function") {
          throw TypeError("Expected func to be a Function, got " + __typeof(func));
        }
        if (name == null) {
          name = getFuncName(func);
        }
        id = -1;
        return named(func.parserName, function (o) {
          var i, result;
          ++id;
          i = id;
          console.log(i + "-" + __strnum(name) + " starting at line #" + __strnum(o.line) + ", index " + __strnum(o.index) + ", indent " + __strnum(o.indent.peek()));
          result = func(o);
          if (!result) {
            console.log(i + "-" + __strnum(name) + " failure at line #" + __strnum(o.line) + ", index " + __strnum(o.index) + ", indent " + __strnum(o.indent.peek()));
          } else {
            console.log(i + "-" + __strnum(name) + " success at line #" + __strnum(o.line) + ", index " + __strnum(o.index) + ", indent " + __strnum(o.indent.peek()), result);
          }
          return result;
        });
      }
      Stack = (function () {
        var _Stack_prototype;
        function Stack(initial, data) {
          var _this;
          _this = this instanceof Stack ? this : __create(_Stack_prototype);
          if (data == null) {
            data = [];
          }
          _this.initial = initial;
          _this.data = data;
          return _this;
        }
        _Stack_prototype = Stack.prototype;
        Stack.displayName = "Stack";
        _Stack_prototype.push = function (value) {
          return this.data.push(value);
        };
        _Stack_prototype.pop = function () {
          var data, len;
          data = this.data;
          len = data.length;
          if (len === 0) {
            throw Error("Cannot pop");
          }
          return data.pop();
        };
        _Stack_prototype.canPop = function () {
          return __num(this.data.length) > 0;
        };
        _Stack_prototype.peek = function () {
          var data, len;
          data = this.data;
          len = data.length;
          if (len === 0) {
            return this.initial;
          } else {
            return data[__num(len) - 1];
          }
        };
        _Stack_prototype.clone = function () {
          return Stack(this.initial, this.data.slice());
        };
        return Stack;
      }());
      function makeAlterStack(stack, value) {
        if (!(stack instanceof Stack)) {
          throw TypeError("Expected stack to be a Stack, got " + __typeof(stack));
        }
        return function (func) {
          if (typeof func !== "function") {
            throw TypeError("Expected func to be a Function, got " + __typeof(func));
          }
          return named(func.parserName, function (o) {
            stack.push(value);
            try {
              return func(o);
            } finally {
              stack.pop();
            }
          });
        };
      }
      _position = Stack("statement");
      inStatement = makeAlterStack(_position, "statement");
      inExpression = makeAlterStack(_position, "expression");
      _inMacro = Stack(false);
      inMacro = makeAlterStack(_inMacro, true);
      _inAst = Stack(false);
      inAst = makeAlterStack(_inAst, true);
      _preventUnclosedObjectLiteral = Stack(false);
      preventUnclosedObjectLiteral = makeAlterStack(_preventUnclosedObjectLiteral, true);
      _asterixAsArrayLength = Stack(false);
      asterixAsArrayLength = makeAlterStack(_asterixAsArrayLength, true);
      SpaceChar = cache(named("SpaceChar", function (o) {
        var c;
        c = o.data.charCodeAt(o.index);
        if (c < 128 ? c === 9 || c === 11 || c === 12 || c === 32 : c === 160 || c === 5760 || c === 6158 || c >= 8192 && c <= 8202 || c === 8239 || c === 8287 || c === 12288 || c === 65263) {
          o.index = __num(o.index) + 1;
          return c;
        } else {
          o.fail("space");
          return false;
        }
      }));
      _Space = named("_Space", function (o) {
        while (SpaceChar(o));
        return true;
      });
      Newline = cache(named("Newline", function (o) {
        var c, data, index;
        data = o.data;
        index = o.index;
        c = data.charCodeAt(index);
        if (c === 13 || c === 10 || c === 8232 || c === 8233) {
          ++index;
          if (c === 13 && data.charCodeAt(index) === 10) {
            ++index;
          }
          o.index = index;
          ++o.line;
          return true;
        } else {
          o.fail("newline");
          return false;
        }
      }));
      CheckStop = named("CheckStop", (function () {
        var Eof, Stop;
        Eof = named("Eof", function (o) {
          return !__lt(o.index, o.data.length);
        });
        Stop = named("Stop", function (o) {
          return Newline(o) || Eof(o);
        });
        return function (o) {
          return Stop(o.clone());
        };
      }()));
      NewlineWithCheckIndent = cache(named("NewlineWithCheckIndent", function (o) {
        var clone;
        clone = o.clone();
        return Newline(clone) && EmptyLines(clone) && CheckIndent(clone) && (o.update(clone), true);
      }));
      MaybeComment = cache(named("MaybeComment", (function () {
        var MultiLineComment, SingleLineComment;
        SingleLineComment = named("SingleLineComment", function (o) {
          var _ref, data, index, len;
          data = o.data;
          index = o.index;
          if (data.charCodeAt(index) === 47 && data.charCodeAt(+index + 1) === 47) {
            len = data.length;
            index = __num(index) + 2;
            for (; ; ++index) {
              if (index >= len || (_ref = data.charCodeAt(index)) === 13 || _ref === 10) {
                o.index = index;
                return true;
              }
            }
          } else {
            return false;
          }
        });
        MultiLineComment = named("MultiLineComment", function (o) {
          var ch, data, index, len;
          data = o.data;
          index = o.index;
          if (data.charCodeAt(index) === 47 && data.charCodeAt(+index + 1) === 42 && data.charCodeAt(+index + 2) !== 33) {
            len = data.length;
            index = __num(index) + 2;
            for (; ; ++index) {
              if (index >= len) {
                o.error("Multi-line comment never ends");
              } else {
                ch = data.charCodeAt(index);
                if (ch === 42 && data.charCodeAt(+index + 1) === 47) {
                  o.index = +index + 2;
                  Space(o);
                  return true;
                } else if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) {
                  if (ch === 13 && data.charCodeAt(+index + 1) === 10) {
                    ++index;
                  }
                  ++o.line;
                }
              }
            }
          } else {
            return false;
          }
        });
        return (function () {
          function _rule(o) {
            return SingleLineComment(o) || MultiLineComment(o);
          }
          return named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "?", function (o) {
            return _rule(o) || true;
          });
        }());
      }())));
      fromCharCode = (function () {
        var f;
        f = String.fromCharCode;
        return function (x) {
          if (x === -1) {
            return "\u0000";
          } else {
            return f(x);
          }
        };
      }());
      function processCharCodes(codes, array) {
        var _arr, _i, _len, v;
        if (array == null) {
          array = [];
        }
        for (_arr = __toArray(codes), _i = 0, _len = _arr.length; _i < _len; ++_i) {
          v = _arr[_i];
          array.push(fromCharCode(v));
        }
        return array;
      }
      LicenseComment = cache(named("LicenseComment", (function () {
        function _rule(o) {
          var _len, ch, data, i, index, l, len, line, lines, result, startIndex;
          data = o.data;
          index = o.index;
          if (data.charCodeAt(index) === 47 && data.charCodeAt(+index + 1) === 42 && data.charCodeAt(+index + 2) === 33) {
            line = [47, 42, 33];
            lines = [line];
            len = data.length;
            startIndex = index;
            index = __num(index) + 3;
            for (; ; ++index) {
              if (index >= len) {
                o.error("Multi-line license comment never ends");
              } else {
                ch = data.charCodeAt(index);
                if (ch === 42 && data.charCodeAt(+index + 1) === 47) {
                  o.index = +index + 2;
                  line.push(42, 47);
                  result = [];
                  for (i = 0, _len = lines.length; i < _len; ++i) {
                    l = lines[i];
                    if (i > 0) {
                      result.push("\n");
                    }
                    processCharCodes(l, result);
                  }
                  return o.comment(startIndex, result.join(""));
                } else if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) {
                  if (ch === 13 && data.charCodeAt(+index + 1) === 10) {
                    ++index;
                  }
                  ++o.line;
                  lines.push(line = []);
                  o.index = +index + 1;
                  if (!StringIndent(o)) {
                    o.error("Improper indent in multi-line license comment");
                  }
                  index = o.index - 1;
                } else {
                  line.push(ch);
                }
              }
            }
          } else {
            return false;
          }
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return _Space(clone) && (result = _rule(clone)) && Space(clone) && (o.update(clone), result);
        };
      }())));
      Space = cache(named("Space", function (o) {
        var clone;
        clone = o.clone();
        return _Space(clone) && MaybeComment(clone) && (o.update(clone), true);
      }));
      NoSpace = cache(named("NoSpace", function (o) {
        return !SpaceChar(o.clone());
      }));
      EmptyLine = cache(named("EmptyLine", function (o) {
        var clone, result;
        clone = o.clone();
        return Space(clone) && (result = Newline(clone)) && (o.update(clone), result);
      }));
      EmptyLines = cache(named("EmptyLines", function (o) {
        while (EmptyLine(o));
        return true;
      }));
      SomeEmptyLines = cache(named("SomeEmptyLines", function (o) {
        if (!EmptyLine(o)) {
          return false;
        } else {
          while (EmptyLine(o));
          return true;
        }
      }));
      INDENTS = { 9: 4, 32: 1 };
      CountIndent = cache(named("CountIndent", (function () {
        var _rule;
        _rule = named(__strnum(SpaceChar != null && SpaceChar.parserName || "SpaceChar") + "*", function (o) {
          var clone, item, result;
          clone = o.clone();
          result = [];
          while (item = SpaceChar(clone)) {
            result.push(item);
          }
          o.update(clone);
          return result;
        });
        function _mutator(x) {
          var _arr, _i, c, count;
          count = 1;
          for (_arr = __toArray(x), _i = _arr.length; _i--; ) {
            c = _arr[_i];
            if (!__owns.call(INDENTS, c)) {
              throw Error("Unexpected indent char: " + __str(JSON.stringify(c)));
            }
            count += __num(INDENTS[c]);
          }
          return count;
        }
        return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
          var index, line, result;
          index = o.index;
          line = o.line;
          result = _rule(o);
          if (!result) {
            return false;
          } else {
            return _mutator(result, o, index, line);
          }
        });
      }())));
      CheckIndent = cache(named("CheckIndent", function (o) {
        var clone, indent;
        clone = o.clone();
        indent = CountIndent(clone);
        if (indent === clone.indent.peek()) {
          o.update(clone);
          return true;
        } else {
          return false;
        }
      }));
      Advance = named("Advance", function (o) {
        var clone, indent;
        clone = o.clone();
        indent = CountIndent(clone);
        if (!__lte(indent, clone.indent.peek())) {
          o.indent.push(indent);
          return true;
        } else {
          return false;
        }
      });
      MaybeAdvance = named("MaybeAdvance", function (o) {
        var clone, indent;
        clone = o.clone();
        indent = CountIndent(clone);
        o.indent.push(indent);
        return true;
      });
      PushIndent = named("PushIndent", (function () {
        function _mutator(indent, o) {
          o.indent.push(indent);
          return true;
        }
        return named(CountIndent != null && CountIndent.parserName || "CountIndent", function (o) {
          var index, line, result;
          index = o.index;
          line = o.line;
          result = CountIndent(o);
          if (!result) {
            return false;
          } else {
            return _mutator(result, o, index, line);
          }
        });
      }()));
      PushFakeIndent = (function () {
        var cache;
        cache = [];
        return function (n) {
          var _ref;
          if ((_ref = cache[n]) == null) {
            return cache[n] = named("PushFakeIndent(" + __strnum(n) + ")", function (o) {
              o.indent.push(__num(o.indent.peek()) + __num(n));
              return true;
            });
          } else {
            return _ref;
          }
        };
      }());
      PopIndent = named("PopIndent", function (o) {
        if (o.indent.canPop()) {
          o.indent.pop();
          return true;
        } else {
          return o.error("Unexpected dedent");
        }
      });
      Zero = cache(named("Zero", function (o) {
        if (o.data.charCodeAt(o.index) === 48) {
          o.index = __num(o.index) + 1;
          return 48;
        } else {
          o.fail('"0"');
          return false;
        }
      }));
      DecimalDigit = cache(named("DecimalDigit", function (o) {
        var c;
        c = o.data.charCodeAt(o.index);
        if (c >= 48 && c <= 57) {
          o.index = __num(o.index) + 1;
          return c;
        } else {
          o.fail("[0-9]");
          return false;
        }
      }));
      Period = cache(named("Period", function (o) {
        if (o.data.charCodeAt(o.index) === 46) {
          o.index = __num(o.index) + 1;
          return 46;
        } else {
          o.fail('"."');
          return false;
        }
      }));
      ColonChar = cache(named("ColonChar", function (o) {
        if (o.data.charCodeAt(o.index) === 58) {
          o.index = __num(o.index) + 1;
          return 58;
        } else {
          o.fail('":"');
          return false;
        }
      }));
      Pipe = cache(named("Pipe", (function () {
        function _rule(o) {
          if (o.data.charCodeAt(o.index) === 124) {
            o.index = __num(o.index) + 1;
            return 124;
          } else {
            o.fail('"|"');
            return false;
          }
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }())));
      DoubleColon = cache(named("DoubleColon", function (o) {
        var clone;
        clone = o.clone();
        return ColonChar(clone) && ColonChar(clone) && (o.update(clone), "::");
      }));
      Minus = named("Minus", function (o) {
        if (o.data.charCodeAt(o.index) === 45) {
          o.index = __num(o.index) + 1;
          return 45;
        } else {
          o.fail('"-"');
          return false;
        }
      });
      Plus = named("Plus", function (o) {
        if (o.data.charCodeAt(o.index) === 43) {
          o.index = __num(o.index) + 1;
          return 43;
        } else {
          o.fail('"+"');
          return false;
        }
      });
      PlusOrMinus = named("PlusOrMinus", function (o) {
        var c;
        c = o.data.charCodeAt(o.index);
        if (c === 43 || c === 45) {
          o.index = __num(o.index) + 1;
          return c;
        } else {
          o.fail("[+\\-]");
          return false;
        }
      });
      Letter = named("Letter", function (o) {
        var c;
        c = o.data.charCodeAt(o.index);
        if (c < 128 ? c >= 65 && c <= 90 || c >= 97 && c <= 122 : c === 170 || c === 181 || c === 186 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 705 || c >= 710 && c <= 721 || c >= 736 && c <= 740 || c === 748 || c === 750 || c >= 880 && c <= 884 || c === 886 || c === 887 || c >= 890 && c <= 893 || c === 902 || c >= 904 && c <= 906 || c === 908 || c >= 910 && c <= 929 || c >= 931 && c <= 1013 || c >= 1015 && c <= 1153 || c >= 1162 && c <= 1317 || c >= 1329 && c <= 1366 || c === 1369 || c >= 1377 && c <= 1415 || c >= 1488 && c <= 1514 || c >= 1520 && c <= 1522 || c >= 1569 && c <= 1610 || c === 1646 || c === 1647 || c >= 1649 && c <= 1747 || c === 1749 || c === 1765 || c === 1766 || c === 1774 || c === 1775 || c >= 1786 && c <= 1788 || c === 1791 || c === 1808 || c >= 1810 && c <= 1839 || c >= 1869 && c <= 1957 || c === 1969 || c >= 1994 && c <= 2026 || c === 2036 || c === 2037 || c === 2042 || c >= 2048 && c <= 2069 || c === 2074 || c === 2084 || c === 2088 || c >= 2308 && c <= 2361 || c === 2365 || c === 2384 || c >= 2392 && c <= 2401 || c === 2417 || c === 2418 || c >= 2425 && c <= 2431 || c >= 2437 && c <= 2444 || c === 2447 || c === 2448 || c >= 2451 && c <= 2472 || c >= 2474 && c <= 2480 || c === 2482 || c >= 2486 && c <= 2489 || c === 2493 || c === 2510 || c === 2524 || c === 2525 || c >= 2527 && c <= 2529 || c === 2544 || c === 2545 || c >= 2565 && c <= 2570 || c === 2575 || c === 2576 || c >= 2579 && c <= 2600 || c >= 2602 && c <= 2608 || c === 2610 || c === 2611 || c === 2613 || c === 2614 || c === 2616 || c === 2617 || c >= 2649 && c <= 2652 || c === 2654 || c >= 2674 && c <= 2676 || c >= 2693 && c <= 2701 || c >= 2703 && c <= 2705 || c >= 2707 && c <= 2728 || c >= 2730 && c <= 2736 || c === 2738 || c === 2739 || c >= 2741 && c <= 2745 || c === 2749 || c === 2768 || c === 2784 || c === 2785 || c >= 2821 && c <= 2828 || c === 2831 || c === 2832 || c >= 2835 && c <= 2856 || c >= 2858 && c <= 2864 || c === 2866 || c === 2867 || c >= 2869 && c <= 2873 || c === 2877 || c === 2908 || c === 2909 || c >= 2911 && c <= 2913 || c === 2929 || c === 2947 || c >= 2949 && c <= 2954 || c >= 2958 && c <= 2960 || c >= 2962 && c <= 2965 || c === 2969 || c === 2970 || c === 2972 || c === 2974 || c === 2975 || c === 2979 || c === 2980 || c >= 2984 && c <= 2986 || c >= 2990 && c <= 3001 || c === 3024 || c >= 3077 && c <= 3084 || c >= 3086 && c <= 3088 || c >= 3090 && c <= 3112 || c >= 3114 && c <= 3123 || c >= 3125 && c <= 3129 || c === 3133 || c === 3160 || c === 3161 || c === 3168 || c === 3169 || c >= 3205 && c <= 3212 || c >= 3214 && c <= 3216 || c >= 3218 && c <= 3240 || c >= 3242 && c <= 3251 || c >= 3253 && c <= 3257 || c === 3261 || c === 3294 || c === 3296 || c === 3297 || c >= 3333 && c <= 3340 || c >= 3342 && c <= 3344 || c >= 3346 && c <= 3368 || c >= 3370 && c <= 3385 || c === 3389 || c === 3424 || c === 3425 || c >= 3450 && c <= 3455 || c >= 3461 && c <= 3478 || c >= 3482 && c <= 3505 || c >= 3507 && c <= 3515 || c === 3517 || c >= 3520 && c <= 3526 || c >= 3585 && c <= 3632 || c === 3634 || c === 3635 || c >= 3648 && c <= 3654 || c === 3713 || c === 3714 || c === 3716 || c === 3719 || c === 3720 || c === 3722 || c === 3725 || c >= 3732 && c <= 3735 || c >= 3737 && c <= 3743 || c >= 3745 && c <= 3747 || c === 3749 || c === 3751 || c === 3754 || c === 3755 || c >= 3757 && c <= 3760 || c === 3762 || c === 3763 || c === 3773 || c >= 3776 && c <= 3780 || c === 3782 || c === 3804 || c === 3805 || c === 3840 || c >= 3904 && c <= 3911 || c >= 3913 && c <= 3948 || c >= 3976 && c <= 3979 || c >= 4096 && c <= 4138 || c === 4159 || c >= 4176 && c <= 4181 || c >= 4186 && c <= 4189 || c === 4193 || c === 4197 || c === 4198 || c >= 4206 && c <= 4208 || c >= 4213 && c <= 4225 || c === 4238 || c >= 4256 && c <= 4293 || c >= 4304 && c <= 4346 || c === 4348 || c >= 4352 && c <= 4680 || c >= 4682 && c <= 4685 || c >= 4688 && c <= 4694 || c === 4696 || c >= 4698 && c <= 4701 || c >= 4704 && c <= 4744 || c >= 4746 && c <= 4749 || c >= 4752 && c <= 4784 || c >= 4786 && c <= 4789 || c >= 4792 && c <= 4798 || c === 4800 || c >= 4802 && c <= 4805 || c >= 4808 && c <= 4822 || c >= 4824 && c <= 4880 || c >= 4882 && c <= 4885 || c >= 4888 && c <= 4954 || c >= 4992 && c <= 5007 || c >= 5024 && c <= 5108 || c >= 5121 && c <= 5740 || c >= 5743 && c <= 5759 || c >= 5761 && c <= 5786 || c >= 5792 && c <= 5866 || c >= 5888 && c <= 5900 || c >= 5902 && c <= 5905 || c >= 5920 && c <= 5937 || c >= 5952 && c <= 5969 || c >= 5984 && c <= 5996 || c >= 5998 && c <= 6000 || c >= 6016 && c <= 6067 || c === 6103 || c === 6108 || c >= 6176 && c <= 6263 || c >= 6272 && c <= 6312 || c === 6314 || c >= 6320 && c <= 6389 || c >= 6400 && c <= 6428 || c >= 6480 && c <= 6509 || c >= 6512 && c <= 6516 || c >= 6528 && c <= 6571 || c >= 6593 && c <= 6599 || c >= 6656 && c <= 6678 || c >= 6688 && c <= 6740 || c === 6823 || c >= 6917 && c <= 6963 || c >= 6981 && c <= 6987 || c >= 7043 && c <= 7072 || c === 7086 || c === 7087 || c >= 7168 && c <= 7203 || c >= 7245 && c <= 7247 || c >= 7258 && c <= 7293 || c >= 7401 && c <= 7404 || c >= 7406 && c <= 7409 || c >= 7424 && c <= 7615 || c >= 7680 && c <= 7957 || c >= 7960 && c <= 7965 || c >= 7968 && c <= 8005 || c >= 8008 && c <= 8013 || c >= 8016 && c <= 8023 || c === 8025 || c === 8027 || c === 8029 || c >= 8031 && c <= 8061 || c >= 8064 && c <= 8116 || c >= 8118 && c <= 8124 || c === 8126 || c >= 8130 && c <= 8132 || c >= 8134 && c <= 8140 || c >= 8144 && c <= 8147 || c >= 8150 && c <= 8155 || c >= 8160 && c <= 8172 || c >= 8178 && c <= 8180 || c >= 8182 && c <= 8188 || c === 8305 || c === 8319 || c >= 8336 && c <= 8340 || c === 8450 || c === 8455 || c >= 8458 && c <= 8467 || c === 8469 || c >= 8473 && c <= 8477 || c === 8484 || c === 8486 || c === 8488 || c >= 8490 && c <= 8493 || c >= 8495 && c <= 8505 || c >= 8508 && c <= 8511 || c >= 8517 && c <= 8521 || c === 8526 || c === 8579 || c === 8580 || c >= 11264 && c <= 11310 || c >= 11312 && c <= 11358 || c >= 11360 && c <= 11492 || c >= 11499 && c <= 11502 || c >= 11520 && c <= 11557 || c >= 11568 && c <= 11621 || c === 11631 || c >= 11648 && c <= 11670 || c >= 11680 && c <= 11686 || c >= 11688 && c <= 11694 || c >= 11696 && c <= 11702 || c >= 11704 && c <= 11710 || c >= 11712 && c <= 11718 || c >= 11720 && c <= 11726 || c >= 11728 && c <= 11734 || c >= 11736 && c <= 11742 || c === 11823 || c === 12293 || c === 12294 || c >= 12337 && c <= 12341 || c === 12347 || c === 12348 || c >= 12353 && c <= 12438 || c >= 12445 && c <= 12447 || c >= 12449 && c <= 12538 || c >= 12540 && c <= 12543 || c >= 12549 && c <= 12589 || c >= 12593 && c <= 12686 || c >= 12704 && c <= 12727 || c >= 12784 && c <= 12799 || c >= 13312 && c <= 19893 || c >= 19968 && c <= 40907 || c >= 40960 && c <= 42124 || c >= 42192 && c <= 42237 || c >= 42240 && c <= 42508 || c >= 42512 && c <= 42527 || c === 42538 || c === 42539 || c >= 42560 && c <= 42591 || c >= 42594 && c <= 42606 || c >= 42623 && c <= 42647 || c >= 42656 && c <= 42725 || c >= 42775 && c <= 42783 || c >= 42786 && c <= 42888 || c === 42891 || c === 42892 || c >= 43003 && c <= 43009 || c >= 43011 && c <= 43013 || c >= 43015 && c <= 43018 || c >= 43020 && c <= 43042 || c >= 43072 && c <= 43123 || c >= 43138 && c <= 43187 || c >= 43250 && c <= 43255 || c === 43259 || c >= 43274 && c <= 43301 || c >= 43312 && c <= 43334 || c >= 43360 && c <= 43388 || c >= 43396 && c <= 43442 || c === 43471 || c >= 43520 && c <= 43560 || c >= 43584 && c <= 43586 || c >= 43588 && c <= 43595 || c >= 43616 && c <= 43638 || c === 43642 || c >= 43648 && c <= 43695 || c === 43697 || c === 43701 || c === 43702 || c >= 43705 && c <= 43709 || c === 43712 || c === 43714 || c >= 43739 && c <= 43741 || c >= 43968 && c <= 44002 || c >= 44032 && c <= 55203 || c >= 55216 && c <= 55238 || c >= 55243 && c <= 55291 || c >= 63744 && c <= 64045 || c >= 64048 && c <= 64109 || c >= 64112 && c <= 64217 || c >= 64256 && c <= 64262 || c >= 64275 && c <= 64279 || c === 64285 || c >= 64287 && c <= 64296 || c >= 64298 && c <= 64310 || c >= 64312 && c <= 64316 || c === 64318 || c === 64320 || c === 64321 || c === 64323 || c === 64324 || c >= 64326 && c <= 64433 || c >= 64467 && c <= 64829 || c >= 64848 && c <= 64911 || c >= 64914 && c <= 64967 || c >= 65008 && c <= 65019 || c >= 65136 && c <= 65140 || c >= 65142 && c <= 65262 || c >= 65264 && c <= 65276 || c >= 65313 && c <= 65338 || c >= 65345 && c <= 65370 || c >= 65382 && c <= 65470 || c >= 65474 && c <= 65479 || c >= 65482 && c <= 65487 || c >= 65490 && c <= 65495 || c >= 65498 && c <= 65500) {
          o.index = __num(o.index) + 1;
          return c;
        } else {
          o.fail("letter");
          return false;
        }
      });
      NumberChar = named("NumberChar", function (o) {
        var c;
        c = o.data.charCodeAt(o.index);
        if (c < 128 ? c >= 48 && c <= 57 : c === 178 || c === 179 || c === 185 || c >= 188 && c <= 190 || c >= 1632 && c <= 1641 || c >= 1776 && c <= 1785 || c >= 1984 && c <= 1993 || c >= 2406 && c <= 2415 || c >= 2534 && c <= 2543 || c >= 2548 && c <= 2553 || c >= 2662 && c <= 2671 || c >= 2790 && c <= 2799 || c >= 2918 && c <= 2927 || c >= 3046 && c <= 3058 || c >= 3174 && c <= 3183 || c >= 3192 && c <= 3198 || c >= 3302 && c <= 3311 || c >= 3430 && c <= 3445 || c >= 3664 && c <= 3673 || c >= 3792 && c <= 3801 || c >= 3872 && c <= 3891 || c >= 4160 && c <= 4169 || c >= 4240 && c <= 4249 || c >= 4969 && c <= 4988 || c >= 5870 && c <= 5872 || c >= 6112 && c <= 6121 || c >= 6128 && c <= 6137 || c >= 6160 && c <= 6169 || c >= 6470 && c <= 6479 || c >= 6608 && c <= 6618 || c >= 6784 && c <= 6793 || c >= 6800 && c <= 6809 || c >= 6992 && c <= 7001 || c >= 7088 && c <= 7097 || c >= 7232 && c <= 7241 || c >= 7248 && c <= 7257 || c === 8304 || c >= 8308 && c <= 8313 || c >= 8320 && c <= 8329 || c >= 8528 && c <= 8578 || c >= 8581 && c <= 8585 || c >= 9312 && c <= 9371 || c >= 9450 && c <= 9471 || c >= 10102 && c <= 10131 || c === 11517 || c === 12295 || c >= 12321 && c <= 12329 || c >= 12344 && c <= 12346 || c >= 12690 && c <= 12693 || c >= 12832 && c <= 12841 || c >= 12881 && c <= 12895 || c >= 12928 && c <= 12937 || c >= 12977 && c <= 12991 || c >= 42528 && c <= 42537 || c >= 42726 && c <= 42735 || c >= 43056 && c <= 43061 || c >= 43216 && c <= 43225 || c >= 43264 && c <= 43273 || c >= 43472 && c <= 43481 || c >= 43600 && c <= 43609 || c >= 44016 && c <= 44025 || c >= 65296 && c <= 65305) {
          o.index = __num(o.index) + 1;
          return c;
        } else {
          o.fail("number");
          return false;
        }
      });
      Underscore = cache(named("Underscore", function (o) {
        if (o.data.charCodeAt(o.index) === 95) {
          o.index = __num(o.index) + 1;
          return 95;
        } else {
          o.fail('"_"');
          return false;
        }
      }));
      DollarSign = cache(named("DollarSign", function (o) {
        if (o.data.charCodeAt(o.index) === 36) {
          o.index = __num(o.index) + 1;
          return 36;
        } else {
          o.fail('"$"');
          return false;
        }
      }));
      AtSign = cache(named("AtSign", function (o) {
        if (o.data.charCodeAt(o.index) === 64) {
          o.index = __num(o.index) + 1;
          return 64;
        } else {
          o.fail('"@"');
          return false;
        }
      }));
      HashSign = cache(named("HashSign", (function () {
        function _rule(o) {
          if (o.data.charCodeAt(o.index) === 35) {
            o.index = __num(o.index) + 1;
            return 35;
          } else {
            o.fail('"#"');
            return false;
          }
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }())));
      PercentSign = cache(named("PercentSign", function (o) {
        if (o.data.charCodeAt(o.index) === 37) {
          o.index = __num(o.index) + 1;
          return 37;
        } else {
          o.fail('"%"');
          return false;
        }
      }));
      SymbolChar = cache(named("SymbolChar", function (o) {
        var c;
        c = o.data.charCodeAt(o.index);
        if (c < 128 ? c === 33 || c === 35 || c === 37 || c === 38 || c === 42 || c === 43 || c === 45 || c === 47 || c >= 60 && c <= 63 || c === 92 || c === 94 || c === 96 || c === 124 || c === 126 || c === 127 : c >= 128 && c <= 159 || c >= 161 && c <= 169 || c >= 171 && c <= 177 || c === 180 || c >= 182 && c <= 184 || c === 187 || c === 191 || c === 215 || c === 247 || c >= 706 && c <= 709 || c >= 722 && c <= 735 || c >= 741 && c <= 747 || c === 749 || c >= 751 && c <= 879 || c === 885 || c === 888 || c === 889 || c >= 894 && c <= 901 || c === 903 || c === 907 || c === 909 || c === 930 || c === 1014 || c >= 1154 && c <= 1161 || c >= 1318 && c <= 1328 || c === 1367 || c === 1368 || c >= 1370 && c <= 1376 || c >= 1416 && c <= 1487 || c >= 1515 && c <= 1519 || c >= 1523 && c <= 1568 || c >= 1611 && c <= 1631 || c >= 1642 && c <= 1645 || c === 1648 || c === 1748 || c >= 1750 && c <= 1764 || c >= 1767 && c <= 1773 || c === 1789 || c === 1790 || c >= 1792 && c <= 1807 || c === 1809 || c >= 1840 && c <= 1868 || c >= 1958 && c <= 1968 || c >= 1970 && c <= 1983 || c >= 2027 && c <= 2035 || c >= 2038 && c <= 2041 || c >= 2043 && c <= 2047 || c >= 2070 && c <= 2073 || c >= 2075 && c <= 2083 || c >= 2085 && c <= 2087 || c >= 2089 && c <= 2307 || c >= 2362 && c <= 2364 || c >= 2366 && c <= 2383 || c >= 2385 && c <= 2391 || c >= 2402 && c <= 2405 || c === 2416 || c >= 2419 && c <= 2424 || c >= 2432 && c <= 2436 || c === 2445 || c === 2446 || c === 2449 || c === 2450 || c === 2473 || c === 2481 || c >= 2483 && c <= 2485 || c >= 2490 && c <= 2492 || c >= 2494 && c <= 2509 || c >= 2511 && c <= 2523 || c === 2526 || c >= 2530 && c <= 2533 || c === 2546 || c === 2547 || c >= 2554 && c <= 2564 || c >= 2571 && c <= 2574 || c === 2577 || c === 2578 || c === 2601 || c === 2609 || c === 2612 || c === 2615 || c >= 2618 && c <= 2648 || c === 2653 || c >= 2655 && c <= 2661 || c === 2672 || c === 2673 || c >= 2677 && c <= 2692 || c === 2702 || c === 2706 || c === 2729 || c === 2737 || c === 2740 || c >= 2746 && c <= 2748 || c >= 2750 && c <= 2767 || c >= 2769 && c <= 2783 || c >= 2786 && c <= 2789 || c >= 2800 && c <= 2820 || c === 2829 || c === 2830 || c === 2833 || c === 2834 || c === 2857 || c === 2865 || c === 2868 || c >= 2874 && c <= 2876 || c >= 2878 && c <= 2907 || c === 2910 || c >= 2914 && c <= 2917 || c === 2928 || c >= 2930 && c <= 2946 || c === 2948 || c >= 2955 && c <= 2957 || c === 2961 || c >= 2966 && c <= 2968 || c === 2971 || c === 2973 || c >= 2976 && c <= 2978 || c >= 2981 && c <= 2983 || c >= 2987 && c <= 2989 || c >= 3002 && c <= 3023 || c >= 3025 && c <= 3045 || c >= 3059 && c <= 3076 || c === 3085 || c === 3089 || c === 3113 || c === 3124 || c >= 3130 && c <= 3132 || c >= 3134 && c <= 3159 || c >= 3162 && c <= 3167 || c >= 3170 && c <= 3173 || c >= 3184 && c <= 3191 || c >= 3199 && c <= 3204 || c === 3213 || c === 3217 || c === 3241 || c === 3252 || c >= 3258 && c <= 3260 || c >= 3262 && c <= 3293 || c === 3295 || c >= 3298 && c <= 3301 || c >= 3312 && c <= 3332 || c === 3341 || c === 3345 || c === 3369 || c >= 3386 && c <= 3388 || c >= 3390 && c <= 3423 || c >= 3426 && c <= 3429 || c >= 3446 && c <= 3449 || c >= 3456 && c <= 3460 || c >= 3479 && c <= 3481 || c === 3506 || c === 3516 || c === 3518 || c === 3519 || c >= 3527 && c <= 3584 || c === 3633 || c >= 3636 && c <= 3647 || c >= 3655 && c <= 3663 || c >= 3674 && c <= 3712 || c === 3715 || c === 3717 || c === 3718 || c === 3721 || c === 3723 || c === 3724 || c >= 3726 && c <= 3731 || c === 3736 || c === 3744 || c === 3748 || c === 3750 || c === 3752 || c === 3753 || c === 3756 || c === 3761 || c >= 3764 && c <= 3772 || c === 3774 || c === 3775 || c === 3781 || c >= 3783 && c <= 3791 || c === 3802 || c === 3803 || c >= 3806 && c <= 3839 || c >= 3841 && c <= 3871 || c >= 3892 && c <= 3903 || c === 3912 || c >= 3949 && c <= 3975 || c >= 3980 && c <= 4095 || c >= 4139 && c <= 4158 || c >= 4170 && c <= 4175 || c >= 4182 && c <= 4185 || c >= 4190 && c <= 4192 || c >= 4194 && c <= 4196 || c >= 4199 && c <= 4205 || c >= 4209 && c <= 4212 || c >= 4226 && c <= 4237 || c === 4239 || c >= 4250 && c <= 4255 || c >= 4294 && c <= 4303 || c === 4347 || c >= 4349 && c <= 4351 || c === 4681 || c === 4686 || c === 4687 || c === 4695 || c === 4697 || c === 4702 || c === 4703 || c === 4745 || c === 4750 || c === 4751 || c === 4785 || c === 4790 || c === 4791 || c === 4799 || c === 4801 || c === 4806 || c === 4807 || c === 4823 || c === 4881 || c === 4886 || c === 4887 || c >= 4955 && c <= 4968 || c >= 4989 && c <= 4991 || c >= 5008 && c <= 5023 || c >= 5109 && c <= 5120 || c === 5741 || c === 5742 || c >= 5787 && c <= 5791 || c >= 5867 && c <= 5869 || c >= 5873 && c <= 5887 || c === 5901 || c >= 5906 && c <= 5919 || c >= 5938 && c <= 5951 || c >= 5970 && c <= 5983 || c === 5997 || c >= 6001 && c <= 6015 || c >= 6068 && c <= 6102 || c >= 6104 && c <= 6107 || c >= 6109 && c <= 6111 || c >= 6122 && c <= 6127 || c >= 6138 && c <= 6157 || c === 6159 || c >= 6170 && c <= 6175 || c >= 6264 && c <= 6271 || c === 6313 || c >= 6315 && c <= 6319 || c >= 6390 && c <= 6399 || c >= 6429 && c <= 6469 || c === 6510 || c === 6511 || c >= 6517 && c <= 6527 || c >= 6572 && c <= 6592 || c >= 6600 && c <= 6607 || c >= 6619 && c <= 6655 || c >= 6679 && c <= 6687 || c >= 6741 && c <= 6783 || c >= 6794 && c <= 6799 || c >= 6810 && c <= 6822 || c >= 6824 && c <= 6916 || c >= 6964 && c <= 6980 || c >= 6988 && c <= 6991 || c >= 7002 && c <= 7042 || c >= 7073 && c <= 7085 || c >= 7098 && c <= 7167 || c >= 7204 && c <= 7231 || c >= 7242 && c <= 7244 || c >= 7294 && c <= 7400 || c === 7405 || c >= 7410 && c <= 7423 || c >= 7616 && c <= 7679 || c === 7958 || c === 7959 || c === 7966 || c === 7967 || c === 8006 || c === 8007 || c === 8014 || c === 8015 || c === 8024 || c === 8026 || c === 8028 || c === 8030 || c === 8062 || c === 8063 || c === 8117 || c === 8125 || c >= 8127 && c <= 8129 || c === 8133 || c >= 8141 && c <= 8143 || c === 8148 || c === 8149 || c >= 8156 && c <= 8159 || c >= 8173 && c <= 8177 || c === 8181 || c >= 8189 && c <= 8191 || c >= 8203 && c <= 8231 || c >= 8234 && c <= 8238 || c >= 8240 && c <= 8286 || c >= 8288 && c <= 8303 || c === 8306 || c === 8307 || c >= 8314 && c <= 8318 || c >= 8330 && c <= 8335 || c >= 8341 && c <= 8449 || c >= 8451 && c <= 8454 || c === 8456 || c === 8457 || c === 8468 || c >= 8470 && c <= 8472 || c >= 8478 && c <= 8483 || c === 8485 || c === 8487 || c === 8489 || c === 8494 || c === 8506 || c === 8507 || c >= 8512 && c <= 8516 || c >= 8522 && c <= 8525 || c === 8527 || c >= 8586 && c <= 9311 || c >= 9372 && c <= 9449 || c >= 9472 && c <= 10101 || c >= 10132 && c <= 11263 || c === 11311 || c === 11359 || c >= 11493 && c <= 11498 || c >= 11503 && c <= 11516 || c === 11518 || c === 11519 || c >= 11558 && c <= 11567 || c >= 11622 && c <= 11630 || c >= 11632 && c <= 11647 || c >= 11671 && c <= 11679 || c === 11687 || c === 11695 || c === 11703 || c === 11711 || c === 11719 || c === 11727 || c === 11735 || c >= 11743 && c <= 11822 || c >= 11824 && c <= 12287 || c >= 12289 && c <= 12292 || c >= 12296 && c <= 12320 || c >= 12330 && c <= 12336 || c === 12342 || c === 12343 || c >= 12349 && c <= 12352 || c >= 12439 && c <= 12444 || c === 12448 || c === 12539 || c >= 12544 && c <= 12548 || c >= 12590 && c <= 12592 || c >= 12687 && c <= 12689 || c >= 12694 && c <= 12703 || c >= 12728 && c <= 12783 || c >= 12800 && c <= 12831 || c >= 12842 && c <= 12880 || c >= 12896 && c <= 12927 || c >= 12938 && c <= 12976 || c >= 12992 && c <= 13311 || c >= 19894 && c <= 19967 || c >= 40908 && c <= 40959 || c >= 42125 && c <= 42191 || c === 42238 || c === 42239 || c >= 42509 && c <= 42511 || c >= 42540 && c <= 42559 || c === 42592 || c === 42593 || c >= 42607 && c <= 42622 || c >= 42648 && c <= 42655 || c >= 42736 && c <= 42774 || c === 42784 || c === 42785 || c === 42889 || c === 42890 || c >= 42893 && c <= 43002 || c === 43010 || c === 43014 || c === 43019 || c >= 43043 && c <= 43055 || c >= 43062 && c <= 43071 || c >= 43124 && c <= 43137 || c >= 43188 && c <= 43215 || c >= 43226 && c <= 43249 || c >= 43256 && c <= 43258 || c >= 43260 && c <= 43263 || c >= 43302 && c <= 43311 || c >= 43335 && c <= 43359 || c >= 43389 && c <= 43395 || c >= 43443 && c <= 43470 || c >= 43482 && c <= 43519 || c >= 43561 && c <= 43583 || c === 43587 || c >= 43596 && c <= 43599 || c >= 43610 && c <= 43615 || c >= 43639 && c <= 43641 || c >= 43643 && c <= 43647 || c === 43696 || c >= 43698 && c <= 43700 || c === 43703 || c === 43704 || c === 43710 || c === 43711 || c === 43713 || c >= 43715 && c <= 43738 || c >= 43742 && c <= 43967 || c >= 44003 && c <= 44015 || c >= 44026 && c <= 44031 || c >= 55204 && c <= 55215 || c >= 55239 && c <= 55242 || c >= 55292 && c <= 63743 || c === 64046 || c === 64047 || c === 64110 || c === 64111 || c >= 64218 && c <= 64255 || c >= 64263 && c <= 64274 || c >= 64280 && c <= 64284 || c === 64286 || c === 64297 || c === 64311 || c === 64317 || c === 64319 || c === 64322 || c === 64325 || c >= 64434 && c <= 64466 || c >= 64830 && c <= 64847 || c === 64912 || c === 64913 || c >= 64968 && c <= 65007 || c >= 65020 && c <= 65135 || c === 65141 || c >= 65277 && c <= 65295 || c >= 65306 && c <= 65312 || c >= 65339 && c <= 65344 || c >= 65371 && c <= 65381 || c >= 65471 && c <= 65473 || c === 65480 || c === 65481 || c === 65488 || c === 65489 || c === 65496 || c === 65497 || c >= 65501 && c <= 65535) {
          o.index = __num(o.index) + 1;
          return c;
        } else {
          o.fail("symbolic");
          return false;
        }
      }));
      DoubleQuote = cache(named("DoubleQuote", function (o) {
        if (o.data.charCodeAt(o.index) === 34) {
          o.index = __num(o.index) + 1;
          return 34;
        } else {
          o.fail("'\"'");
          return false;
        }
      }));
      SingleQuote = cache(named("SingleQuote", function (o) {
        if (o.data.charCodeAt(o.index) === 39) {
          o.index = __num(o.index) + 1;
          return 39;
        } else {
          o.fail("\"'\"");
          return false;
        }
      }));
      TripleDoubleQuote = cache(named("TripleDoubleQuote", function (o) {
        var clone;
        clone = o.clone();
        return DoubleQuote(clone) && DoubleQuote(clone) && DoubleQuote(clone) && (o.update(clone), '"""');
      }));
      TripleSingleQuote = cache(named("TripleSingleQuote", function (o) {
        var clone;
        clone = o.clone();
        return SingleQuote(clone) && SingleQuote(clone) && SingleQuote(clone) && (o.update(clone), "'''");
      }));
      Semicolon = cache(named("Semicolon", (function () {
        function _rule(o) {
          if (o.data.charCodeAt(o.index) === 59) {
            o.index = __num(o.index) + 1;
            return 59;
          } else {
            o.fail('";"');
            return false;
          }
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }())));
      Asterix = named("Asterix", function (o) {
        if (o.data.charCodeAt(o.index) === 42) {
          o.index = __num(o.index) + 1;
          return 42;
        } else {
          o.fail('"*"');
          return false;
        }
      });
      OpenParenthesis = cache(named("OpenParenthesis", (function () {
        function _rule(o) {
          if (o.data.charCodeAt(o.index) === 40) {
            o.index = __num(o.index) + 1;
            return 40;
          } else {
            o.fail('"("');
            return false;
          }
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }())));
      CloseParenthesis = cache(named("CloseParenthesis", (function () {
        function _rule(o) {
          if (o.data.charCodeAt(o.index) === 41) {
            o.index = __num(o.index) + 1;
            return 41;
          } else {
            o.fail('")"');
            return false;
          }
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }())));
      OpenSquareBracketChar = cache(named("OpenSquareBracketChar", function (o) {
        if (o.data.charCodeAt(o.index) === 91) {
          o.index = __num(o.index) + 1;
          return 91;
        } else {
          o.fail('"["');
          return false;
        }
      }));
      OpenSquareBracket = cache(named("OpenSquareBracket", function (o) {
        var clone, result;
        clone = o.clone();
        return Space(clone) && (result = OpenSquareBracketChar(clone)) && (o.update(clone), result);
      }));
      CloseSquareBracket = cache(named("CloseSquareBracket", (function () {
        function _rule(o) {
          if (o.data.charCodeAt(o.index) === 93) {
            o.index = __num(o.index) + 1;
            return 93;
          } else {
            o.fail('"]"');
            return false;
          }
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }())));
      OpenCurlyBrace = cache(named("OpenCurlyBrace", (function () {
        function _rule(o) {
          if (o.data.charCodeAt(o.index) === 123) {
            o.index = __num(o.index) + 1;
            return 123;
          } else {
            o.fail('"{"');
            return false;
          }
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }())));
      CloseCurlyBrace = cache(named("CloseCurlyBrace", (function () {
        function _rule(o) {
          if (o.data.charCodeAt(o.index) === 125) {
            o.index = __num(o.index) + 1;
            return 125;
          } else {
            o.fail('"}"');
            return false;
          }
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }())));
      Backslash = cache(named("Backslash", function (o) {
        if (o.data.charCodeAt(o.index) === 92) {
          o.index = __num(o.index) + 1;
          return 92;
        } else {
          o.fail('"\\\\"');
          return false;
        }
      }));
      Comma = cache(named("Comma", (function () {
        function _rule(o) {
          if (o.data.charCodeAt(o.index) === 44) {
            o.index = __num(o.index) + 1;
            return 44;
          } else {
            o.fail('","');
            return false;
          }
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }())));
      MaybeComma = cache(named("MaybeComma", function (o) {
        return Comma(o) || true;
      }));
      CommaOrNewline = cache(named("CommaOrNewline", (function () {
        function _rule(o) {
          var clone, result;
          clone = o.clone();
          return (result = Comma(clone)) && EmptyLines(clone) && (o.update(clone), result);
        }
        return function (o) {
          return _rule(o) || SomeEmptyLines(o);
        };
      }())));
      SomeEmptyLinesWithCheckIndent = named("SomeEmptyLinesWithCheckIndent", function (o) {
        var clone;
        clone = o.clone();
        return SomeEmptyLines(clone) && CheckIndent(clone) && (o.update(clone), true);
      });
      CommaOrNewlineWithCheckIndent = named("CommaOrNewlineWithCheckIndent", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = named(__strnum(SomeEmptyLinesWithCheckIndent != null && SomeEmptyLinesWithCheckIndent.parserName || "SomeEmptyLinesWithCheckIndent") + "?", function (o) {
            return SomeEmptyLinesWithCheckIndent(o) || true;
          });
          return function (o) {
            var clone;
            clone = o.clone();
            return Comma(clone) && _rule2(clone) && (o.update(clone), true);
          };
        }());
        return function (o) {
          return _rule(o) || SomeEmptyLinesWithCheckIndent(o);
        };
      }()));
      MaybeCommaOrNewline = named("MaybeCommaOrNewline", function (o) {
        return CommaOrNewline(o) || true;
      });
      NameStart = named("NameStart", function (o) {
        return Letter(o) || Underscore(o) || DollarSign(o);
      });
      NameChar = named("NameChar", function (o) {
        return NameStart(o) || NumberChar(o);
      });
      NamePart = named("NamePart", function (o) {
        var clone, item, result;
        clone = o.clone();
        result = [];
        while (item = NameChar(clone)) {
          result.push(item);
        }
        if (result.length < 1) {
          return false;
        } else {
          o.update(clone);
          return result;
        }
      });
      _Name = cache(named("_Name", (function () {
        return (function () {
          var _rule, _rule2;
          _rule = (function () {
            var _rule3;
            _rule3 = named(__strnum(NameChar != null && NameChar.parserName || "NameChar") + "*", function (o) {
              var clone, item, result;
              clone = o.clone();
              result = [];
              while (item = NameChar(clone)) {
                result.push(item);
              }
              o.update(clone);
              return result;
            });
            return function (o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.head = NameStart(clone)) && (result.tail = _rule3(clone)) && (o.update(clone), result);
            };
          }());
          _rule2 = (function () {
            function _rule3(o) {
              var clone, result;
              clone = o.clone();
              return Minus(clone) && (result = NamePart(clone)) && (o.update(clone), result);
            }
            return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "*", function (o) {
              var clone, item, result;
              clone = o.clone();
              result = [];
              while (item = _rule3(clone)) {
                result.push(item);
              }
              o.update(clone);
              return result;
            });
          }());
          return (function () {
            function _rule3(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.head = _rule(clone)) && (result.tail = _rule2(clone)) && (o.update(clone), result);
            }
            function _mutator(x) {
              var _arr, _i, _len, part, parts;
              parts = [fromCharCode(x.head.head)];
              processCharCodes(x.head.tail, parts);
              for (_arr = __toArray(x.tail), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                part = _arr[_i];
                parts.push(fromCharCode(part[0]).toUpperCase());
                processCharCodes(
                  __slice.call(part, 1),
                  parts
                );
              }
              return parts.join("");
            }
            return named(_rule3 != null && _rule3.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule3(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
      }())));
      Name = cache(named("Name", (function () {
        function _rule(o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _Name(clone)) && (o.update(clone), result);
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          clone.preventFail();
          result = _rule(clone);
          clone.unpreventFail();
          if (result) {
            o.update(clone);
            return result;
          } else {
            o.fail("name");
            return false;
          }
        };
      }())));
      _Symbol = cache(named("_Symbol", (function () {
        var _rule;
        _rule = named(__strnum(SymbolChar != null && SymbolChar.parserName || "SymbolChar") + "+", function (o) {
          var clone, item, result;
          clone = o.clone();
          result = [];
          while (item = SymbolChar(clone)) {
            result.push(item);
          }
          if (result.length < 1) {
            return false;
          } else {
            o.update(clone);
            return result;
          }
        });
        function _mutator(x) {
          return processCharCodes(x).join("");
        }
        return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
          var index, line, result;
          index = o.index;
          line = o.line;
          result = _rule(o);
          if (!result) {
            return false;
          } else {
            return _mutator(result, o, index, line);
          }
        });
      }())));
      Symbol = cache(named("Symbol", (function () {
        function _rule(o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _Symbol(clone)) && (o.update(clone), result);
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          clone.preventFail();
          result = _rule(clone);
          clone.unpreventFail();
          if (result) {
            o.update(clone);
            return result;
          } else {
            o.fail("symbol");
            return false;
          }
        };
      }())));
      _NameOrSymbol = (function () {
        function _rule(o) {
          return _Name(o) || _Symbol(o);
        }
        return (function () {
          var _rule2;
          _rule2 = named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "+", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = _rule(clone)) {
              result.push(item);
            }
            if (result.length < 1) {
              return false;
            } else {
              o.update(clone);
              return result;
            }
          });
          function _mutator(x) {
            return x.join("");
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }());
      function NameOrSymbol(o) {
        var clone, result;
        clone = o.clone();
        return Space(clone) && (result = _NameOrSymbol(clone)) && (o.update(clone), result);
      }
      AnyChar = named("AnyChar", function (o) {
        var data, index;
        data = o.data;
        index = o.index;
        if (!__lt(index, data.length)) {
          o.fail("any");
          return false;
        } else {
          ++o.index;
          return o.data.charCodeAt(index);
        }
      });
      ThisLiteral = cache(named("ThisLiteral", word("this", function (x, o, i) {
        return o["this"](i);
      })));
      ThisShorthandLiteral = cache(named("ThisShorthandLiteral", (function () {
        function _rule(o) {
          var clone;
          clone = o.clone();
          return Space(clone) && AtSign(clone) && (o.update(clone), true);
        }
        function _mutator(x, o, i) {
          return o["this"](i);
        }
        return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
          var index, line, result;
          index = o.index;
          line = o.line;
          result = _rule(o);
          if (!result) {
            return false;
          } else {
            return _mutator(result, o, index, line);
          }
        });
      }())));
      ThisOrShorthandLiteral = cache(named("ThisOrShorthandLiteral", function (o) {
        return ThisLiteral(o) || ThisShorthandLiteral(o);
      }));
      ThisOrShorthandLiteralPeriod = named("ThisOrShorthandLiteralPeriod", (function () {
        var _rule2;
        function _rule(o) {
          var clone, result;
          clone = o.clone();
          return (result = ThisLiteral(clone)) && Period(clone) && (o.update(clone), result);
        }
        _rule2 = (function () {
          var _rule3;
          _rule3 = named(__strnum(Period != null && Period.parserName || "Period") + "?", function (o) {
            return Period(o) || true;
          });
          return function (o) {
            var clone, result;
            clone = o.clone();
            return (result = ThisShorthandLiteral(clone)) && _rule3(clone) && (o.update(clone), result);
          };
        }());
        return function (o) {
          return _rule(o) || _rule2(o);
        };
      }()));
      DecimalNumber = cache(named("DecimalNumber", (function () {
        var DecimalDigits, RawDecimalDigits;
        RawDecimalDigits = named("RawDecimalDigits", function (o) {
          var clone, item, result;
          clone = o.clone();
          result = [];
          while (item = DecimalDigit(clone)) {
            result.push(item);
          }
          if (result.length < 1) {
            return false;
          } else {
            o.update(clone);
            return result;
          }
        });
        DecimalDigits = named("DecimalDigits", (function () {
          var _rule;
          _rule = (function () {
            var _rule2;
            _rule2 = (function () {
              var _rule3;
              _rule3 = named(__strnum(Underscore != null && Underscore.parserName || "Underscore") + "+", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = Underscore(clone)) {
                  result.push(item);
                }
                if (result.length < 1) {
                  return false;
                } else {
                  o.update(clone);
                  return result;
                }
              });
              return function (o) {
                var clone, result;
                clone = o.clone();
                return _rule3(clone) && (result = RawDecimalDigits(clone)) && (o.update(clone), result);
              };
            }());
            return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
              var clone, item, result;
              clone = o.clone();
              result = [];
              while (item = _rule2(clone)) {
                result.push(item);
              }
              o.update(clone);
              return result;
            });
          }());
          return (function () {
            function _rule2(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.head = RawDecimalDigits(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
            }
            function _mutator(x) {
              var _arr, _i, _len, part, parts;
              parts = processCharCodes(x.head);
              for (_arr = __toArray(x.tail), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                part = _arr[_i];
                processCharCodes(part, parts);
              }
              return parts.join("");
            }
            return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule2(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }()));
        return (function () {
          var _rule, _rule2, _rule3;
          _rule = (function () {
            var _rule4;
            _rule4 = (function () {
              function _rule5(o) {
                var clone, result;
                clone = o.clone();
                return Period(clone) && (result = DecimalDigits(clone)) && (o.update(clone), result);
              }
              function _mutator(x) {
                return "." + __strnum(x);
              }
              return named(_rule5 != null && _rule5.parserName || "<unknown>", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = _rule5(o);
                if (!result) {
                  return false;
                } else {
                  return _mutator(result, o, index, line);
                }
              });
            }());
            return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "?", function (o) {
              var index, line;
              index = o.index;
              line = o.line;
              return _rule4(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
            });
          }());
          _rule2 = (function () {
            var _rule4;
            _rule4 = (function () {
              var _rule6;
              function _rule5(o) {
                var c;
                c = o.data.charCodeAt(o.index);
                if (c === 69 || c === 101) {
                  o.index = __num(o.index) + 1;
                  return c;
                } else {
                  o.fail("[Ee]");
                  return false;
                }
              }
              _rule6 = named(__strnum(PlusOrMinus != null && PlusOrMinus.parserName || "PlusOrMinus") + "?", function (o) {
                var index, line;
                index = o.index;
                line = o.line;
                return PlusOrMinus(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
              });
              return (function () {
                function _rule7(o) {
                  var clone, result;
                  clone = o.clone();
                  result = {};
                  return (result.e = _rule5(clone)) && (result.op = _rule6(clone)) && (result.digits = DecimalDigits(clone)) && (o.update(clone), result);
                }
                function _mutator(x) {
                  return __strnum(fromCharCode(x.e)) + __strnum(x.op !== NOTHING ? fromCharCode(x.op) : "") + __strnum(x.digits);
                }
                return named(_rule7 != null && _rule7.parserName || "<unknown>", function (o) {
                  var index, line, result;
                  index = o.index;
                  line = o.line;
                  result = _rule7(o);
                  if (!result) {
                    return false;
                  } else {
                    return _mutator(result, o, index, line);
                  }
                });
              }());
            }());
            return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "?", function (o) {
              var index, line;
              index = o.index;
              line = o.line;
              return _rule4(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
            });
          }());
          _rule3 = (function () {
            function _rule4(o) {
              var clone;
              clone = o.clone();
              return Underscore(clone) && NamePart(clone) && (o.update(clone), true);
            }
            return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "?", function (o) {
              return _rule4(o) || true;
            });
          }());
          return (function () {
            function _rule4(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.integer = DecimalDigits(clone)) && (result.decimal = _rule(clone)) && (result.scientific = _rule2(clone)) && _rule3(clone) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              var decimal, scientific, text, value;
              decimal = x.decimal;
              scientific = x.scientific;
              if (decimal === NOTHING) {
                decimal = "";
              }
              if (scientific === NOTHING) {
                scientific = "";
              }
              text = __strnum(x.integer) + __strnum(decimal) + __strnum(scientific);
              value = Number(text);
              if (!isFinite(value)) {
                o.error("Unable to parse number: " + text);
              }
              return o["const"](i, value);
            }
            return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule4(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
      }())));
      function makeRadixNumber(radix, separator, digit) {
        var digits;
        digits = (function () {
          var _rule, _rule2;
          _rule = named(__strnum(digit != null && digit.parserName || "digit") + "+", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = digit(clone)) {
              result.push(item);
            }
            if (result.length < 1) {
              return false;
            } else {
              o.update(clone);
              return result;
            }
          });
          _rule2 = (function () {
            var _rule3;
            _rule3 = (function () {
              var _rule4, _rule5;
              _rule4 = named(__strnum(Underscore != null && Underscore.parserName || "Underscore") + "+", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = Underscore(clone)) {
                  result.push(item);
                }
                if (result.length < 1) {
                  return false;
                } else {
                  o.update(clone);
                  return result;
                }
              });
              _rule5 = named(__strnum(digit != null && digit.parserName || "digit") + "+", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = digit(clone)) {
                  result.push(item);
                }
                if (result.length < 1) {
                  return false;
                } else {
                  o.update(clone);
                  return result;
                }
              });
              return function (o) {
                var clone, result;
                clone = o.clone();
                return _rule4(clone) && (result = _rule5(clone)) && (o.update(clone), result);
              };
            }());
            return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "*", function (o) {
              var clone, item, result;
              clone = o.clone();
              result = [];
              while (item = _rule3(clone)) {
                result.push(item);
              }
              o.update(clone);
              return result;
            });
          }());
          return (function () {
            function _rule3(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.head = _rule(clone)) && (result.tail = _rule2(clone)) && (o.update(clone), result);
            }
            function _mutator(x) {
              var _arr, _i, _len, part, parts;
              parts = processCharCodes(x.head);
              for (_arr = __toArray(x.tail), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                part = _arr[_i];
                processCharCodes(part, parts);
              }
              return parts.join("");
            }
            return named(_rule3 != null && _rule3.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule3(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return (function () {
          var _rule;
          _rule = (function () {
            function _rule2(o) {
              var clone, result;
              clone = o.clone();
              return Period(clone) && (result = digits(clone)) && (o.update(clone), result);
            }
            return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "?", function (o) {
              var index, line;
              index = o.index;
              line = o.line;
              return _rule2(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
            });
          }());
          return (function () {
            function _rule2(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return Zero(clone) && (result.separator = separator(clone)) && (result.integer = digits(clone)) && (result.decimal = _rule(clone)) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              var decimal, decimalNum, decimalText, integer, value;
              integer = x.integer;
              decimal = x.decimal;
              if (decimal === NOTHING) {
                decimal = "";
              }
              value = parseInt(integer, radix);
              if (!isFinite(value)) {
                if (decimal) {
                  decimalText = "." + __strnum(decimal);
                } else {
                  decimalText = "";
                }
                o.error("Unable to parse number: 0" + __strnum(fromCharCode(x.separator)) + __strnum(integer) + decimalText);
              }
              if (decimal) {
                while (true) {
                  decimalNum = parseInt(decimal, radix);
                  if (isFinite(decimalNum)) {
                    value += decimalNum / Math.pow(__num(radix), __num(decimal.length));
                    break;
                  } else {
                    decimal = decimal.slice(0, -1);
                  }
                }
              }
              return o["const"](i, value);
            }
            return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule2(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
      }
      HexDigit = named("HexDigit", function (o) {
        var c;
        c = o.data.charCodeAt(o.index);
        if (c >= 48 && c <= 57 || c >= 65 && c <= 70 || c >= 97 && c <= 102) {
          o.index = __num(o.index) + 1;
          return c;
        } else {
          o.fail("[0-9A-Fa-f]");
          return false;
        }
      });
      HexNumber = named("HexNumber", makeRadixNumber(
        16,
        function (o) {
          var c;
          c = o.data.charCodeAt(o.index);
          if (c === 88 || c === 120) {
            o.index = __num(o.index) + 1;
            return c;
          } else {
            o.fail("[Xx]");
            return false;
          }
        },
        HexDigit
      ));
      OctalDigit = named("OctalDigit", function (o) {
        var c;
        c = o.data.charCodeAt(o.index);
        if (c >= 48 && c <= 55) {
          o.index = __num(o.index) + 1;
          return c;
        } else {
          o.fail("[0-7]");
          return false;
        }
      });
      OctalNumber = named("OctalNumber", makeRadixNumber(
        8,
        function (o) {
          var c;
          c = o.data.charCodeAt(o.index);
          if (c === 79 || c === 111) {
            o.index = __num(o.index) + 1;
            return c;
          } else {
            o.fail("[Oo]");
            return false;
          }
        },
        OctalDigit
      ));
      BinaryDigit = named("BinaryDigit", function (o) {
        var c;
        c = o.data.charCodeAt(o.index);
        if (c === 48 || c === 49) {
          o.index = __num(o.index) + 1;
          return c;
        } else {
          o.fail("[01]");
          return false;
        }
      });
      BinaryNumber = named("BinaryNumber", makeRadixNumber(
        2,
        function (o) {
          var c;
          c = o.data.charCodeAt(o.index);
          if (c === 66 || c === 98) {
            o.index = __num(o.index) + 1;
            return c;
          } else {
            o.fail("[Bb]");
            return false;
          }
        },
        BinaryDigit
      ));
      RadixNumber = named("RadixNumber", (function () {
        var GetDigits, Radix;
        GetDigits = (function () {
          var digitCache;
          digitCache = [];
          return function (radix) {
            var _ref;
            if ((_ref = digitCache[radix]) == null) {
              return digitCache[radix] = (function () {
                var _end, chars, digit, i;
                switch (radix) {
                case 2:
                  digit = BinaryDigit;
                  break;
                case 8:
                  digit = OctalDigit;
                  break;
                case 10:
                  digit = DecimalDigit;
                  break;
                case 16:
                  digit = HexDigit;
                  break;
                default:
                  chars = [];
                  for (i = 0, _end = __num(radix) > 10 ? __num(radix) : 10; i < _end; ++i) {
                    chars[i + 48] = true;
                  }
                  for (i = 0, _end = (__num(radix) > 36 ? __num(radix) : 36) - 10; i < _end; ++i) {
                    chars[i + 97] = true;
                    chars[i + 65] = true;
                  }
                  digit = function (o) {
                    var c;
                    c = o.data.charCodeAt(o.index);
                    if (chars[c]) {
                      o.index = __num(o.index) + 1;
                      return c;
                    } else {
                      return false;
                    }
                  };
                }
                return (function () {
                  var _rule, _rule2;
                  _rule = named(__strnum(digit != null && digit.parserName || "digit") + "+", function (o) {
                    var clone, item, result;
                    clone = o.clone();
                    result = [];
                    while (item = digit(clone)) {
                      result.push(item);
                    }
                    if (result.length < 1) {
                      return false;
                    } else {
                      o.update(clone);
                      return result;
                    }
                  });
                  _rule2 = (function () {
                    var _rule3;
                    _rule3 = (function () {
                      var _rule4, _rule5;
                      _rule4 = named(__strnum(Underscore != null && Underscore.parserName || "Underscore") + "+", function (o) {
                        var clone, item, result;
                        clone = o.clone();
                        result = [];
                        while (item = Underscore(clone)) {
                          result.push(item);
                        }
                        if (result.length < 1) {
                          return false;
                        } else {
                          o.update(clone);
                          return result;
                        }
                      });
                      _rule5 = named(__strnum(digit != null && digit.parserName || "digit") + "+", function (o) {
                        var clone, item, result;
                        clone = o.clone();
                        result = [];
                        while (item = digit(clone)) {
                          result.push(item);
                        }
                        if (result.length < 1) {
                          return false;
                        } else {
                          o.update(clone);
                          return result;
                        }
                      });
                      return function (o) {
                        var clone, result;
                        clone = o.clone();
                        return _rule4(clone) && (result = _rule5(clone)) && (o.update(clone), result);
                      };
                    }());
                    return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "*", function (o) {
                      var clone, item, result;
                      clone = o.clone();
                      result = [];
                      while (item = _rule3(clone)) {
                        result.push(item);
                      }
                      o.update(clone);
                      return result;
                    });
                  }());
                  return (function () {
                    function _rule3(o) {
                      var clone, result;
                      clone = o.clone();
                      result = {};
                      return (result.head = _rule(clone)) && (result.tail = _rule2(clone)) && (o.update(clone), result);
                    }
                    function _mutator(x) {
                      var _arr, _i, _len, part, parts;
                      parts = processCharCodes(x.head);
                      for (_arr = __toArray(x.tail), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                        part = _arr[_i];
                        processCharCodes(part, parts);
                      }
                      return parts.join("");
                    }
                    return named(_rule3 != null && _rule3.parserName || "<unknown>", function (o) {
                      var index, line, result;
                      index = o.index;
                      line = o.line;
                      result = _rule3(o);
                      if (!result) {
                        return false;
                      } else {
                        return _mutator(result, o, index, line);
                      }
                    });
                  }());
                }());
              }());
            } else {
              return _ref;
            }
          };
        }());
        Radix = named(__strnum(DecimalDigit != null && DecimalDigit.parserName || "DecimalDigit") + "{1,2}", function (o) {
          var clone, item, result;
          clone = o.clone();
          result = [];
          while (result.length < 2 && (item = DecimalDigit(clone))) {
            result.push(item);
          }
          if (result.length < 1) {
            return false;
          } else {
            o.update(clone);
            return result;
          }
        });
        return function (o) {
          var clone, decimal, decimalNum, digits, integer, radix, radixNum, startIndex, subClone, value;
          startIndex = o.index;
          clone = o.clone();
          radix = Radix(clone);
          if (!radix) {
            return false;
          }
          radix = processCharCodes(radix).join("");
          if (!LowerR(clone)) {
            return false;
          }
          radixNum = Number(radix);
          if (!isFinite(radixNum)) {
            o.error("Unable to parse radix: " + __strnum(radix));
          } else if (radixNum < 2 || radixNum > 36) {
            o.error("Radix must be at least 2 and at most 36, not " + radixNum);
          }
          digits = GetDigits(radixNum);
          integer = digits(clone);
          if (!integer) {
            return false;
          }
          value = parseInt(integer, radixNum);
          if (!isFinite(value)) {
            o.error("Unable to parse number: " + radixNum + "r" + __strnum(integer));
          }
          subClone = clone.clone();
          if (Period(subClone)) {
            decimal = digits(subClone);
            if (decimal) {
              clone.update(subClone);
              while (true) {
                decimalNum = parseInt(decimal, radixNum);
                if (decimalNum !== decimalNum) {
                  o.error("Unable to parse number: " + radixNum + "r" + __strnum(integer) + "." + __strnum(decimal));
                } else if (isFinite(decimalNum)) {
                  value += decimalNum / Math.pow(radixNum, __num(decimal.length));
                  break;
                } else {
                  decimal = decimal.slice(0, -1);
                }
              }
            }
          }
          o.update(clone);
          return o["const"](startIndex, value);
        };
      }()));
      NumberLiteral = cache(named("NumberLiteral", (function () {
        function _rule(o) {
          return HexNumber(o) || OctalNumber(o) || BinaryNumber(o) || RadixNumber(o) || DecimalNumber(o);
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }())));
      function makeConstLiteral(name, value) {
        return word(name, function (x, o, i) {
          return o["const"](i, value);
        });
      }
      NullLiteral = cache(named("NullLiteral", makeConstLiteral("null", null)));
      VoidLiteral = cache(named("VoidLiteral", (function () {
        var _rule, _rule2;
        _rule = makeConstLiteral("undefined", void 0);
        _rule2 = makeConstLiteral("void", void 0);
        return function (o) {
          return _rule(o) || _rule2(o);
        };
      }())));
      InfinityLiteral = named("InfinityLiteral", makeConstLiteral("Infinity", 1/0));
      NaNLiteral = named("NaNLiteral", makeConstLiteral("NaN", 0/0));
      TrueLiteral = named("TrueLiteral", makeConstLiteral("true", true));
      FalseLiteral = named("FalseLiteral", makeConstLiteral("false", false));
      SimpleConstantLiteral = named("SimpleConstantLiteral", function (o) {
        return NullLiteral(o) || VoidLiteral(o) || InfinityLiteral(o) || NaNLiteral(o) || TrueLiteral(o) || FalseLiteral(o);
      });
      LowerX = cache(named("LowerX", function (o) {
        if (o.data.charCodeAt(o.index) === 120) {
          o.index = __num(o.index) + 1;
          return 120;
        } else {
          o.fail('"x"');
          return false;
        }
      }));
      HexEscapeSequence = named("HexEscapeSequence", (function () {
        var _backend;
        _backend = (function () {
          var _rule;
          _rule = named(__strnum(HexDigit != null && HexDigit.parserName || "HexDigit") + "{2}", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (result.length < 2 && (item = HexDigit(clone))) {
              result.push(item);
            }
            if (result.length < 2) {
              return false;
            } else {
              o.update(clone);
              return result;
            }
          });
          return (function () {
            function _rule2(o) {
              var clone, result;
              clone = o.clone();
              return LowerX(clone) && (result = _rule(clone)) && (o.update(clone), result);
            }
            function _mutator(x) {
              return parseInt(processCharCodes(x).join(""), 16) || -1;
            }
            return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule2(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!LowerX(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      LowerU = cache(named("LowerU", function (o) {
        if (o.data.charCodeAt(o.index) === 117) {
          o.index = __num(o.index) + 1;
          return 117;
        } else {
          o.fail('"u"');
          return false;
        }
      }));
      UnicodeEscapeSequence = named("UnicodeEscapeSequence", (function () {
        var _backend;
        _backend = (function () {
          var _rule;
          _rule = named(__strnum(HexDigit != null && HexDigit.parserName || "HexDigit") + "{4}", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (result.length < 4 && (item = HexDigit(clone))) {
              result.push(item);
            }
            if (result.length < 4) {
              return false;
            } else {
              o.update(clone);
              return result;
            }
          });
          return (function () {
            function _rule2(o) {
              var clone, result;
              clone = o.clone();
              return LowerU(clone) && (result = _rule(clone)) && (o.update(clone), result);
            }
            function _mutator(x) {
              return parseInt(processCharCodes(x).join(""), 16) || -1;
            }
            return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule2(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!LowerU(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      SingleEscapeCharacter = named("SingleEscapeCharacter", (function () {
        var ESCAPED_CHARACTERS;
        ESCAPED_CHARACTERS = {
          98: 8,
          102: 12,
          114: 13,
          110: 10,
          116: 9,
          118: 11,
          48: -1,
          49: 1,
          50: 2,
          51: 3,
          52: 4,
          53: 5,
          54: 6,
          55: 7
        };
        return (function () {
          function _mutator(c) {
            if (__owns.call(ESCAPED_CHARACTERS, c)) {
              return ESCAPED_CHARACTERS[c];
            } else {
              return c;
            }
          }
          return named(AnyChar != null && AnyChar.parserName || "AnyChar", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = AnyChar(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      BackslashEscapeSequence = named("BackslashEscapeSequence", (function () {
        function _rule(o) {
          return HexEscapeSequence(o) || UnicodeEscapeSequence(o) || SingleEscapeCharacter(o);
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Backslash(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }()));
      Nothing = named("Nothing", function (o) {
        return o.nothing(o.index);
      });
      StringInterpolation = named("StringInterpolation", (function () {
        var _backend;
        _backend = (function () {
          var _rule;
          _rule = (function () {
            var _rule2;
            _rule2 = (function () {
              function _rule3(o) {
                return Expression(o) || Nothing(o);
              }
              return function (o) {
                var clone, result;
                clone = o.clone();
                return OpenParenthesis(clone) && (result = _rule3(clone)) && CloseParenthesis(clone) && (o.update(clone), result);
              };
            }());
            return function (o) {
              return Identifier(o) || _rule2(o);
            };
          }());
          return function (o) {
            var clone, result;
            clone = o.clone();
            return DollarSign(clone) && NoSpace(clone) && (result = _rule(clone)) && (o.update(clone), result);
          };
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!DollarSign(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      SingleStringLiteral = named("SingleStringLiteral", (function () {
        var _backend;
        _backend = (function () {
          var _rule;
          _rule = (function () {
            var _rule2;
            _rule2 = (function () {
              var _rule3;
              _rule3 = (function () {
                function _rule4(o) {
                  return SingleQuote(o) || Newline(o);
                }
                return named("!" + __strnum(_rule4 != null && _rule4.parserName || "<unknown>"), function (o) {
                  return !_rule4(o.clone()) && AnyChar(o);
                });
              }());
              return function (o) {
                return BackslashEscapeSequence(o) || _rule3(o);
              };
            }());
            return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
              var clone, item, result;
              clone = o.clone();
              result = [];
              while (item = _rule2(clone)) {
                result.push(item);
              }
              o.update(clone);
              return result;
            });
          }());
          return (function () {
            function _rule2(o) {
              var clone, result;
              clone = o.clone();
              return SingleQuote(clone) && (result = _rule(clone)) && SingleQuote(clone) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              return o["const"](i, processCharCodes(x).join(""));
            }
            return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule2(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!SingleQuote(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      DoubleStringLiteralInner = named("DoubleStringLiteralInner", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = (function () {
            function _rule3(o) {
              return DoubleQuote(o) || Newline(o);
            }
            return named("!" + __strnum(_rule3 != null && _rule3.parserName || "<unknown>"), function (o) {
              return !_rule3(o.clone()) && AnyChar(o);
            });
          }());
          return function (o) {
            return BackslashEscapeSequence(o) || StringInterpolation(o) || _rule2(o);
          };
        }());
        return named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "*", function (o) {
          var clone, item, result;
          clone = o.clone();
          result = [];
          while (item = _rule(clone)) {
            result.push(item);
          }
          o.update(clone);
          return result;
        });
      }()));
      function doubleStringLiteralHandler(x, o, i) {
        var _arr, _i, _len, currentLiteral, part, stringParts;
        stringParts = [];
        currentLiteral = [];
        for (_arr = __toArray(x), _i = 0, _len = _arr.length; _i < _len; ++_i) {
          part = _arr[_i];
          if (typeof part === "number") {
            currentLiteral.push(part);
          } else if (!(part instanceof NothingNode)) {
            stringParts.push(o["const"](i, processCharCodes(currentLiteral).join("")));
            currentLiteral = [];
            stringParts.push(part);
          }
        }
        if (currentLiteral.length > 0) {
          stringParts.push(o["const"](i, processCharCodes(currentLiteral).join("")));
        }
        return stringParts;
      }
      DoubleStringLiteral = named("DoubleStringLiteral", (function () {
        var _backend;
        _backend = (function () {
          function _rule(o) {
            var clone, result;
            clone = o.clone();
            return DoubleQuote(clone) && (result = DoubleStringLiteralInner(clone)) && DoubleQuote(clone) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            var _arr, _arr2, _i, _len, part, stringParts;
            for (_arr = [], _arr2 = __toArray(doubleStringLiteralHandler(x, o, i)), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
              part = _arr2[_i];
              if (!part.isConst() || part.constValue() !== "") {
                _arr.push(part);
              }
            }
            stringParts = _arr;
            if (stringParts.length === 0) {
              return o["const"](i, "");
            } else if (stringParts.length === 1 && stringParts[0].isConst() && typeof stringParts[0].constValue() === "string") {
              return stringParts[0];
            } else {
              return o.string(i, stringParts);
            }
          }
          return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!DoubleQuote(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      PercentSignDoubleQuote = cache(named("PercentSignDoubleQuote", function (o) {
        var clone;
        clone = o.clone();
        return PercentSign(clone) && DoubleQuote(clone) && (o.update(clone), true);
      }));
      DoubleStringArrayLiteral = named("DoubleStringArrayLiteral", (function () {
        var _backend;
        _backend = (function () {
          function _rule(o) {
            var clone, result;
            clone = o.clone();
            return PercentSignDoubleQuote(clone) && (result = DoubleStringLiteralInner(clone)) && DoubleQuote(clone) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            var stringParts;
            stringParts = doubleStringLiteralHandler(x, o, i);
            return o.array(i, stringParts);
          }
          return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!PercentSignDoubleQuote(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      StringIndent = named("StringIndent", function (o) {
        var c, clone, count, currentIndent;
        clone = o.clone();
        count = 1;
        currentIndent = clone.indent.peek();
        while (count < __num(currentIndent)) {
          c = SpaceChar(clone);
          if (!c) {
            break;
          }
          if (!__owns.call(INDENTS, c)) {
            throw Error("Unexpected indent char: " + __str(JSON.stringify(c)));
          }
          count += __num(INDENTS[c]);
        }
        if (count > __num(currentIndent)) {
          return o.error("Mixed tabs and spaces in string literal");
        } else if (count < __num(currentIndent) && !Newline(clone.clone())) {
          return false;
        } else {
          o.update(clone);
          return count;
        }
      });
      TripleSingleStringLine = named("TripleSingleStringLine", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = (function () {
            function _rule3(o) {
              return TripleSingleQuote(o) || Newline(o);
            }
            return named("!" + __strnum(_rule3 != null && _rule3.parserName || "<unknown>"), function (o) {
              return !_rule3(o.clone()) && AnyChar(o);
            });
          }());
          return function (o) {
            return BackslashEscapeSequence(o) || _rule2(o);
          };
        }());
        return (function () {
          var _rule2;
          _rule2 = named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "*", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = _rule(clone)) {
              result.push(item);
            }
            o.update(clone);
            return result;
          });
          function _mutator(x) {
            return [processCharCodes(x).join("").replace(/[\t ]+$/, "")];
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      TripleDoubleStringLine = named("TripleDoubleStringLine", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = (function () {
            function _rule3(o) {
              return TripleDoubleQuote(o) || Newline(o);
            }
            return named("!" + __strnum(_rule3 != null && _rule3.parserName || "<unknown>"), function (o) {
              return !_rule3(o.clone()) && AnyChar(o);
            });
          }());
          return function (o) {
            return BackslashEscapeSequence(o) || StringInterpolation(o) || _rule2(o);
          };
        }());
        return (function () {
          var _rule2;
          _rule2 = named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "*", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = _rule(clone)) {
              result.push(item);
            }
            o.update(clone);
            return result;
          });
          function _mutator(x) {
            var _arr, _i, _len, currentLiteral, part, stringParts;
            stringParts = [];
            currentLiteral = [];
            for (_arr = __toArray(x), _i = 0, _len = _arr.length; _i < _len; ++_i) {
              part = _arr[_i];
              if (typeof part === "number") {
                currentLiteral.push(part);
              } else if (!(part instanceof NothingNode)) {
                stringParts.push(processCharCodes(currentLiteral).join(""));
                currentLiteral = [];
                stringParts.push(part);
              }
            }
            if (currentLiteral.length > 0) {
              stringParts.push(processCharCodes(currentLiteral).join("").replace(/[\t ]+$/, ""));
            }
            return stringParts;
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      function tripleStringHandler(x, o, i) {
        var _end, _len, j, len, line, lines, part, stringParts;
        lines = [x.first];
        if (lines[0].length === 0 || lines[0].length === 1 && lines[0][0] === "") {
          lines.shift();
        }
        for (j = 1, _end = __num(x.emptyLines.length); j < _end; ++j) {
          lines.push([""]);
        }
        lines.push.apply(lines, __toArray(x.rest));
        len = lines.length;
        if (len > 0 && (lines[len - 1].length === 0 || lines[len - 1].length === 1 && lines[len - 1][0] === "")) {
          lines.pop();
          --len;
        }
        stringParts = [];
        for (j = 0, _len = lines.length; j < _len; ++j) {
          line = lines[j];
          if (j > 0) {
            stringParts.push("\n");
          }
          stringParts.push.apply(stringParts, __toArray(line));
        }
        for (j = stringParts.length - 2; j >= 0; --j) {
          if (typeof stringParts[j] === "string" && typeof stringParts[j + 1] === "string") {
            stringParts.splice(j, 2, "" + stringParts[j] + stringParts[j + 1]);
          }
        }
        for (j = 0, _len = stringParts.length; j < _len; ++j) {
          part = stringParts[j];
          if (typeof part === "string") {
            stringParts[j] = o["const"](i, part);
          }
        }
        return stringParts;
      }
      function makeTripleString(quote, line) {
        return (function () {
          var _backend;
          _backend = (function () {
            var _rule, _rule2;
            _rule = (function () {
              function _rule3(o) {
                var clone, result;
                clone = o.clone();
                return _Space(clone) && (result = Newline(clone)) && (o.update(clone), result);
              }
              return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "*", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = _rule3(clone)) {
                  result.push(item);
                }
                o.update(clone);
                return result;
              });
            }());
            _rule2 = (function () {
              var _rule3;
              _rule3 = (function () {
                var _rule4, _rule5;
                _rule4 = (function () {
                  var _rule6;
                  _rule6 = (function () {
                    var _rule7;
                    _rule7 = (function () {
                      function _rule8(o) {
                        var clone, result;
                        clone = o.clone();
                        return Newline(clone) && StringIndent(clone) && (result = line(clone)) && (o.update(clone), result);
                      }
                      return named(__strnum(_rule8 != null && _rule8.parserName || "<unknown>") + "*", function (o) {
                        var clone, item, result;
                        clone = o.clone();
                        result = [];
                        while (item = _rule8(clone)) {
                          result.push(item);
                        }
                        o.update(clone);
                        return result;
                      });
                    }());
                    return (function () {
                      function _rule8(o) {
                        var clone, result;
                        clone = o.clone();
                        result = {};
                        return StringIndent(clone) && (result.head = line(clone)) && (result.tail = _rule7(clone)) && (o.update(clone), result);
                      }
                      function _mutator(x) {
                        return [x.head].concat(__toArray(x.tail));
                      }
                      return named(_rule8 != null && _rule8.parserName || "<unknown>", function (o) {
                        var index, line, result;
                        index = o.index;
                        line = o.line;
                        result = _rule8(o);
                        if (!result) {
                          return false;
                        } else {
                          return _mutator(result, o, index, line);
                        }
                      });
                    }());
                  }());
                  function _missing2() {
                    return [];
                  }
                  return named(__strnum(_rule6 != null && _rule6.parserName || "<unknown>") + "?", function (o) {
                    var index, line;
                    index = o.index;
                    line = o.line;
                    return _rule6(o) || _missing2(void 0, o, index, line);
                  });
                }());
                _rule5 = named(__strnum(Newline != null && Newline.parserName || "Newline") + "?", function (o) {
                  return Newline(o) || true;
                });
                return function (o) {
                  var clone, result;
                  clone = o.clone();
                  return MaybeAdvance(clone) && (result = _rule4(clone)) && _rule5(clone) && PopIndent(clone) && (o.update(clone), result);
                };
              }());
              function _missing() {
                return [];
              }
              return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "?", function (o) {
                var index, line;
                index = o.index;
                line = o.line;
                return _rule3(o) || _missing(void 0, o, index, line);
              });
            }());
            return (function () {
              function _rule3(o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return quote(clone) && (result.first = line(clone)) && (result.emptyLines = _rule(clone)) && (result.rest = _rule2(clone)) && quote(clone) && (o.update(clone), result);
              }
              function _mutator(x, o, i) {
                var _arr, _arr2, _i, _len, part, stringParts;
                for (_arr = [], _arr2 = __toArray(tripleStringHandler(x, o, i)), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                  part = _arr2[_i];
                  if (!part.isConst() || part.constValue() !== "") {
                    _arr.push(part);
                  }
                }
                stringParts = _arr;
                if (stringParts.length === 0) {
                  return o["const"](i, "");
                } else if (stringParts.length === 1 && stringParts[0].isConst() && typeof stringParts[0].constValue() === "string") {
                  return stringParts[0];
                } else {
                  return o.string(i, stringParts);
                }
              }
              return named(_rule3 != null && _rule3.parserName || "<unknown>", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = _rule3(o);
                if (!result) {
                  return false;
                } else {
                  return _mutator(result, o, index, line);
                }
              });
            }());
          }());
          return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
            var result;
            if (!quote(o.clone())) {
              return false;
            } else {
              result = _backend(o);
              if (!result) {
                throw SHORT_CIRCUIT;
              }
              return result;
            }
          });
        }());
      }
      TripleSingleStringLiteral = named("TripleSingleStringLiteral", makeTripleString(TripleSingleQuote, TripleSingleStringLine));
      TripleDoubleStringLiteral = named("TripleDoubleStringLiteral", makeTripleString(TripleDoubleQuote, TripleDoubleStringLine));
      PercentSignTripleDoubleQuote = cache(named("PercentSignTripleDoubleQuote", function (o) {
        var clone;
        clone = o.clone();
        return PercentSign(clone) && TripleDoubleQuote(clone) && (o.update(clone), true);
      }));
      TripleDoubleStringArrayLiteral = named("TripleDoubleStringArrayLiteral", (function () {
        var _backend;
        _backend = (function () {
          var _rule, _rule2;
          _rule = (function () {
            function _rule3(o) {
              var clone, result;
              clone = o.clone();
              return _Space(clone) && (result = Newline(clone)) && (o.update(clone), result);
            }
            return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "*", function (o) {
              var clone, item, result;
              clone = o.clone();
              result = [];
              while (item = _rule3(clone)) {
                result.push(item);
              }
              o.update(clone);
              return result;
            });
          }());
          _rule2 = (function () {
            var _rule3;
            _rule3 = (function () {
              var _rule4, _rule5;
              _rule4 = (function () {
                var _rule6;
                _rule6 = (function () {
                  var _rule7;
                  _rule7 = (function () {
                    function _rule8(o) {
                      var clone, result;
                      clone = o.clone();
                      return Newline(clone) && StringIndent(clone) && (result = TripleDoubleStringLine(clone)) && (o.update(clone), result);
                    }
                    return named(__strnum(_rule8 != null && _rule8.parserName || "<unknown>") + "*", function (o) {
                      var clone, item, result;
                      clone = o.clone();
                      result = [];
                      while (item = _rule8(clone)) {
                        result.push(item);
                      }
                      o.update(clone);
                      return result;
                    });
                  }());
                  return (function () {
                    function _rule8(o) {
                      var clone, result;
                      clone = o.clone();
                      result = {};
                      return StringIndent(clone) && (result.head = TripleDoubleStringLine(clone)) && (result.tail = _rule7(clone)) && (o.update(clone), result);
                    }
                    function _mutator(x) {
                      return [x.head].concat(__toArray(x.tail));
                    }
                    return named(_rule8 != null && _rule8.parserName || "<unknown>", function (o) {
                      var index, line, result;
                      index = o.index;
                      line = o.line;
                      result = _rule8(o);
                      if (!result) {
                        return false;
                      } else {
                        return _mutator(result, o, index, line);
                      }
                    });
                  }());
                }());
                function _missing2() {
                  return [];
                }
                return named(__strnum(_rule6 != null && _rule6.parserName || "<unknown>") + "?", function (o) {
                  var index, line;
                  index = o.index;
                  line = o.line;
                  return _rule6(o) || _missing2(void 0, o, index, line);
                });
              }());
              _rule5 = named(__strnum(Newline != null && Newline.parserName || "Newline") + "?", function (o) {
                return Newline(o) || true;
              });
              return function (o) {
                var clone, result;
                clone = o.clone();
                return MaybeAdvance(clone) && (result = _rule4(clone)) && _rule5(clone) && PopIndent(clone) && (o.update(clone), result);
              };
            }());
            function _missing() {
              return [];
            }
            return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "?", function (o) {
              var index, line;
              index = o.index;
              line = o.line;
              return _rule3(o) || _missing(void 0, o, index, line);
            });
          }());
          return (function () {
            function _rule3(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return PercentSignTripleDoubleQuote(clone) && (result.first = TripleDoubleStringLine(clone)) && (result.emptyLines = _rule(clone)) && (result.rest = _rule2(clone)) && TripleDoubleQuote(clone) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              var stringParts;
              stringParts = tripleStringHandler(x, o, i);
              return o.array(i, stringParts);
            }
            return named(_rule3 != null && _rule3.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule3(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!PercentSignTripleDoubleQuote(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      LowerR = cache(named("LowerR", function (o) {
        if (o.data.charCodeAt(o.index) === 114) {
          o.index = __num(o.index) + 1;
          return 114;
        } else {
          o.fail('"r"');
          return false;
        }
      }));
      RegexTripleSingleToken = cache(named("RegexTripleSingleToken", function (o) {
        var clone;
        clone = o.clone();
        return LowerR(clone) && TripleSingleQuote(clone) && (o.update(clone), true);
      }));
      RegexTripleDoubleToken = cache(named("RegexTripleDoubleToken", function (o) {
        var clone;
        clone = o.clone();
        return LowerR(clone) && TripleDoubleQuote(clone) && (o.update(clone), true);
      }));
      RegexSingleToken = cache(named("RegexSingleToken", function (o) {
        var clone;
        clone = o.clone();
        return LowerR(clone) && SingleQuote(clone) && (o.update(clone), true);
      }));
      RegexDoubleToken = cache(named("RegexDoubleToken", function (o) {
        var clone;
        clone = o.clone();
        return LowerR(clone) && DoubleQuote(clone) && (o.update(clone), true);
      }));
      RegexFlags = named("RegexFlags", (function () {
        function _missing() {
          return [];
        }
        return named(__strnum(NamePart != null && NamePart.parserName || "NamePart") + "?", function (o) {
          var index, line;
          index = o.index;
          line = o.line;
          return NamePart(o) || _missing(void 0, o, index, line);
        });
      }()));
      RegexComment = named("RegexComment", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = named("!" + __strnum(Newline != null && Newline.parserName || "Newline"), function (o) {
            return !Newline(o.clone()) && AnyChar(o);
          });
          return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = _rule2(clone)) {
              result.push(item);
            }
            o.update(clone);
            return result;
          });
        }());
        return (function () {
          function _rule2(o) {
            var clone;
            clone = o.clone();
            return HashSign(clone) && _rule(clone) && (o.update(clone), true);
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else if (typeof NOTHING === "function") {
              return NOTHING(result, o, index, line);
            } else if (NOTHING !== void 0) {
              return NOTHING;
            } else {
              return result;
            }
          });
        }());
      }()));
      RegexLiteral = named("RegexLiteral", (function () {
        var _rule;
        _rule = (function () {
          var _rule2, _rule3, _rule4, _rule5;
          _rule2 = (function () {
            var _backend;
            _backend = (function () {
              var _rule6;
              _rule6 = (function () {
                var _rule7;
                _rule7 = (function () {
                  var _rule10, _rule11, _rule9;
                  function _rule8(o) {
                    var clone;
                    clone = o.clone();
                    return Backslash(clone) && DollarSign(clone) && (o.update(clone), 36);
                  }
                  _rule9 = named(SpaceChar != null && SpaceChar.parserName || "SpaceChar", function (o) {
                    var index, line, result;
                    index = o.index;
                    line = o.line;
                    result = SpaceChar(o);
                    if (!result) {
                      return false;
                    } else if (typeof NOTHING === "function") {
                      return NOTHING(result, o, index, line);
                    } else if (NOTHING !== void 0) {
                      return NOTHING;
                    } else {
                      return result;
                    }
                  });
                  _rule10 = named(Newline != null && Newline.parserName || "Newline", function (o) {
                    var index, line, result;
                    index = o.index;
                    line = o.line;
                    result = Newline(o);
                    if (!result) {
                      return false;
                    } else if (typeof NOTHING === "function") {
                      return NOTHING(result, o, index, line);
                    } else if (NOTHING !== void 0) {
                      return NOTHING;
                    } else {
                      return result;
                    }
                  });
                  _rule11 = named("!" + __strnum(TripleDoubleQuote != null && TripleDoubleQuote.parserName || "TripleDoubleQuote"), function (o) {
                    return !TripleDoubleQuote(o.clone()) && AnyChar(o);
                  });
                  return function (o) {
                    return _rule8(o) || _rule9(o) || _rule10(o) || RegexComment(o) || StringInterpolation(o) || _rule11(o);
                  };
                }());
                return named(__strnum(_rule7 != null && _rule7.parserName || "<unknown>") + "*", function (o) {
                  var clone, item, result;
                  clone = o.clone();
                  result = [];
                  while (item = _rule7(clone)) {
                    result.push(item);
                  }
                  o.update(clone);
                  return result;
                });
              }());
              return function (o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return RegexTripleDoubleToken(clone) && (result.text = _rule6(clone)) && TripleDoubleQuote(clone) && (result.flags = RegexFlags(clone)) && (o.update(clone), result);
              };
            }());
            return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
              var result;
              if (!RegexTripleDoubleToken(o.clone())) {
                return false;
              } else {
                result = _backend(o);
                if (!result) {
                  throw SHORT_CIRCUIT;
                }
                return result;
              }
            });
          }());
          _rule3 = (function () {
            var _backend;
            _backend = (function () {
              var _rule6;
              _rule6 = (function () {
                var _rule7;
                _rule7 = (function () {
                  var _rule10, _rule8, _rule9;
                  _rule8 = named(SpaceChar != null && SpaceChar.parserName || "SpaceChar", function (o) {
                    var index, line, result;
                    index = o.index;
                    line = o.line;
                    result = SpaceChar(o);
                    if (!result) {
                      return false;
                    } else if (typeof NOTHING === "function") {
                      return NOTHING(result, o, index, line);
                    } else if (NOTHING !== void 0) {
                      return NOTHING;
                    } else {
                      return result;
                    }
                  });
                  _rule9 = named(Newline != null && Newline.parserName || "Newline", function (o) {
                    var index, line, result;
                    index = o.index;
                    line = o.line;
                    result = Newline(o);
                    if (!result) {
                      return false;
                    } else if (typeof NOTHING === "function") {
                      return NOTHING(result, o, index, line);
                    } else if (NOTHING !== void 0) {
                      return NOTHING;
                    } else {
                      return result;
                    }
                  });
                  _rule10 = named("!" + __strnum(TripleSingleQuote != null && TripleSingleQuote.parserName || "TripleSingleQuote"), function (o) {
                    return !TripleSingleQuote(o.clone()) && AnyChar(o);
                  });
                  return function (o) {
                    return _rule8(o) || _rule9(o) || RegexComment(o) || _rule10(o);
                  };
                }());
                return named(__strnum(_rule7 != null && _rule7.parserName || "<unknown>") + "*", function (o) {
                  var clone, item, result;
                  clone = o.clone();
                  result = [];
                  while (item = _rule7(clone)) {
                    result.push(item);
                  }
                  o.update(clone);
                  return result;
                });
              }());
              return function (o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return RegexTripleSingleToken(clone) && (result.text = _rule6(clone)) && TripleSingleQuote(clone) && (result.flags = RegexFlags(clone)) && (o.update(clone), result);
              };
            }());
            return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
              var result;
              if (!RegexTripleSingleToken(o.clone())) {
                return false;
              } else {
                result = _backend(o);
                if (!result) {
                  throw SHORT_CIRCUIT;
                }
                return result;
              }
            });
          }());
          _rule4 = (function () {
            var _backend;
            _backend = (function () {
              var _rule6;
              _rule6 = (function () {
                var _rule7;
                _rule7 = (function () {
                  var _rule10;
                  function _rule8(o) {
                    var clone;
                    clone = o.clone();
                    return DoubleQuote(clone) && DoubleQuote(clone) && (o.update(clone), 34);
                  }
                  function _rule9(o) {
                    var clone;
                    clone = o.clone();
                    return Backslash(clone) && DollarSign(clone) && (o.update(clone), 36);
                  }
                  _rule10 = (function () {
                    function _rule11(o) {
                      return DoubleQuote(o) || Newline(o) || DollarSign(o);
                    }
                    return named("!" + __strnum(_rule11 != null && _rule11.parserName || "<unknown>"), function (o) {
                      return !_rule11(o.clone()) && AnyChar(o);
                    });
                  }());
                  return function (o) {
                    return _rule8(o) || _rule9(o) || _rule10(o) || StringInterpolation(o);
                  };
                }());
                return named(__strnum(_rule7 != null && _rule7.parserName || "<unknown>") + "*", function (o) {
                  var clone, item, result;
                  clone = o.clone();
                  result = [];
                  while (item = _rule7(clone)) {
                    result.push(item);
                  }
                  o.update(clone);
                  return result;
                });
              }());
              return function (o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return RegexDoubleToken(clone) && (result.text = _rule6(clone)) && DoubleQuote(clone) && (result.flags = RegexFlags(clone)) && (o.update(clone), result);
              };
            }());
            return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
              var result;
              if (!RegexDoubleToken(o.clone())) {
                return false;
              } else {
                result = _backend(o);
                if (!result) {
                  throw SHORT_CIRCUIT;
                }
                return result;
              }
            });
          }());
          _rule5 = (function () {
            var _backend;
            _backend = (function () {
              var _rule6;
              _rule6 = (function () {
                var _rule7;
                _rule7 = (function () {
                  var _rule9;
                  function _rule8(o) {
                    var clone;
                    clone = o.clone();
                    return SingleQuote(clone) && SingleQuote(clone) && (o.update(clone), 39);
                  }
                  _rule9 = (function () {
                    function _rule10(o) {
                      return SingleQuote(o) || Newline(o);
                    }
                    return named("!" + __strnum(_rule10 != null && _rule10.parserName || "<unknown>"), function (o) {
                      return !_rule10(o.clone()) && AnyChar(o);
                    });
                  }());
                  return function (o) {
                    return _rule8(o) || _rule9(o);
                  };
                }());
                return named(__strnum(_rule7 != null && _rule7.parserName || "<unknown>") + "*", function (o) {
                  var clone, item, result;
                  clone = o.clone();
                  result = [];
                  while (item = _rule7(clone)) {
                    result.push(item);
                  }
                  o.update(clone);
                  return result;
                });
              }());
              return function (o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return RegexSingleToken(clone) && (result.text = _rule6(clone)) && SingleQuote(clone) && (result.flags = RegexFlags(clone)) && (o.update(clone), result);
              };
            }());
            return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
              var result;
              if (!RegexSingleToken(o.clone())) {
                return false;
              } else {
                result = _backend(o);
                if (!result) {
                  throw SHORT_CIRCUIT;
                }
                return result;
              }
            });
          }());
          return (function () {
            function _rule6(o) {
              return _rule2(o) || _rule3(o) || _rule4(o) || _rule5(o);
            }
            function _mutator(x, o, i) {
              var _arr, _i, _len, currentLiteral, flag, flags, part, seenFlags, stringParts, text;
              stringParts = [];
              currentLiteral = [];
              for (_arr = __toArray(x.text), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                part = _arr[_i];
                if (typeof part === "number") {
                  currentLiteral.push(part);
                } else if (part !== NOTHING && !(part instanceof NothingNode)) {
                  if (currentLiteral.length > 0) {
                    stringParts.push(o["const"](i, processCharCodes(currentLiteral).join("")));
                    currentLiteral = [];
                  }
                  stringParts.push(part);
                }
              }
              if (currentLiteral.length > 0) {
                stringParts.push(o["const"](i, processCharCodes(currentLiteral).join("")));
              }
              flags = processCharCodes(x.flags).join("");
              if (stringParts.length === 0) {
                text = o["const"](i, "");
              } else if (stringParts.length === 1 && stringParts[0].isConst() && typeof stringParts[0].constValue() === "string") {
                text = stringParts[0];
              } else {
                text = o.string(i, stringParts);
              }
              if (text.isConst()) {
                try {
                  RegExp(String(text.constValue()));
                } catch (e) {
                  o.error(e.message);
                }
              }
              seenFlags = [];
              for (_arr = __toArray(flags), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                flag = _arr[_i];
                if (__in(flag, seenFlags)) {
                  o.error("Specified flag '" + __strnum(flag) + "' in regular expression more than once");
                } else if (flag !== "g" && flag !== "i" && flag !== "m" && flag !== "y") {
                  o.error("Unknown regular expression flag '" + __strnum(flag) + "'");
                }
                seenFlags.push(flag);
              }
              return o.regexp(i, text, flags);
            }
            return named(_rule6 != null && _rule6.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule6(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }()));
      BackslashStringLiteral = named("BackslashStringLiteral", function (o) {
        var clone, result;
        clone = o.clone();
        return Backslash(clone) && NoSpace(clone) && (result = IdentifierNameConst(clone)) && (o.update(clone), result);
      });
      StringLiteral = cache(named("StringLiteral", (function () {
        function _rule(o) {
          return BackslashStringLiteral(o) || TripleSingleStringLiteral(o) || TripleDoubleStringLiteral(o) || TripleDoubleStringArrayLiteral(o) || SingleStringLiteral(o) || DoubleStringLiteral(o) || DoubleStringArrayLiteral(o);
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }())));
      ConstantLiteral = cache(named("ConstantLiteral", function (o) {
        return SimpleConstantLiteral(o) || NumberLiteral(o) || StringLiteral(o) || RegexLiteral(o);
      }));
      ArgumentsLiteral = cache(named("ArgumentsLiteral", word("arguments", function (x, o, i) {
        return o.args(i);
      })));
      Literal = named("Literal", function (o) {
        return ThisOrShorthandLiteral(o) || ArgumentsLiteral(o) || ConstantLiteral(o);
      });
      IdentifierNameConst = named("IdentifierNameConst", function (o) {
        var index, result;
        index = o.index;
        result = Name(o);
        if (result) {
          return o["const"](index, result);
        } else {
          return false;
        }
      });
      IdentifierNameConstOrNumberLiteral = cache(named("IdentifierNameConstOrNumberLiteral", function (o) {
        return IdentifierNameConst(o) || NumberLiteral(o);
      }));
      RESERVED_IDENTS = [
        "as",
        "AST",
        "arguments",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "enum",
        "eval",
        "export",
        "extends",
        "false",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "Infinity",
        "instanceof",
        "in",
        "let",
        "macro",
        "mutable",
        "NaN",
        "new",
        "not",
        "null",
        "package",
        "private",
        "protected",
        "public",
        "return",
        "static",
        "super",
        "switch",
        "then",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "undefined",
        "var",
        "void",
        "while",
        "with",
        "yield"
      ];
      Identifier = cache(named("Identifier", (function () {
        var _rule;
        _rule = (function () {
          function _rule3(o) {
            return _inAst.peek();
          }
          return (function () {
            function _rule4(o) {
              var clone, result;
              clone = o.clone();
              return _rule3(clone) && Space(clone) && DollarSign(clone) && NoSpace(clone) && (result = InvocationArguments(clone)) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              return o.call(
                i,
                o.ident(i, "$"),
                x
              );
            }
            return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule4(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        function _rule2(o) {
          var clone, index, result;
          index = o.index;
          clone = o.clone();
          result = Name(clone);
          if (!result || __in(result, RESERVED_IDENTS) || o.macros.hasMacroOrOperator(result)) {
            o.fail("identifier");
            return false;
          } else {
            o.update(clone);
            return o.ident(index, result);
          }
        }
        return function (o) {
          return _rule(o) || _rule2(o);
        };
      }())));
      MaybeNotToken = cache(named("MaybeNotToken", (function () {
        var _rule;
        _rule = word("not");
        return named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "?", function (o) {
          return _rule(o) || true;
        });
      }())));
      MaybeExistentialSymbolNoSpace = cache(named("MaybeExistentialSymbolNoSpace", (function () {
        var _rule;
        _rule = (function () {
          function _rule2(o) {
            if (o.data.charCodeAt(o.index) === 63) {
              o.index = __num(o.index) + 1;
              return 63;
            } else {
              o.fail('"?"');
              return false;
            }
          }
          return function (o) {
            var clone;
            clone = o.clone();
            return NoSpace(clone) && _rule2(clone) && (o.update(clone), "?");
          };
        }());
        return named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "?", function (o) {
          return _rule(o) || true;
        });
      }())));
      CustomOperatorCloseParenthesis = named("CustomOperatorCloseParenthesis", (function () {
        function handleUnaryOperator(operator, o, i, line) {
          var clone, node, op;
          clone = o.clone(o.cloneScope());
          op = operator.rule(clone);
          if (op && CloseParenthesis(clone)) {
            o.update(clone);
            node = clone.ident(i, "x");
            clone.scope.add(node, false, Type.any);
            return o["function"](
              i,
              [clone.param(i, node)],
              operator.func(
                { op: op, node: node },
                clone,
                i,
                line
              ),
              true,
              false
            );
          }
        }
        return function (o) {
          var _arr, _arr2, _i, _i2, _len, _ref, clone, i, inverted, left, line, op, operator, operators, result, right;
          i = o.index;
          line = o.line;
          for (_arr = __toArray(o.macros.binaryOperators), _i = 0, _len = _arr.length; _i < _len; ++_i) {
            operators = _arr[_i];
            if (operators) {
              for (_arr2 = __toArray(operators), _i2 = _arr2.length; _i2--; ) {
                operator = _arr2[_i2];
                clone = o.clone(o.cloneScope());
                inverted = false;
                if (operator.invertible) {
                  inverted = MaybeNotToken(clone);
                  if (!inverted) {
                    continue;
                  }
                }
                op = operator.rule(clone);
                if (op && CloseParenthesis(clone)) {
                  left = o.ident(i, "x");
                  right = o.ident(i, "y");
                  clone.scope.add(left, false, Type.any);
                  clone.scope.add(right, false, Type.any);
                  result = o["function"](
                    i,
                    [
                      clone.param(i, left),
                      clone.param(i, right)
                    ],
                    operator.func(
                      { left: left, inverted: inverted === "not", op: op, right: right },
                      clone,
                      i,
                      line
                    ),
                    true,
                    false
                  );
                  o.update(clone);
                  return result;
                }
              }
            }
          }
          for (_arr = __toArray(o.macros.prefixUnaryOperators), _i = _arr.length; _i--; ) {
            operator = _arr[_i];
            if ((_ref = handleUnaryOperator(operator, o, i, line)) != null) {
              return _ref;
            }
          }
          for (_arr = __toArray(o.macros.postfixUnaryOperators), _i = _arr.length; _i--; ) {
            operator = _arr[_i];
            if ((_ref = handleUnaryOperator(operator, o, i, line)) != null) {
              return _ref;
            }
          }
          return false;
        };
      }()));
      CustomBinaryOperator = named("CustomBinaryOperator", function (o) {
        var _arr, _arr2, _i, _i2, _len, clone, i, inverted, op, operator, operators;
        i = o.index;
        for (_arr = __toArray(o.macros.binaryOperators), _i = 0, _len = _arr.length; _i < _len; ++_i) {
          operators = _arr[_i];
          if (operators) {
            for (_arr2 = __toArray(operators), _i2 = _arr2.length; _i2--; ) {
              operator = _arr2[_i2];
              clone = o.clone();
              inverted = false;
              if (operator.invertible) {
                inverted = MaybeNotToken(clone);
                if (!inverted) {
                  continue;
                }
              }
              op = operator.rule(clone);
              if (op) {
                o.update(clone);
                return { op: op, operator: operator, inverted: inverted === "not" };
              }
            }
          }
        }
        return false;
      });
      Parenthetical = named("Parenthetical", (function () {
        var _rule;
        _rule = (function () {
          var _rule3, _rule4, _rule5;
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return (result = AssignmentAsExpression(clone)) && CloseParenthesis(clone) && (o.update(clone), result);
          }
          _rule3 = (function () {
            var _rule6;
            _rule6 = named(__strnum(CustomBinaryOperator != null && CustomBinaryOperator.parserName || "CustomBinaryOperator") + "?", function (o) {
              var index, line;
              index = o.index;
              line = o.line;
              return CustomBinaryOperator(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
            });
            return (function () {
              function _rule7(o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return (result.left = Expression(clone)) && (result.operator = _rule6(clone)) && CloseParenthesis(clone) && (o.update(clone), result);
              }
              function _mutator(_p, o, i, line) {
                var clone, left, operator, right;
                left = _p.left;
                operator = _p.operator;
                if (operator === NOTHING) {
                  return left;
                } else {
                  clone = o.clone(o.cloneScope());
                  right = o.tmp(i, getTmpId(), "x");
                  clone.scope.add(right, false, Type.any);
                  return o["function"](
                    i,
                    [clone.param(i, right)],
                    operator.operator.func(
                      {
                        left: left.rescope(clone.scope.id, clone),
                        inverted: operator.inverted,
                        op: operator.op,
                        right: right
                      },
                      clone,
                      i,
                      line
                    ),
                    true,
                    false
                  );
                }
              }
              return named(_rule7 != null && _rule7.parserName || "<unknown>", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = _rule7(o);
                if (!result) {
                  return false;
                } else {
                  return _mutator(result, o, index, line);
                }
              });
            }());
          }());
          _rule4 = (function () {
            function _rule6(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.operator = CustomBinaryOperator(clone)) && (result.right = Expression(clone)) && CloseParenthesis(clone) && (o.update(clone), result);
            }
            function _mutator(_p, o, i, line) {
              var _p2, clone, inverted, left, op, operator, right;
              right = _p.right;
              _p2 = _p.operator;
              op = _p2.op;
              operator = _p2.operator;
              inverted = _p2.inverted;
              clone = o.clone(o.cloneScope());
              left = o.tmp(i, getTmpId(), "x");
              clone.scope.add(left, false, Type.any);
              return o["function"](
                i,
                [clone.param(i, left)],
                operator.func(
                  {
                    left: left,
                    inverted: inverted,
                    op: op,
                    right: right.rescope(clone.scope.id, clone)
                  },
                  clone,
                  i,
                  line
                ),
                true,
                false
              );
            }
            return named(_rule6 != null && _rule6.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule6(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
          _rule5 = (function () {
            var _rule6;
            _rule6 = named(__strnum(typeof InvocationOrAccessPart !== "undefined" && InvocationOrAccessPart !== null && InvocationOrAccessPart.parserName || "InvocationOrAccessPart") + "+", function (o) {
              var clone, item, result;
              clone = o.clone();
              result = [];
              while (item = InvocationOrAccessPart(clone)) {
                result.push(item);
              }
              if (result.length < 1) {
                return false;
              } else {
                o.update(clone);
                return result;
              }
            });
            return (function () {
              function _rule7(o) {
                var clone, result;
                clone = o.clone();
                return (result = _rule6(clone)) && CloseParenthesis(clone) && (o.update(clone), result);
              }
              function _mutator(x, o, i) {
                var clone, left;
                clone = o.clone(o.cloneScope());
                left = o.tmp(i, getTmpId(), "x");
                clone.scope.add(left, false, Type.any);
                return o["function"](
                  i,
                  [clone.param(i, left)],
                  convertInvocationOrAccess(
                    false,
                    { type: "normal", existential: false, node: left },
                    x,
                    o,
                    i
                  ).rescope(clone.scope.id, clone),
                  true,
                  false
                );
              }
              return named(_rule7 != null && _rule7.parserName || "<unknown>", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = _rule7(o);
                if (!result) {
                  return false;
                } else {
                  return _mutator(result, o, index, line);
                }
              });
            }());
          }());
          return function (o) {
            return _rule2(o) || _rule3(o) || CustomOperatorCloseParenthesis(o) || _rule4(o) || _rule5(o);
          };
        }());
        return function (o) {
          var clone, result;
          clone = o.clone();
          return OpenParenthesis(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }()));
      MaybeSpreadToken = named("MaybeSpreadToken", (function () {
        function _rule(o) {
          var clone;
          clone = o.clone();
          return Space(clone) && Period(clone) && Period(clone) && Period(clone) && (o.update(clone), "...");
        }
        return named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "?", function (o) {
          return _rule(o) || true;
        });
      }()));
      SpreadOrExpression = named("SpreadOrExpression", (function () {
        function _rule(o) {
          var clone, result;
          clone = o.clone();
          result = {};
          return (result.spread = MaybeSpreadToken(clone)) && (result.node = Expression(clone)) && (o.update(clone), result);
        }
        function _mutator(x, o, i) {
          if (x.spread === "...") {
            return o.spread(i, x.node.doWrap(o));
          } else {
            return x.node;
          }
        }
        return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
          var index, line, result;
          index = o.index;
          line = o.line;
          result = _rule(o);
          if (!result) {
            return false;
          } else {
            return _mutator(result, o, index, line);
          }
        });
      }()));
      ArrayLiteral = named("ArrayLiteral", preventUnclosedObjectLiteral((function () {
        var _rule, _rule2;
        _rule = (function () {
          var _rule3;
          _rule3 = (function () {
            var _rule4;
            _rule4 = (function () {
              function _rule5(o) {
                var clone, result;
                clone = o.clone();
                return Comma(clone) && (result = SpreadOrExpression(clone)) && (o.update(clone), result);
              }
              return named(__strnum(_rule5 != null && _rule5.parserName || "<unknown>") + "*", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = _rule5(clone)) {
                  result.push(item);
                }
                o.update(clone);
                return result;
              });
            }());
            return (function () {
              function _rule5(o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return (result.head = SpreadOrExpression(clone)) && (result.tail = _rule4(clone)) && MaybeComma(clone) && (o.update(clone), result);
              }
              function _mutator(x) {
                return [x.head].concat(__toArray(x.tail));
              }
              return named(_rule5 != null && _rule5.parserName || "<unknown>", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = _rule5(o);
                if (!result) {
                  return false;
                } else {
                  return _mutator(result, o, index, line);
                }
              });
            }());
          }());
          function _missing() {
            return [];
          }
          return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule3(o) || _missing(void 0, o, index, line);
          });
        }());
        _rule2 = (function () {
          var _rule3;
          _rule3 = (function () {
            var _rule4;
            _rule4 = (function () {
              var _rule5;
              _rule5 = (function () {
                var _rule6;
                _rule6 = (function () {
                  function _rule7(o) {
                    var clone, result;
                    clone = o.clone();
                    return CommaOrNewlineWithCheckIndent(clone) && (result = SpreadOrExpression(clone)) && (o.update(clone), result);
                  }
                  return named(__strnum(_rule7 != null && _rule7.parserName || "<unknown>") + "*", function (o) {
                    var clone, item, result;
                    clone = o.clone();
                    result = [];
                    while (item = _rule7(clone)) {
                      result.push(item);
                    }
                    o.update(clone);
                    return result;
                  });
                }());
                return (function () {
                  function _rule7(o) {
                    var clone, result;
                    clone = o.clone();
                    result = {};
                    return CheckIndent(clone) && (result.head = SpreadOrExpression(clone)) && (result.tail = _rule6(clone)) && (o.update(clone), result);
                  }
                  function _mutator(x) {
                    return [x.head].concat(__toArray(x.tail));
                  }
                  return named(_rule7 != null && _rule7.parserName || "<unknown>", function (o) {
                    var index, line, result;
                    index = o.index;
                    line = o.line;
                    result = _rule7(o);
                    if (!result) {
                      return false;
                    } else {
                      return _mutator(result, o, index, line);
                    }
                  });
                }());
              }());
              function _missing2() {
                return [];
              }
              return named(__strnum(_rule5 != null && _rule5.parserName || "<unknown>") + "?", function (o) {
                var index, line;
                index = o.index;
                line = o.line;
                return _rule5(o) || _missing2(void 0, o, index, line);
              });
            }());
            return function (o) {
              var clone, result;
              clone = o.clone();
              return SomeEmptyLines(clone) && MaybeAdvance(clone) && (result = _rule4(clone)) && EmptyLines(clone) && MaybeCommaOrNewline(clone) && PopIndent(clone) && (o.update(clone), result);
            };
          }());
          function _missing() {
            return [];
          }
          return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule3(o) || _missing(void 0, o, index, line);
          });
        }());
        return (function () {
          function _rule3(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return OpenSquareBracket(clone) && Space(clone) && (result.first = _rule(clone)) && (result.rest = _rule2(clone)) && CloseSquareBracket(clone) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.array(i, __toArray(x.first).concat(__toArray(x.rest)));
          }
          return named(_rule3 != null && _rule3.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule3(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }())));
      BracketedObjectKey = named("BracketedObjectKey", function (o) {
        var clone, result;
        clone = o.clone();
        return OpenSquareBracket(clone) && (result = ExpressionOrAssignment(clone)) && CloseSquareBracket(clone) && (o.update(clone), result);
      });
      ConstObjectKey = named("ConstObjectKey", (function () {
        var _rule;
        _rule = (function () {
          function _mutator(x, o, i) {
            return o["const"](i, String(x.value));
          }
          return named(NumberLiteral != null && NumberLiteral.parserName || "NumberLiteral", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = NumberLiteral(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        return function (o) {
          return StringLiteral(o) || _rule(o) || IdentifierNameConst(o);
        };
      }()));
      ObjectKey = cache(named("ObjectKey", function (o) {
        return BracketedObjectKey(o) || ConstObjectKey(o);
      }));
      Colon = cache(named("Colon", (function () {
        var _rule;
        _rule = named("!" + __strnum(ColonChar != null && ColonChar.parserName || "ColonChar"), function (o) {
          return !ColonChar(o.clone());
        });
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = ColonChar(clone)) && _rule(clone) && (o.update(clone), result);
        };
      }())));
      NotColon = cache(named("NotColon", function (o) {
        return !Colon(o.clone());
      }));
      ObjectKeyColon = cache(named("ObjectKeyColon", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = (function () {
            function _rule3(o) {
              if (o.data.charCodeAt(o.index) === 61) {
                o.index = __num(o.index) + 1;
                return 61;
              } else {
                o.fail('"="');
                return false;
              }
            }
            return named("!" + __strnum(_rule3 != null && _rule3.parserName || "<unknown>"), function (o) {
              return !_rule3(o.clone());
            });
          }());
          return function (o) {
            var clone, result;
            clone = o.clone();
            return (result = ObjectKey(clone)) && Colon(clone) && _rule2(clone) && (o.update(clone), result);
          };
        }());
        return function (o) {
          var clone, result;
          clone = o.clone();
          clone.preventFail();
          result = _rule(clone);
          clone.unpreventFail();
          if (result) {
            o.update(clone);
            return result;
          } else {
            o.fail('key ":"');
            return false;
          }
        };
      }())));
      DualObjectKey = named("DualObjectKey", (function () {
        function _backend(o) {
          var clone, result;
          clone = o.clone();
          result = {};
          return (result.key = ObjectKeyColon(clone)) && (result.value = Expression(clone)) && (o.update(clone), result);
        }
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!ObjectKeyColon(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      PropertyObjectKeyColon = cache(named("PropertyObjectKeyColon", (function () {
        var _rule;
        _rule = (function () {
          var _rule2, _rule3, _rule4;
          _rule2 = word("property");
          _rule3 = word("get");
          _rule4 = word("set");
          return function (o) {
            return _rule2(o) || _rule3(o) || _rule4(o);
          };
        }());
        return function (o) {
          var clone, result;
          clone = o.clone();
          result = {};
          return (result.property = _rule(clone)) && Space(clone) && (result.key = ObjectKeyColon(clone)) && (o.update(clone), result);
        };
      }())));
      PropertyDualObjectKey = named("PropertyDualObjectKey", (function () {
        var _backend;
        _backend = (function () {
          function _rule(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.propertyKey = PropertyObjectKeyColon(clone)) && (result.value = Expression(clone)) && (o.update(clone), result);
          }
          function _mutator(x) {
            return { key: x.propertyKey.key, value: x.value, property: x.propertyKey.property };
          }
          return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!PropertyObjectKeyColon(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      PropertyOrDualObjectKey = named("PropertyOrDualObjectKey", function (o) {
        return PropertyDualObjectKey(o) || DualObjectKey(o);
      });
      IdentifierOrSimpleAccessStart = named("IdentifierOrSimpleAccessStart", (function () {
        var _rule, _rule2, _rule3;
        _rule = (function () {
          function _rule4(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.parent = ThisOrShorthandLiteralPeriod(clone)) && (result.child = IdentifierNameConstOrNumberLiteral(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.access(i, x.parent, x.child);
          }
          return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule4(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        _rule2 = (function () {
          function _rule4(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.parent = ThisOrShorthandLiteral(clone)) && DoubleColon(clone) && (result.child = IdentifierNameConstOrNumberLiteral(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.access(
              i,
              o.access(i, x.parent, o["const"](i, "prototype")),
              x.child
            );
          }
          return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule4(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        _rule3 = (function () {
          var _rule4;
          _rule4 = named(__strnum(DoubleColon != null && DoubleColon.parserName || "DoubleColon") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return DoubleColon(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
          return (function () {
            function _rule5(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.parent = ThisOrShorthandLiteral(clone)) && (result.isProto = _rule4(clone)) && OpenSquareBracketChar(clone) && (result.child = Expression(clone)) && CloseSquareBracket(clone) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              var parent;
              parent = x.parent;
              if (x.isProto !== NOTHING) {
                parent = o.access(i, parent, o["const"](i, "prototype"));
              }
              return o.access(i, parent, x.child);
            }
            return named(_rule5 != null && _rule5.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule5(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return function (o) {
          return Identifier(o) || _rule(o) || _rule2(o) || _rule3(o);
        };
      }()));
      IdentifierOrSimpleAccessPart = named("IdentifierOrSimpleAccessPart", (function () {
        var _rule, _rule2;
        _rule = (function () {
          function _rule3(o) {
            return Period(o) || DoubleColon(o);
          }
          return (function () {
            function _rule4(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.type = _rule3(clone)) && (result.child = IdentifierNameConstOrNumberLiteral(clone)) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              var child, isProto;
              isProto = x.type === "::";
              child = x.child;
              return function (parent) {
                return o.access(
                  i,
                  isProto
                    ? o.access(i, parent, o["const"](i, "prototype"))
                    : parent,
                  child
                );
              };
            }
            return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule4(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        _rule2 = (function () {
          var _rule3;
          _rule3 = named(__strnum(DoubleColon != null && DoubleColon.parserName || "DoubleColon") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return DoubleColon(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
          return (function () {
            function _rule4(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.type = _rule3(clone)) && OpenSquareBracketChar(clone) && (result.child = Expression(clone)) && CloseSquareBracket(clone) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              var child, isProto;
              isProto = x.type !== NOTHING;
              child = x.child;
              return function (parent) {
                return o.access(
                  i,
                  isProto
                    ? o.access(i, parent, o["const"](i, "prototype"))
                    : parent,
                  child
                );
              };
            }
            return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule4(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return function (o) {
          return _rule(o) || _rule2(o);
        };
      }()));
      IdentifierOrSimpleAccess = cache(named("IdentifierOrSimpleAccess", (function () {
        var _rule;
        _rule = named(__strnum(IdentifierOrSimpleAccessPart != null && IdentifierOrSimpleAccessPart.parserName || "IdentifierOrSimpleAccessPart") + "*", function (o) {
          var clone, item, result;
          clone = o.clone();
          result = [];
          while (item = IdentifierOrSimpleAccessPart(clone)) {
            result.push(item);
          }
          o.update(clone);
          return result;
        });
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.head = IdentifierOrSimpleAccessStart(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            var _arr, _i, _len, creator, current;
            current = x.head;
            for (_arr = __toArray(x.tail), _i = 0, _len = _arr.length; _i < _len; ++_i) {
              creator = _arr[_i];
              current = creator(current);
            }
            return current;
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }())));
      SingularObjectKey = named("SingularObjectKey", (function () {
        var _rule, _rule2, _rule3, _rule4, _rule5;
        _rule = (function () {
          function _rule6(o) {
            var clone, result;
            clone = o.clone();
            return (result = IdentifierOrSimpleAccess(clone)) && NotColon(clone) && (o.update(clone), result);
          }
          function _mutator(ident, o, i) {
            var key;
            if (ident instanceof AccessNode) {
              key = ident.child;
            } else if (ident instanceof IdentNode) {
              key = o["const"](i, ident.name);
            } else {
              key = o.error("Unknown ident type: " + __typeof(ident));
            }
            return { key: key, value: ident };
          }
          return named(_rule6 != null && _rule6.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule6(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        _rule2 = (function () {
          function _rule6(o) {
            var clone, result;
            clone = o.clone();
            return (result = ConstantLiteral(clone)) && NotColon(clone) && (o.update(clone), result);
          }
          function _mutator(node, o, i) {
            var key;
            if (node.isConst() && typeof node.constValue()) {
              key = o["const"](i, String(node.constValue()));
            } else {
              key = node;
            }
            return { key: key, value: node };
          }
          return named(_rule6 != null && _rule6.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule6(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        _rule3 = (function () {
          function _rule6(o) {
            var clone, result;
            clone = o.clone();
            return (result = ThisLiteral(clone)) && NotColon(clone) && (o.update(clone), result);
          }
          function _mutator(node, o, i) {
            return {
              key: o["const"](i, "this"),
              value: node
            };
          }
          return named(_rule6 != null && _rule6.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule6(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        _rule4 = (function () {
          function _rule6(o) {
            var clone, result;
            clone = o.clone();
            return (result = ArgumentsLiteral(clone)) && NotColon(clone) && (o.update(clone), result);
          }
          function _mutator(node, o, i) {
            return {
              key: o["const"](i, "arguments"),
              value: node
            };
          }
          return named(_rule6 != null && _rule6.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule6(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        _rule5 = (function () {
          function _rule6(o) {
            var clone, result;
            clone = o.clone();
            return (result = BracketedObjectKey(clone)) && NotColon(clone) && (o.update(clone), result);
          }
          function _mutator(node) {
            return { key: node, value: node };
          }
          return named(_rule6 != null && _rule6.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule6(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        return function (o) {
          return _rule(o) || _rule2(o) || _rule3(o) || _rule4(o) || _rule5(o);
        };
      }()));
      KeyValuePair = cache(named("KeyValuePair", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = named(__strnum(PlusOrMinus != null && PlusOrMinus.parserName || "PlusOrMinus") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return PlusOrMinus(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
          return (function () {
            function _rule3(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return Space(clone) && (result.bool = _rule2(clone)) && (result.pair = SingularObjectKey(clone)) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              if (x.bool !== NOTHING) {
                return {
                  key: x.pair.key,
                  value: o["const"](i, x.bool === 43),
                  property: x.pair.property
                };
              } else {
                return x.pair;
              }
            }
            return named(_rule3 != null && _rule3.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule3(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return function (o) {
          return PropertyOrDualObjectKey(o) || _rule(o);
        };
      }())));
      ObjectLiteral = named("ObjectLiteral", (function () {
        var _rule, _rule2, _rule3;
        _rule = (function () {
          var _rule4;
          _rule4 = (function () {
            var _rule5, _rule6, _rule7;
            _rule5 = word("extends");
            _rule6 = preventUnclosedObjectLiteral(function (o) {
              return Logic(o);
            });
            _rule7 = (function () {
              function _rule8(o) {
                return Newline(o.clone());
              }
              function _rule9(o) {
                return CloseCurlyBrace(o.clone());
              }
              return function (o) {
                return Comma(o) || _rule8(o) || _rule9(o);
              };
            }());
            return function (o) {
              var clone, result;
              clone = o.clone();
              return _rule5(clone) && (result = _rule6(clone)) && Space(clone) && _rule7(clone) && (o.update(clone), result);
            };
          }());
          return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule4(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
        }());
        _rule2 = (function () {
          var _rule4;
          _rule4 = (function () {
            var _rule5;
            _rule5 = (function () {
              function _rule6(o) {
                var clone, result;
                clone = o.clone();
                return Comma(clone) && (result = KeyValuePair(clone)) && (o.update(clone), result);
              }
              return named(__strnum(_rule6 != null && _rule6.parserName || "<unknown>") + "*", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = _rule6(clone)) {
                  result.push(item);
                }
                o.update(clone);
                return result;
              });
            }());
            return (function () {
              function _rule6(o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return (result.head = KeyValuePair(clone)) && (result.tail = _rule5(clone)) && MaybeComma(clone) && (o.update(clone), result);
              }
              function _mutator(x) {
                return [x.head].concat(__toArray(x.tail));
              }
              return named(_rule6 != null && _rule6.parserName || "<unknown>", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = _rule6(o);
                if (!result) {
                  return false;
                } else {
                  return _mutator(result, o, index, line);
                }
              });
            }());
          }());
          function _missing() {
            return [];
          }
          return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule4(o) || _missing(void 0, o, index, line);
          });
        }());
        _rule3 = (function () {
          var _rule4;
          _rule4 = (function () {
            var _rule5;
            _rule5 = (function () {
              var _rule6;
              _rule6 = (function () {
                var _rule7;
                _rule7 = (function () {
                  function _rule8(o) {
                    var clone, result;
                    clone = o.clone();
                    return CommaOrNewlineWithCheckIndent(clone) && (result = KeyValuePair(clone)) && (o.update(clone), result);
                  }
                  return named(__strnum(_rule8 != null && _rule8.parserName || "<unknown>") + "*", function (o) {
                    var clone, item, result;
                    clone = o.clone();
                    result = [];
                    while (item = _rule8(clone)) {
                      result.push(item);
                    }
                    o.update(clone);
                    return result;
                  });
                }());
                return (function () {
                  function _rule8(o) {
                    var clone, result;
                    clone = o.clone();
                    result = {};
                    return CheckIndent(clone) && (result.head = KeyValuePair(clone)) && (result.tail = _rule7(clone)) && (o.update(clone), result);
                  }
                  function _mutator(x) {
                    return [x.head].concat(__toArray(x.tail));
                  }
                  return named(_rule8 != null && _rule8.parserName || "<unknown>", function (o) {
                    var index, line, result;
                    index = o.index;
                    line = o.line;
                    result = _rule8(o);
                    if (!result) {
                      return false;
                    } else {
                      return _mutator(result, o, index, line);
                    }
                  });
                }());
              }());
              function _missing2() {
                return [];
              }
              return named(__strnum(_rule6 != null && _rule6.parserName || "<unknown>") + "?", function (o) {
                var index, line;
                index = o.index;
                line = o.line;
                return _rule6(o) || _missing2(void 0, o, index, line);
              });
            }());
            return function (o) {
              var clone, result;
              clone = o.clone();
              return SomeEmptyLines(clone) && MaybeAdvance(clone) && (result = _rule5(clone)) && EmptyLines(clone) && MaybeCommaOrNewline(clone) && PopIndent(clone) && (o.update(clone), result);
            };
          }());
          function _missing() {
            return [];
          }
          return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule4(o) || _missing(void 0, o, index, line);
          });
        }());
        return (function () {
          function _rule4(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return OpenCurlyBrace(clone) && Space(clone) && (result.prototype = _rule(clone)) && (result.first = _rule2(clone)) && (result.rest = _rule3(clone)) && CloseCurlyBrace(clone) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.object(i, __toArray(x.first).concat(__toArray(x.rest)), x.prototype !== NOTHING ? x.prototype : void 0);
          }
          return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule4(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      Body = named("Body", function (o) {
        var clone, result;
        clone = o.clone();
        return Space(clone) && Newline(clone) && EmptyLines(clone) && Advance(clone) && (result = Block(clone)) && PopIndent(clone) && (o.update(clone), result);
      });
      DedentedBody = named("DedentedBody", (function () {
        var _rule;
        _rule = (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return Newline(clone) && EmptyLines(clone) && (result = Block(clone)) && (o.update(clone), result);
          }
          return function (o) {
            return _rule2(o) || Nothing(o);
          };
        }());
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }()));
      DeclareEqualSymbol = named("DeclareEqualSymbol", (function () {
        function _rule(o) {
          if (o.data.charCodeAt(o.index) === 61) {
            o.index = __num(o.index) + 1;
            return 61;
          } else {
            o.fail('"="');
            return false;
          }
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }()));
      ArrayType = cache(named("ArrayType", (function () {
        var _rule;
        _rule = named(__strnum(typeof TypeReference !== "undefined" && TypeReference !== null && TypeReference.parserName || "TypeReference") + "?", function (o) {
          var index, line;
          index = o.index;
          line = o.line;
          return TypeReference(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
        });
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return OpenSquareBracket(clone) && (result = _rule(clone)) && CloseSquareBracket(clone) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            if (x === NOTHING) {
              return o.ident(i, "Array");
            } else {
              return o.typeArray(i, x);
            }
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }())));
      ObjectTypePair = named("ObjectTypePair", function (o) {
        var clone, result;
        clone = o.clone();
        result = {};
        return (result.key = ConstObjectKey(clone)) && Colon(clone) && (result.value = TypeReference(clone)) && (o.update(clone), result);
      });
      ObjectType = cache(named("ObjectType", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = (function () {
            var _rule3;
            _rule3 = (function () {
              function _rule4(o) {
                var clone, result;
                clone = o.clone();
                return CommaOrNewline(clone) && (result = ObjectTypePair(clone)) && (o.update(clone), result);
              }
              return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "*", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = _rule4(clone)) {
                  result.push(item);
                }
                o.update(clone);
                return result;
              });
            }());
            return (function () {
              function _rule4(o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return (result.head = ObjectTypePair(clone)) && (result.tail = _rule3(clone)) && MaybeComma(clone) && (o.update(clone), result);
              }
              function _mutator(x) {
                return [x.head].concat(__toArray(x.tail));
              }
              return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = _rule4(o);
                if (!result) {
                  return false;
                } else {
                  return _mutator(result, o, index, line);
                }
              });
            }());
          }());
          function _missing() {
            return [];
          }
          return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule2(o) || _missing(void 0, o, index, line);
          });
        }());
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return OpenCurlyBrace(clone) && (result = _rule(clone)) && CloseCurlyBrace(clone) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            var _arr, _i, _len, key, keys, keyValue;
            if (x.length === 0) {
              return o.ident(i, "Object");
            } else {
              keys = [];
              for (_arr = __toArray(x), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                key = _arr[_i].key;
                if (!(key instanceof ConstNode)) {
                  o.error("Expected a constant key, got " + __typeof(key));
                } else {
                  keyValue = String(key.value);
                  if (__in(keyValue, keys)) {
                    o.error("Duplicate object key: " + keyValue);
                  }
                  keys.push(keyValue);
                }
              }
              return o.typeObject(i, x);
            }
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }())));
      _inFunctionTypeParams = Stack(false);
      inFunctionTypeParams = makeAlterStack(_inFunctionTypeParams, true);
      notInFunctionTypeParams = makeAlterStack(_inFunctionTypeParams, false);
      FunctionType = cache(named("FunctionType", (function () {
        var _rule2, _rule3, _rule4;
        function _rule(o) {
          return !_inFunctionTypeParams.peek();
        }
        _rule2 = (function () {
          var _rule5, _rule6;
          _rule5 = (function () {
            var _rule7;
            _rule7 = (function () {
              function _rule8(o) {
                var clone;
                clone = o.clone();
                return CommaOrNewline(clone) && TypeReference(clone) && (o.update(clone), true);
              }
              return named(__strnum(_rule8 != null && _rule8.parserName || "<unknown>") + "*", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = _rule8(clone)) {
                  result.push(item);
                }
                o.update(clone);
                return result;
              });
            }());
            return function (o) {
              var clone;
              clone = o.clone();
              return OpenParenthesis(clone) && TypeReference(clone) && _rule7(clone) && CloseParenthesis(clone) && (o.update(clone), true);
            };
          }());
          _rule6 = inFunctionTypeParams(function (o) {
            return TypeReference(o);
          });
          return function (o) {
            return _rule5(o) || _rule6(o) || Nothing(o);
          };
        }());
        _rule3 = symbol("->");
        _rule4 = named(__strnum(typeof TypeReference !== "undefined" && TypeReference !== null && TypeReference.parserName || "TypeReference") + "?", function (o) {
          var index, line;
          index = o.index;
          line = o.line;
          return TypeReference(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
        });
        return (function () {
          function _rule5(o) {
            var clone, result;
            clone = o.clone();
            return _rule(clone) && _rule2(clone) && _rule3(clone) && (result = _rule4(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            if (x === NOTHING) {
              return o.ident(i, "Function");
            } else {
              return o.typeFunction(i, x);
            }
          }
          return named(_rule5 != null && _rule5.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule5(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }())));
      NonUnionType = cache(named("NonUnionType", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = notInFunctionTypeParams(function (o) {
            return TypeReference(o);
          });
          return function (o) {
            var clone, result;
            clone = o.clone();
            return OpenParenthesis(clone) && (result = _rule2(clone)) && CloseParenthesis(clone) && (o.update(clone), result);
          };
        }());
        return function (o) {
          return FunctionType(o) || _rule(o) || ArrayType(o) || ObjectType(o) || IdentifierOrSimpleAccess(o) || VoidLiteral(o) || NullLiteral(o);
        };
      }())));
      TypeReference = cache(named("TypeReference", (function () {
        var _rule;
        _rule = (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return Pipe(clone) && (result = NonUnionType(clone)) && (o.update(clone), result);
          }
          return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = _rule2(clone)) {
              result.push(item);
            }
            o.update(clone);
            return result;
          });
        }());
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.head = NonUnionType(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            var j, type, types;
            types = [x.head].concat(__toArray(x.tail));
            if (types.length === 1) {
              return types[0];
            } else {
              for (j = types.length; j--; ) {
                type = types[j];
                if (type instanceof TypeUnionNode) {
                  types.splice.apply(types, [j, 1].concat(__toArray(type.types)));
                }
              }
              if (types.length === 1) {
                return types[0];
              } else {
                return o.typeUnion(i, types);
              }
            }
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }())));
      AsToken = cache(named("AsToken", word("as")));
      MaybeAsType = named("MaybeAsType", (function () {
        var _rule;
        _rule = (function () {
          function _backend(o) {
            var clone, result;
            clone = o.clone();
            return AsToken(clone) && (result = TypeReference(clone)) && (o.update(clone), result);
          }
          return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
            var result;
            if (!AsToken(o.clone())) {
              return false;
            } else {
              result = _backend(o);
              if (!result) {
                throw SHORT_CIRCUIT;
              }
              return result;
            }
          });
        }());
        return named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "?", function (o) {
          var index, line;
          index = o.index;
          line = o.line;
          return _rule(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
        });
      }()));
      IdentifierParameter = named("IdentifierParameter", (function () {
        var _rule, _rule2, _rule3;
        _rule = (function () {
          var _rule4;
          _rule4 = word("mutable");
          return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "?", function (o) {
            return _rule4(o) || true;
          });
        }());
        _rule2 = named(__strnum(ThisOrShorthandLiteralPeriod != null && ThisOrShorthandLiteralPeriod.parserName || "ThisOrShorthandLiteralPeriod") + "?", function (o) {
          var index, line;
          index = o.index;
          line = o.line;
          return ThisOrShorthandLiteralPeriod(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
        });
        _rule3 = (function () {
          function _rule4(o) {
            var clone, result;
            clone = o.clone();
            return DeclareEqualSymbol(clone) && (result = Expression(clone)) && (o.update(clone), result);
          }
          return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule4(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
        }());
        return (function () {
          function _rule4(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.isMutable = _rule(clone)) && (result.spread = MaybeSpreadToken(clone)) && (result.parent = _rule2(clone)) && (result.ident = Identifier(clone)) && (result.asType = MaybeAsType(clone)) && (result.defaultValue = _rule3(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            var name;
            if (x.parent !== NOTHING) {
              name = o.access(i, x.parent, o["const"](i, x.ident.name));
            } else {
              name = x.ident;
            }
            if (x.spread === "..." && x.defaultValue !== NOTHING) {
              o.error("Cannot specify a default value for a spread parameter");
            }
            return o.param(
              i,
              name,
              x.defaultValue !== NOTHING ? x.defaultValue : void 0,
              x.spread === "...",
              x.isMutable === "mutable",
              x.asType !== NOTHING ? x.asType : void 0
            );
          }
          return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule4(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      Parameter = named("Parameter", function (o) {
        return IdentifierParameter(o) || ArrayParameter(o) || ObjectParameter(o);
      });
      ParameterOrNothing = named("ParameterOrNothing", function (o) {
        return Parameter(o) || Nothing(o);
      });
      function validateSpreadParameters(params, o) {
        var _arr, _i, param, spreadCount;
        spreadCount = 0;
        for (_arr = __toArray(params), _i = _arr.length; _i--; ) {
          param = _arr[_i];
          if (param instanceof ParamNode && param.spread) {
            ++spreadCount;
            if (spreadCount > 1) {
              o.error("Cannot have more than one spread parameter");
            }
          }
        }
        return params;
      }
      function removeTrailingNothings(array) {
        if (!__isArray(array)) {
          throw TypeError("Expected array to be an Array, got " + __typeof(array));
        }
        while (array.length && array[array.length - 1] instanceof NothingNode) {
          array.pop();
        }
        return array;
      }
      ArrayParameter = named("ArrayParameter", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = (function () {
            var _rule3;
            _rule3 = (function () {
              function _rule4(o) {
                var clone, result;
                clone = o.clone();
                return CommaOrNewline(clone) && (result = ParameterOrNothing(clone)) && (o.update(clone), result);
              }
              return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "*", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = _rule4(clone)) {
                  result.push(item);
                }
                o.update(clone);
                return result;
              });
            }());
            return (function () {
              function _rule4(o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return (result.head = ParameterOrNothing(clone)) && (result.tail = _rule3(clone)) && (o.update(clone), result);
              }
              function _mutator(x) {
                return removeTrailingNothings([x.head].concat(__toArray(x.tail)));
              }
              return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = _rule4(o);
                if (!result) {
                  return false;
                } else {
                  return _mutator(result, o, index, line);
                }
              });
            }());
          }());
          function _missing() {
            return [];
          }
          return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule2(o) || _missing(void 0, o, index, line);
          });
        }());
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return OpenSquareBracket(clone) && EmptyLines(clone) && (result = _rule(clone)) && EmptyLines(clone) && MaybeCommaOrNewline(clone) && CloseSquareBracket(clone) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.arrayParam(i, validateSpreadParameters(x, o));
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      ParamDualObjectKey = named("ParamDualObjectKey", function (o) {
        var clone, result;
        clone = o.clone();
        result = {};
        return (result.key = ObjectKeyColon(clone)) && (result.value = Parameter(clone)) && (o.update(clone), result);
      });
      ParamSingularObjectKey = named("ParamSingularObjectKey", (function () {
        function _rule(o) {
          var clone, result;
          clone = o.clone();
          return (result = IdentifierParameter(clone)) && NotColon(clone) && (o.update(clone), result);
        }
        function _mutator(param, o, i) {
          var ident, key;
          ident = param.ident;
          if (ident instanceof IdentNode) {
            key = o["const"](i, ident.name);
          } else if (ident instanceof AccessNode) {
            key = ident.child;
          } else {
            throw Error("Unknown object key type: " + __typeof(ident));
          }
          return { key: key, value: param };
        }
        return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
          var index, line, result;
          index = o.index;
          line = o.line;
          result = _rule(o);
          if (!result) {
            return false;
          } else {
            return _mutator(result, o, index, line);
          }
        });
      }()));
      KvpParameter = named("KvpParameter", function (o) {
        return ParamDualObjectKey(o) || ParamSingularObjectKey(o);
      });
      ObjectParameter = named("ObjectParameter", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = (function () {
            var _rule3;
            _rule3 = (function () {
              function _rule4(o) {
                var clone, result;
                clone = o.clone();
                return CommaOrNewline(clone) && (result = KvpParameter(clone)) && (o.update(clone), result);
              }
              return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "*", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = _rule4(clone)) {
                  result.push(item);
                }
                o.update(clone);
                return result;
              });
            }());
            return (function () {
              function _rule4(o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return (result.head = KvpParameter(clone)) && (result.tail = _rule3(clone)) && (o.update(clone), result);
              }
              function _mutator(x) {
                return [x.head].concat(__toArray(x.tail));
              }
              return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = _rule4(o);
                if (!result) {
                  return false;
                } else {
                  return _mutator(result, o, index, line);
                }
              });
            }());
          }());
          function _missing() {
            return [];
          }
          return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule2(o) || _missing(void 0, o, index, line);
          });
        }());
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return OpenCurlyBrace(clone) && EmptyLines(clone) && (result = _rule(clone)) && EmptyLines(clone) && MaybeCommaOrNewline(clone) && CloseCurlyBrace(clone) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.objectParam(i, x);
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      Parameters = named("Parameters", (function () {
        var _rule;
        _rule = (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return CommaOrNewline(clone) && (result = ParameterOrNothing(clone)) && (o.update(clone), result);
          }
          return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = _rule2(clone)) {
              result.push(item);
            }
            o.update(clone);
            return result;
          });
        }());
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.head = ParameterOrNothing(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return validateSpreadParameters(removeTrailingNothings([x.head].concat(__toArray(x.tail))), o);
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      ParameterSequence = named("ParameterSequence", (function () {
        var _rule;
        _rule = (function () {
          function _missing() {
            return [];
          }
          return named(__strnum(Parameters != null && Parameters.parserName || "Parameters") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return Parameters(o) || _missing(void 0, o, index, line);
          });
        }());
        return (function () {
          var _mutator;
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return OpenParenthesis(clone) && EmptyLines(clone) && (result = _rule(clone)) && EmptyLines(clone) && MaybeCommaOrNewline(clone) && CloseParenthesis(clone) && (o.update(clone), result);
          }
          _mutator = (function () {
            function check(names, duplicates, param) {
              var _arr, _i, element, name, pair;
              if (param instanceof ParamNode) {
                if (param.ident instanceof IdentNode) {
                  name = param.ident.name;
                } else if (param.ident instanceof AccessNode) {
                  if (!(param.ident.child instanceof ConstNode) || typeof param.ident.child.value !== "string") {
                    throw Error("Expected constant access: " + __typeof(param.ident.child));
                  }
                  name = param.ident.child.value;
                } else {
                  throw Error("Unknown param ident: " + __typeof(param.ident));
                }
                if (__in(name, names)) {
                  if (!__in(name, duplicates)) {
                    duplicates.push(name);
                  }
                } else {
                  names.push(name);
                }
              } else if (param instanceof ArrayNode) {
                for (_arr = __toArray(param.elements), _i = _arr.length; _i--; ) {
                  element = _arr[_i];
                  check(names, duplicates, element);
                }
              } else if (param instanceof ObjectNode) {
                for (_arr = __toArray(param.pairs), _i = _arr.length; _i--; ) {
                  pair = _arr[_i];
                  check(names, duplicates, pair.value);
                }
              } else if (!(param instanceof NothingNode)) {
                throw Error("Unknown param node: " + __typeof(param));
              }
            }
            return function (x, o, i) {
              var _arr, _i, duplicates, names, param;
              names = [];
              duplicates = [];
              for (_arr = __toArray(x), _i = _arr.length; _i--; ) {
                param = _arr[_i];
                check(names, duplicates, param);
              }
              if (duplicates.length) {
                o.error("Duplicate parameter name: " + __strnum(duplicates.sort().join(", ")));
              }
              return x;
            };
          }());
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      function addParamToScope(o, param) {
        var _arr, _i, _ref, element, pair;
        if (param instanceof ParamNode) {
          if ((_ref = param.ident) instanceof IdentNode || _ref instanceof TmpNode) {
            o.scope.add(param.ident, param.isMutable, param.asType ? nodeToType(param.asType) : param.spread ? Type.array : Type.any);
          } else if (param.ident instanceof AccessNode) {
            if (!(param.ident.child instanceof ConstNode) || typeof param.ident.child.value !== "string") {
              throw Error("Expected constant access: " + __typeof(param.ident.child));
            }
            o.scope.add(
              o.ident(param.startIndex, param.ident.child.value),
              param.isMutable,
              param.asType ? nodeToType(param.asType) : param.spread ? Type.array : Type.any
            );
          } else {
            throw Error("Unknown param ident: " + __typeof(param.ident));
          }
        } else if (param instanceof ArrayNode) {
          for (_arr = __toArray(param.elements), _i = _arr.length; _i--; ) {
            element = _arr[_i];
            addParamToScope(o, element);
          }
        } else if (param instanceof ObjectNode) {
          for (_arr = __toArray(param.pairs), _i = _arr.length; _i--; ) {
            pair = _arr[_i];
            addParamToScope(o, pair.value);
          }
        } else if (!(param instanceof NothingNode)) {
          throw Error("Unknown param node type: " + __typeof(param));
        }
      }
      _inGenerator = Stack(false);
      _FunctionBody = named("_FunctionBody", (function () {
        var _rule;
        _rule = (function () {
          var _rule2, _rule3;
          _rule2 = symbol("->");
          _rule3 = (function () {
            function _missing(x, o, i) {
              return o.nothing(i);
            }
            return named(__strnum(typeof Statement !== "undefined" && Statement !== null && Statement.parserName || "Statement") + "?", function (o) {
              var index, line;
              index = o.index;
              line = o.line;
              return Statement(o) || _missing(void 0, o, index, line);
            });
          }());
          return function (o) {
            var clone, result;
            clone = o.clone();
            return _rule2(clone) && (result = _rule3(clone)) && (o.update(clone), result);
          };
        }());
        return function (o) {
          return _rule(o) || Body(o);
        };
      }()));
      FunctionBody = named("FunctionBody", makeAlterStack(_inGenerator, false)(_FunctionBody));
      GeneratorFunctionBody = named("GeneratorFunctionBody", makeAlterStack(_inGenerator, true)(_FunctionBody));
      FunctionDeclaration = named("FunctionDeclaration", (function () {
        var paramsRule, restRule;
        paramsRule = (function () {
          function _missing() {
            return [];
          }
          return named(__strnum(ParameterSequence != null && ParameterSequence.parserName || "ParameterSequence") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return ParameterSequence(o) || _missing(void 0, o, index, line);
          });
        }());
        restRule = (function () {
          var _rule, _rule2, _rule3;
          _rule = inFunctionTypeParams(MaybeAsType);
          _rule2 = (function () {
            function _rule5(o) {
              if (o.data.charCodeAt(o.index) === 33) {
                o.index = __num(o.index) + 1;
                return 33;
              } else {
                o.fail('"!"');
                return false;
              }
            }
            return named(__strnum(_rule5 != null && _rule5.parserName || "<unknown>") + "?", function (o) {
              var index, line;
              index = o.index;
              line = o.line;
              return _rule5(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
            });
          }());
          _rule3 = named(__strnum(AtSign != null && AtSign.parserName || "AtSign") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return AtSign(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
          function _rule4(o) {
            var body, generator;
            generator = !!Asterix(o);
            if (generator) {
              body = GeneratorFunctionBody(o);
            } else {
              body = FunctionBody(o);
            }
            return body && { generator: generator, body: body };
          }
          return function (o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.asType = _rule(clone)) && (result.autoReturn = _rule2(clone)) && (result.bound = _rule3(clone)) && (result.generatorBody = _rule4(clone)) && (o.update(clone), result);
          };
        }());
        return function (o) {
          var _arr, _i, _ref, asType, autoReturn, body, bound, clone, generator, index, param, params, rest;
          index = o.index;
          clone = o.clone(o.cloneScope());
          params = paramsRule(clone);
          if (!params) {
            return false;
          }
          for (_arr = __toArray(params), _i = _arr.length; _i--; ) {
            param = _arr[_i];
            addParamToScope(clone, param);
          }
          rest = restRule(clone);
          if (!rest) {
            return false;
          }
          asType = rest.asType;
          autoReturn = rest.autoReturn;
          bound = rest.bound;
          generator = (_ref = rest.generatorBody).generator;
          body = _ref.body;
          if (autoReturn !== NOTHING && generator) {
            o.error("A function cannot be both non-returning and a generator");
          }
          o.update(clone);
          return o["function"](
            index,
            params,
            body,
            autoReturn === NOTHING,
            bound !== NOTHING,
            asType !== NOTHING ? asType : void 0,
            generator
          );
        };
      }()));
      FunctionLiteral = named("FunctionLiteral", (function () {
        function _backend(o) {
          var clone, result;
          clone = o.clone();
          return HashSign(clone) && (result = FunctionDeclaration(clone)) && (o.update(clone), result);
        }
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!HashSign(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      AssignmentAsExpression = cache(named("AssignmentAsExpression", inExpression(function (o) {
        return Assignment(o);
      })));
      ExpressionOrAssignment = named("ExpressionOrAssignment", function (o) {
        return AssignmentAsExpression(o) || Expression(o);
      });
      AstExpressionToken = cache(named("AstExpressionToken", word("ASTE")));
      AstExpression = named("AstExpression", (function () {
        var _backend;
        _backend = (function () {
          var _rule2;
          function _rule(o) {
            if (!_inMacro.peek()) {
              return o.error("Can only use AST inside a macro");
            } else if (_inAst.peek()) {
              return o.error("Cannot use AST inside an AST");
            } else {
              return true;
            }
          }
          _rule2 = inAst(ExpressionOrAssignment);
          return function (o) {
            var clone, result;
            clone = o.clone();
            return _rule(clone) && AstExpressionToken(clone) && (result = _rule2(clone)) && (o.update(clone), result);
          };
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!AstExpressionToken(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      AstToken = cache(named("AstToken", word("AST")));
      AstStatement = named("AstStatement", (function () {
        var _backend;
        _backend = (function () {
          var _rule2;
          function _rule(o) {
            if (!_inMacro.peek()) {
              return o.error("Can only use AST inside a macro");
            } else if (_inAst.peek()) {
              return o.error("Cannot use AST inside an AST");
            } else {
              return true;
            }
          }
          _rule2 = inAst(function (o) {
            return Body(o) || Statement(o) || Nothing(o);
          });
          return function (o) {
            var clone, result;
            clone = o.clone();
            return _rule(clone) && AstToken(clone) && (result = _rule2(clone)) && (o.update(clone), result);
          };
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!AstToken(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      Ast = named("Ast", (function () {
        function _rule(o) {
          return AstExpression(o) || AstStatement(o);
        }
        function _mutator(x, o, i) {
          return MacroHelper.constifyObject(x, i, o.index, o.scope.id);
        }
        return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
          var index, line, result;
          index = o.index;
          line = o.line;
          result = _rule(o);
          if (!result) {
            return false;
          } else {
            return _mutator(result, o, index, line);
          }
        });
      }()));
      MacroName = cache(named("MacroName", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = (function () {
            var _rule3;
            _rule3 = (function () {
              function _rule4(o) {
                return _Symbol(o) || _Name(o);
              }
              return (function () {
                var _rule5;
                _rule5 = named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "+", function (o) {
                  var clone, item, result;
                  clone = o.clone();
                  result = [];
                  while (item = _rule4(clone)) {
                    result.push(item);
                  }
                  if (result.length < 1) {
                    return false;
                  } else {
                    o.update(clone);
                    return result;
                  }
                });
                function _mutator(x) {
                  return x.join("");
                }
                return named(_rule5 != null && _rule5.parserName || "<unknown>", function (o) {
                  var index, line, result;
                  index = o.index;
                  line = o.line;
                  result = _rule5(o);
                  if (!result) {
                    return false;
                  } else {
                    return _mutator(result, o, index, line);
                  }
                });
              }());
            }());
            return function (o) {
              var clone, result;
              clone = o.clone();
              return (result = _rule3(clone)) && NotColon(clone) && (o.update(clone), result);
            };
          }());
          return function (o) {
            var clone, result;
            clone = o.clone();
            return Space(clone) && (result = _rule2(clone)) && (o.update(clone), result);
          };
        }());
        return function (o) {
          var clone, result;
          clone = o.clone();
          clone.preventFail();
          result = _rule(clone);
          clone.unpreventFail();
          if (result) {
            o.update(clone);
            return result;
          } else {
            o.fail("macro-name");
            return false;
          }
        };
      }())));
      MacroNames = named("MacroNames", (function () {
        var _rule;
        _rule = (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return Comma(clone) && (result = MacroName(clone)) && (o.update(clone), result);
          }
          return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = _rule2(clone)) {
              result.push(item);
            }
            o.update(clone);
            return result;
          });
        }());
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.head = MacroName(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return [x.head].concat(__toArray(x.tail));
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      UseMacro = named("UseMacro", function (o) {
        var clone, m, macros, name;
        clone = o.clone();
        macros = clone.macros;
        name = MacroName(clone);
        if (name) {
          m = macros.getByName(name);
          if (m) {
            return m(o);
          }
        }
        return false;
      });
      MacroSyntaxParameterType = named("MacroSyntaxParameterType", (function () {
        var _rule, _rule2;
        _rule = (function () {
          var _rule3, _rule4;
          _rule3 = (function () {
            function _rule5(o) {
              var clone, result;
              clone = o.clone();
              return OpenParenthesis(clone) && EmptyLines(clone) && (result = MacroSyntaxParameters(clone)) && EmptyLines(clone) && MaybeCommaOrNewline(clone) && CloseParenthesis(clone) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              return o.syntaxSequence(i, x);
            }
            return named(_rule5 != null && _rule5.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule5(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
          _rule4 = (function () {
            function _rule5(o) {
              var clone, result;
              clone = o.clone();
              return OpenParenthesis(clone) && EmptyLines(clone) && (result = MacroSyntaxChoiceParameters(clone)) && EmptyLines(clone) && CloseParenthesis(clone) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              return o.syntaxChoice(i, x);
            }
            return named(_rule5 != null && _rule5.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule5(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
          return function (o) {
            return Identifier(o) || StringLiteral(o) || _rule3(o) || _rule4(o);
          };
        }());
        _rule2 = (function () {
          var _rule3;
          _rule3 = (function () {
            var _rule4, _rule5, _rule6;
            _rule4 = symbol("?");
            _rule5 = symbol("*");
            _rule6 = symbol("+");
            return function (o) {
              return _rule4(o) || _rule5(o) || _rule6(o);
            };
          }());
          return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule3(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
        }());
        return (function () {
          function _rule3(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.type = _rule(clone)) && (result.multiplier = _rule2(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            if (x.multiplier === NOTHING) {
              return x.type;
            } else {
              return o.syntaxMany(i, x.type, x.multiplier);
            }
          }
          return named(_rule3 != null && _rule3.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule3(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      MacroSyntaxParameter = named("MacroSyntaxParameter", (function () {
        var _rule;
        _rule = (function () {
          var _rule3;
          function _rule2(o) {
            return ThisOrShorthandLiteral(o) || Identifier(o);
          }
          _rule3 = (function () {
            function _rule4(o) {
              var clone, result;
              clone = o.clone();
              return AsToken(clone) && (result = MacroSyntaxParameterType(clone)) && (o.update(clone), result);
            }
            return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "?", function (o) {
              var index, line;
              index = o.index;
              line = o.line;
              return _rule4(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
            });
          }());
          return (function () {
            function _rule4(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.ident = _rule2(clone)) && (result.type = _rule3(clone)) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              return o.syntaxParam(i, x.ident, x.type !== NOTHING ? x.type : void 0);
            }
            return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule4(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return function (o) {
          return StringLiteral(o) || _rule(o);
        };
      }()));
      MacroSyntaxParameters = named("MacroSyntaxParameters", (function () {
        var _rule;
        _rule = (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return Comma(clone) && (result = MacroSyntaxParameter(clone)) && (o.update(clone), result);
          }
          return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = _rule2(clone)) {
              result.push(item);
            }
            o.update(clone);
            return result;
          });
        }());
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.head = MacroSyntaxParameter(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
          }
          function _mutator(x) {
            return [x.head].concat(__toArray(x.tail));
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      MacroSyntaxChoiceParameters = named("MacroSyntaxChoiceParameters", (function () {
        var _rule;
        _rule = (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return Pipe(clone) && (result = MacroSyntaxParameterType(clone)) && (o.update(clone), result);
          }
          return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = _rule2(clone)) {
              result.push(item);
            }
            o.update(clone);
            return result;
          });
        }());
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.head = MacroSyntaxParameterType(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
          }
          function _mutator(x) {
            return [x.head].concat(__toArray(x.tail));
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      MacroOptions = named("MacroOptions", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = word("with");
          return (function () {
            function _rule3(o) {
              var clone, result;
              clone = o.clone();
              return _rule2(clone) && (result = UnclosedObjectLiteral(clone)) && (o.update(clone), result);
            }
            function _mutator(x) {
              var _arr, _i, _len, _ref, key, options, value;
              options = {};
              for (_arr = __toArray(x.pairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                key = (_ref = _arr[_i]).key;
                value = _ref.value;
                if (!key.isConst()) {
                  o.error("Cannot have non-const keys in the options");
                }
                if (!value.isConst()) {
                  o.error("Cannot have non-const value in the options");
                }
                options[key.constValue()] = value.constValue();
              }
              return options;
            }
            return named(_rule3 != null && _rule3.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule3(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        function _missing() {
          return {};
        }
        return named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "?", function (o) {
          var index, line;
          index = o.index;
          line = o.line;
          return _rule(o) || _missing(void 0, o, index, line);
        });
      }()));
      SyntaxToken = cache(named("SyntaxToken", word("syntax")));
      MacroSyntax = named("MacroSyntax", (function () {
        var _rule;
        _rule = (function () {
          var _backend;
          _backend = (function () {
            function _rule2(o) {
              var body, clone, i, options, params;
              i = o.index;
              clone = o.clone(o.cloneScope());
              params = MacroSyntaxParameters(clone);
              if (!params) {
                throw SHORT_CIRCUIT;
              }
              options = MacroOptions(clone);
              clone.startMacroSyntax(i, params, options);
              body = FunctionBody(clone);
              if (!body) {
                throw SHORT_CIRCUIT;
              }
              clone.macroSyntax(
                i,
                "syntax",
                params,
                options,
                body
              );
              o.update(clone);
              return true;
            }
            return function (o) {
              var clone, result;
              clone = o.clone();
              return SyntaxToken(clone) && (result = _rule2(clone)) && (o.update(clone), result);
            };
          }());
          return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
            var result;
            if (!SyntaxToken(o.clone())) {
              return false;
            } else {
              result = _backend(o);
              if (!result) {
                throw SHORT_CIRCUIT;
              }
              return result;
            }
          });
        }());
        return function (o) {
          var clone, result;
          clone = o.clone();
          return CheckIndent(clone) && (result = _rule(clone)) && Space(clone) && CheckStop(clone) && (o.update(clone), result);
        };
      }()));
      MacroBody = named("MacroBody", (function () {
        var _rule;
        _rule = (function () {
          var _rule3;
          _rule3 = (function () {
            var _rule4;
            _rule4 = (function () {
              function _rule5(o) {
                var clone, result;
                clone = o.clone();
                return Newline(clone) && EmptyLines(clone) && (result = MacroSyntax(clone)) && (o.update(clone), result);
              }
              return named(__strnum(_rule5 != null && _rule5.parserName || "<unknown>") + "*", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = _rule5(clone)) {
                  result.push(item);
                }
                o.update(clone);
                return result;
              });
            }());
            return function (o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return Advance(clone) && (result.head = MacroSyntax(clone)) && (result.tail = _rule4(clone)) && PopIndent(clone) && (o.update(clone), result);
            };
          }());
          return (function () {
            function _rule4(o) {
              var clone, result;
              clone = o.clone();
              return Space(clone) && Newline(clone) && EmptyLines(clone) && (result = _rule3(clone)) && (o.update(clone), result);
            }
            function _mutator(x) {
              return true;
            }
            return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule4(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        function _rule2(o) {
          var _arr, _i, body, clone, i, options, param, params;
          i = o.index;
          clone = o.clone(o.cloneScope());
          params = ParameterSequence(clone);
          if (!params) {
            return false;
          }
          for (_arr = __toArray(params), _i = _arr.length; _i--; ) {
            param = _arr[_i];
            addParamToScope(clone, param);
          }
          options = MacroOptions(clone);
          body = FunctionBody(clone);
          if (!body) {
            return false;
          }
          clone.macroSyntax(
            i,
            "call",
            params,
            options,
            body
          );
          o.update(clone);
          return true;
        }
        return function (o) {
          return _rule(o) || _rule2(o);
        };
      }()));
      MacroToken = cache(named("MacroToken", word("macro")));
      DefineMacro = named("DefineMacro", inMacro((function () {
        var _backend;
        _backend = (function () {
          var _rule;
          _rule = named("(identifier MacroBody)", function (o) {
            var names;
            names = MacroNames(o);
            if (names) {
              return o.enterMacro(names, function () {
                return MacroBody(o);
              });
            } else {
              return false;
            }
          });
          return (function () {
            function _rule2(o) {
              var clone;
              clone = o.clone();
              return MacroToken(clone) && _rule(clone) && (o.update(clone), true);
            }
            function _mutator(x, o, i) {
              return o.nothing(i);
            }
            return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule2(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!MacroToken(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }())));
      DefineSyntaxStart = cache(named("DefineSyntaxStart", (function () {
        var _rule, _rule2;
        _rule = word("define");
        _rule2 = word("syntax");
        return function (o) {
          var clone;
          clone = o.clone();
          return _rule(clone) && _rule2(clone) && (o.update(clone), true);
        };
      }())));
      DefineSyntax = named("DefineSyntax", (function () {
        var _backend;
        _backend = (function () {
          var _rule;
          _rule = named(__strnum(FunctionBody != null && FunctionBody.parserName || "FunctionBody") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return FunctionBody(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
          return (function () {
            function _rule2(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return DefineSyntaxStart(clone) && (result.name = Identifier(clone)) && DeclareEqualSymbol(clone) && (result.value = MacroSyntaxParameters(clone)) && (result.body = _rule(clone)) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              return o.defineSyntax(i, x.name.name, x.value, x.body !== NOTHING ? x.body : void 0);
            }
            return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule2(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!DefineSyntaxStart(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      DefineHelperStart = cache(named("DefineHelperStart", (function () {
        var _rule, _rule2;
        _rule = word("define");
        _rule2 = word("helper");
        return function (o) {
          var clone;
          clone = o.clone();
          return _rule(clone) && _rule2(clone) && (o.update(clone), true);
        };
      }())));
      DefineHelper = named("DefineHelper", (function () {
        var _backend;
        _backend = (function () {
          function _rule(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return DefineHelperStart(clone) && (result.name = Identifier(clone)) && DeclareEqualSymbol(clone) && (result.value = Expression(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.defineHelper(i, x.name, x.value);
          }
          return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!DefineHelperStart(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      DefineOperatorStart = cache(named("DefineOperatorStart", (function () {
        var _rule, _rule2;
        _rule = word("define");
        _rule2 = word("operator");
        return function (o) {
          var clone;
          clone = o.clone();
          return _rule(clone) && _rule2(clone) && (o.update(clone), true);
        };
      }())));
      DefineOperator = named("DefineOperator", (function () {
        var _backend;
        _backend = inMacro((function () {
          var mainRule, nodeType;
          mainRule = (function () {
            var _rule, _rule2;
            _rule = (function () {
              var _rule3, _rule4, _rule5;
              _rule3 = wordOrSymbol("binary");
              _rule4 = wordOrSymbol("assign");
              _rule5 = wordOrSymbol("unary");
              return function (o) {
                return _rule3(o) || _rule4(o) || _rule5(o);
              };
            }());
            _rule2 = (function () {
              function _rule3(o) {
                var clone, result;
                clone = o.clone();
                return Comma(clone) && (result = NameOrSymbol(clone)) && (o.update(clone), result);
              }
              return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "*", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = _rule3(clone)) {
                  result.push(item);
                }
                o.update(clone);
                return result;
              });
            }());
            return function (o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return DefineOperatorStart(clone) && (result.type = _rule(clone)) && (result.head = NameOrSymbol(clone)) && (result.tail = _rule2(clone)) && (result.options = MacroOptions(clone)) && (o.update(clone), result);
            };
          }());
          nodeType = Type.object.union(Type["undefined"]);
          return function (o) {
            var body, clone, i, ops, ret, x;
            i = o.index;
            x = mainRule(o);
            if (!x) {
              throw SHORT_CIRCUIT;
            }
            clone = o.clone(o.cloneScope());
            switch (x.type) {
            case "binary":
            case "assign":
              clone.scope.add(
                clone.ident(i, "left"),
                true,
                nodeType
              );
              clone.scope.add(
                clone.ident(i, "op"),
                true,
                Type.string
              );
              clone.scope.add(
                clone.ident(i, "right"),
                true,
                nodeType
              );
              break;
            case "unary":
              clone.scope.add(
                clone.ident(i, "op"),
                true,
                Type.string
              );
              clone.scope.add(
                clone.ident(i, "node"),
                true,
                nodeType
              );
              break;
            }
            body = FunctionBody(clone);
            if (!body) {
              throw SHORT_CIRCUIT;
            }
            ops = [x.head].concat(__toArray(x.tail));
            switch (x.type) {
            case "binary":
              ret = clone.defineBinaryOperator(i, ops, x.options, body);
              break;
            case "assign":
              ret = clone.defineAssignOperator(i, ops, x.options, body);
              break;
            case "unary":
              ret = clone.defineUnaryOperator(i, ops, x.options, body);
              break;
            default: throw Error();
            }
            o.update(clone);
            return ret;
          };
        }()));
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!DefineOperatorStart(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      Index = cache(named("Index", (function () {
        var ExpressionWithAsterixAsArrayLength;
        ExpressionWithAsterixAsArrayLength = named("ExpressionWithAsterixAsArrayLength", asterixAsArrayLength(function (o) {
          return Expression(o);
        }));
        return (function () {
          var _rule;
          _rule = (function () {
            function _rule2(o) {
              var clone, result;
              clone = o.clone();
              return CommaOrNewline(clone) && (result = ExpressionWithAsterixAsArrayLength(clone)) && (o.update(clone), result);
            }
            return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
              var clone, item, result;
              clone = o.clone();
              result = [];
              while (item = _rule2(clone)) {
                result.push(item);
              }
              o.update(clone);
              return result;
            });
          }());
          return (function () {
            function _rule2(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.head = ExpressionWithAsterixAsArrayLength(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
            }
            function _mutator(x) {
              if (__num(x.tail.length) > 0) {
                return { type: "multi", elements: [x.head].concat(__toArray(x.tail)) };
              } else {
                return { type: "single", node: x.head };
              }
            }
            return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule2(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
      }())));
      IdentifierOrAccessStart = named("IdentifierOrAccessStart", (function () {
        var _rule, _rule2, _rule3;
        _rule = (function () {
          function _rule4(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.parent = ThisOrShorthandLiteralPeriod(clone)) && (result.child = IdentifierNameConstOrNumberLiteral(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.access(i, x.parent, x.child);
          }
          return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule4(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        _rule2 = (function () {
          function _rule4(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.parent = ThisOrShorthandLiteral(clone)) && DoubleColon(clone) && (result.child = IdentifierNameConstOrNumberLiteral(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.access(
              i,
              o.access(i, x.parent, o["const"](i, "prototype")),
              x.child
            );
          }
          return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule4(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        _rule3 = (function () {
          var _rule4;
          _rule4 = named(__strnum(DoubleColon != null && DoubleColon.parserName || "DoubleColon") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return DoubleColon(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
          return (function () {
            function _rule5(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.parent = ThisOrShorthandLiteral(clone)) && (result.isProto = _rule4(clone)) && OpenSquareBracketChar(clone) && (result.child = Index(clone)) && CloseSquareBracket(clone) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              var parent;
              parent = x.parent;
              if (x.isProto !== NOTHING) {
                parent = o.access(i, parent, o["const"](i, "prototype"));
              }
              if (x.child.type === "single") {
                return o.access(i, parent, x.child.node);
              } else if (x.child.type === "multi") {
                return o.accessMulti(i, parent, x.child.elements);
              } else {
                throw Error();
              }
            }
            return named(_rule5 != null && _rule5.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule5(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return function (o) {
          return Identifier(o) || _rule(o) || _rule2(o) || _rule3(o);
        };
      }()));
      IdentifierOrAccessPart = named("IdentifierOrAccessPart", (function () {
        var _rule, _rule2;
        _rule = (function () {
          function _rule3(o) {
            return Period(o) || DoubleColon(o);
          }
          return (function () {
            function _rule4(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.type = _rule3(clone)) && (result.child = IdentifierNameConstOrNumberLiteral(clone)) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              return function (parent) {
                if (x.type === "::") {
                  parent = o.access(i, parent, o["const"](i, "prototype"));
                }
                return o.access(i, parent, x.child);
              };
            }
            return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule4(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        _rule2 = (function () {
          var _rule3;
          _rule3 = named(__strnum(DoubleColon != null && DoubleColon.parserName || "DoubleColon") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return DoubleColon(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
          return (function () {
            function _rule4(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.type = _rule3(clone)) && OpenSquareBracketChar(clone) && (result.child = Index(clone)) && CloseSquareBracket(clone) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              return function (parent) {
                if (x.type !== NOTHING) {
                  parent = o.access(i, parent, o["const"](i, "prototype"));
                }
                if (x.child.type === "single") {
                  return o.access(i, parent, x.child.node);
                } else if (x.child.type === "multi") {
                  return o.accessMulti(i, parent, x.child.elements);
                } else {
                  throw Error();
                }
              };
            }
            return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule4(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return function (o) {
          return _rule(o) || _rule2(o);
        };
      }()));
      IdentifierOrAccess = cache(named("IdentifierOrAccess", (function () {
        var _rule;
        _rule = named(__strnum(IdentifierOrAccessPart != null && IdentifierOrAccessPart.parserName || "IdentifierOrAccessPart") + "*", function (o) {
          var clone, item, result;
          clone = o.clone();
          result = [];
          while (item = IdentifierOrAccessPart(clone)) {
            result.push(item);
          }
          o.update(clone);
          return result;
        });
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.head = IdentifierOrAccessStart(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            var _arr, _i, _len, current, part;
            current = x.head;
            for (_arr = __toArray(x.tail), _i = 0, _len = _arr.length; _i < _len; ++_i) {
              part = _arr[_i];
              current = part(current);
            }
            return current;
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }())));
      SimpleAssignable = named("SimpleAssignable", IdentifierOrAccess);
      ComplexAssignable = named("ComplexAssignable", SimpleAssignable);
      DirectAssignment = named("DirectAssignment", (function () {
        function _rule(o) {
          if (o.data.charCodeAt(o.index) === 61) {
            o.index = __num(o.index) + 1;
            return 61;
          } else {
            o.fail('"="');
            return false;
          }
        }
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.left = ComplexAssignable(clone)) && Space(clone) && ColonChar(clone) && _rule(clone) && (result.right = ExpressionOrAssignment(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.assign(i, x.left, "=", x.right.doWrap(o));
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      CustomAssignment = named("CustomAssignment", function (o) {
        var _arr, _i, clone, left, line, op, operator, right, rule, startIndex, subClone;
        startIndex = o.index;
        line = o.line;
        clone = o.clone();
        left = SimpleAssignable(clone);
        if (left) {
          for (_arr = __toArray(o.macros.assignOperators), _i = _arr.length; _i--; ) {
            operator = _arr[_i];
            subClone = clone.clone();
            rule = operator.rule;
            op = rule(subClone);
            if (!op) {
              continue;
            }
            right = ExpressionOrAssignment(subClone);
            if (!right) {
              continue;
            }
            o.update(subClone);
            return operator.func(
              { left: left, op: op, right: right },
              o,
              startIndex,
              line
            );
          }
        }
        return false;
      });
      Assignment = cache(named("Assignment", function (o) {
        return DirectAssignment(o) || CustomAssignment(o);
      }));
      UnclosedObjectLiteral = named("UnclosedObjectLiteral", (function () {
        var _rule;
        _rule = (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return Comma(clone) && (result = PropertyOrDualObjectKey(clone)) && (o.update(clone), result);
          }
          return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = _rule2(clone)) {
              result.push(item);
            }
            o.update(clone);
            return result;
          });
        }());
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.head = PropertyOrDualObjectKey(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.object(i, [x.head].concat(__toArray(x.tail)));
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      IndentedUnclosedObjectLiteralInner = named("IndentedUnclosedObjectLiteralInner", (function () {
        var _rule;
        _rule = (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return CommaOrNewlineWithCheckIndent(clone) && (result = PropertyOrDualObjectKey(clone)) && (o.update(clone), result);
          }
          return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = _rule2(clone)) {
              result.push(item);
            }
            o.update(clone);
            return result;
          });
        }());
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.head = PropertyOrDualObjectKey(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.object(i, [x.head].concat(__toArray(x.tail)));
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      IndentedUnclosedObjectLiteral = named("IndentedUnclosedObjectLiteral", (function () {
        function _rule(o) {
          return !_preventUnclosedObjectLiteral.peek();
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return _rule(clone) && Space(clone) && Newline(clone) && EmptyLines(clone) && Advance(clone) && CheckIndent(clone) && (result = IndentedUnclosedObjectLiteralInner(clone)) && PopIndent(clone) && (o.update(clone), result);
        };
      }()));
      UnclosedArrayLiteralElement = named("UnclosedArrayLiteralElement", (function () {
        var _rule;
        _rule = (function () {
          var _rule2;
          _rule2 = (function () {
            var _rule3;
            _rule3 = PushFakeIndent(2);
            function _rule4(o) {
              return IndentedUnclosedObjectLiteralInner(o) || IndentedUnclosedArrayLiteralInner(o) || SpreadOrExpression(o);
            }
            return function (o) {
              var clone, result;
              clone = o.clone();
              return _rule3(clone) && (result = _rule4(clone)) && PopIndent(clone) && (o.update(clone), result);
            };
          }());
          return function (o) {
            return _rule2(o) || SpreadOrExpression(o);
          };
        }());
        return function (o) {
          var clone, result;
          clone = o.clone();
          return Asterix(clone) && Space(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }()));
      IndentedUnclosedArrayLiteralInner = named("IndentedUnclosedArrayLiteralInner", (function () {
        var _rule;
        _rule = (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            return MaybeComma(clone) && SomeEmptyLinesWithCheckIndent(clone) && (result = UnclosedArrayLiteralElement(clone)) && (o.update(clone), result);
          }
          return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
            var clone, item, result;
            clone = o.clone();
            result = [];
            while (item = _rule2(clone)) {
              result.push(item);
            }
            o.update(clone);
            return result;
          });
        }());
        return (function () {
          function _rule2(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.head = UnclosedArrayLiteralElement(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return o.array(i, [x.head].concat(__toArray(x.tail)));
          }
          return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule2(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      IndentedUnclosedArrayLiteral = named("IndentedUnclosedArrayLiteral", (function () {
        function _rule(o) {
          return !_preventUnclosedObjectLiteral.peek();
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return _rule(clone) && Space(clone) && Newline(clone) && EmptyLines(clone) && Advance(clone) && CheckIndent(clone) && (result = IndentedUnclosedArrayLiteralInner(clone)) && PopIndent(clone) && (o.update(clone), result);
        };
      }()));
      CURRENT_ARRAY_LENGTH_NAME = "__currentArrayLength";
      PrimaryExpression = cache(named("PrimaryExpression", (function () {
        function _rule(o) {
          var i;
          if (_asterixAsArrayLength.peek()) {
            i = o.index;
            if (Asterix(o)) {
              return o.ident(i, CURRENT_ARRAY_LENGTH_NAME);
            }
          }
        }
        return function (o) {
          return UnclosedObjectLiteral(o) || Literal(o) || ArrayLiteral(o) || ObjectLiteral(o) || Ast(o) || Parenthetical(o) || FunctionLiteral(o) || UseMacro(o) || Identifier(o) || _rule(o) || IndentedUnclosedObjectLiteral(o) || IndentedUnclosedArrayLiteral(o);
        };
      }())));
      ClosedArguments = named("ClosedArguments", (function () {
        var _rule, _rule2;
        _rule = (function () {
          var _rule3;
          _rule3 = (function () {
            var _rule4;
            _rule4 = (function () {
              function _rule5(o) {
                var clone, result;
                clone = o.clone();
                return Comma(clone) && (result = SpreadOrExpression(clone)) && (o.update(clone), result);
              }
              return named(__strnum(_rule5 != null && _rule5.parserName || "<unknown>") + "*", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = _rule5(clone)) {
                  result.push(item);
                }
                o.update(clone);
                return result;
              });
            }());
            return (function () {
              function _rule5(o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return (result.head = SpreadOrExpression(clone)) && (result.tail = _rule4(clone)) && MaybeComma(clone) && (o.update(clone), result);
              }
              function _mutator(x) {
                return [x.head].concat(__toArray(x.tail));
              }
              return named(_rule5 != null && _rule5.parserName || "<unknown>", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = _rule5(o);
                if (!result) {
                  return false;
                } else {
                  return _mutator(result, o, index, line);
                }
              });
            }());
          }());
          function _missing() {
            return [];
          }
          return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule3(o) || _missing(void 0, o, index, line);
          });
        }());
        _rule2 = (function () {
          var _rule3;
          _rule3 = (function () {
            var _rule4;
            _rule4 = (function () {
              var _rule5;
              _rule5 = (function () {
                var _rule6;
                _rule6 = (function () {
                  function _rule7(o) {
                    var clone, result;
                    clone = o.clone();
                    return CommaOrNewlineWithCheckIndent(clone) && (result = SpreadOrExpression(clone)) && (o.update(clone), result);
                  }
                  return named(__strnum(_rule7 != null && _rule7.parserName || "<unknown>") + "*", function (o) {
                    var clone, item, result;
                    clone = o.clone();
                    result = [];
                    while (item = _rule7(clone)) {
                      result.push(item);
                    }
                    o.update(clone);
                    return result;
                  });
                }());
                return (function () {
                  function _rule7(o) {
                    var clone, result;
                    clone = o.clone();
                    result = {};
                    return CheckIndent(clone) && (result.head = SpreadOrExpression(clone)) && (result.tail = _rule6(clone)) && (o.update(clone), result);
                  }
                  function _mutator(x) {
                    return [x.head].concat(__toArray(x.tail));
                  }
                  return named(_rule7 != null && _rule7.parserName || "<unknown>", function (o) {
                    var index, line, result;
                    index = o.index;
                    line = o.line;
                    result = _rule7(o);
                    if (!result) {
                      return false;
                    } else {
                      return _mutator(result, o, index, line);
                    }
                  });
                }());
              }());
              function _missing2() {
                return [];
              }
              return named(__strnum(_rule5 != null && _rule5.parserName || "<unknown>") + "?", function (o) {
                var index, line;
                index = o.index;
                line = o.line;
                return _rule5(o) || _missing2(void 0, o, index, line);
              });
            }());
            return function (o) {
              var clone, result;
              clone = o.clone();
              return SomeEmptyLines(clone) && MaybeAdvance(clone) && (result = _rule4(clone)) && EmptyLines(clone) && MaybeCommaOrNewline(clone) && PopIndent(clone) && (o.update(clone), result);
            };
          }());
          function _missing() {
            return [];
          }
          return named(__strnum(_rule3 != null && _rule3.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule3(o) || _missing(void 0, o, index, line);
          });
        }());
        return (function () {
          function _rule3(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return NoSpace(clone) && OpenParenthesis(clone) && Space(clone) && (result.first = _rule(clone)) && (result.rest = _rule2(clone)) && CloseParenthesis(clone) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return __toArray(x.first).concat(__toArray(x.rest));
          }
          return named(_rule3 != null && _rule3.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule3(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      UnclosedArguments = named("UnclosedArguments", (function () {
        var _rule, _rule2, _rule3;
        _rule = (function () {
          var _rule4;
          _rule4 = (function () {
            var _rule5;
            _rule5 = named(__strnum(SpaceChar != null && SpaceChar.parserName || "SpaceChar") + "+", function (o) {
              if (!SpaceChar(o)) {
                return false;
              } else {
                while (SpaceChar(o));
                return true;
              }
            });
            return function (o) {
              var clone;
              clone = o.clone();
              return _rule5(clone) && MaybeComment(clone) && (o.update(clone), true);
            };
          }());
          return function (o) {
            return _rule4(o) || CheckStop(o);
          };
        }());
        _rule2 = (function () {
          var _rule4;
          _rule4 = (function () {
            function _rule5(o) {
              var clone, result;
              clone = o.clone();
              return Comma(clone) && (result = SpreadOrExpression(clone)) && (o.update(clone), result);
            }
            return named(__strnum(_rule5 != null && _rule5.parserName || "<unknown>") + "*", function (o) {
              var clone, item, result;
              clone = o.clone();
              result = [];
              while (item = _rule5(clone)) {
                result.push(item);
              }
              o.update(clone);
              return result;
            });
          }());
          return (function () {
            function _rule5(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.head = SpreadOrExpression(clone)) && (result.tail = _rule4(clone)) && (o.update(clone), result);
            }
            function _mutator(x) {
              return [x.head].concat(__toArray(x.tail));
            }
            return named(_rule5 != null && _rule5.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule5(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        _rule3 = (function () {
          var _rule4, _rule5;
          _rule4 = (function () {
            var _rule6;
            _rule6 = (function () {
              function _rule7(o) {
                var clone, result;
                clone = o.clone();
                return CommaOrNewlineWithCheckIndent(clone) && (result = SpreadOrExpression(clone)) && (o.update(clone), result);
              }
              return named(__strnum(_rule7 != null && _rule7.parserName || "<unknown>") + "*", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = _rule7(clone)) {
                  result.push(item);
                }
                o.update(clone);
                return result;
              });
            }());
            return (function () {
              function _rule7(o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return Comma(clone) && SomeEmptyLines(clone) && Advance(clone) && CheckIndent(clone) && (result.head = SpreadOrExpression(clone)) && (result.tail = _rule6(clone)) && MaybeComma(clone) && PopIndent(clone) && (o.update(clone), result);
              }
              function _mutator(x) {
                return [x.head].concat(__toArray(x.tail));
              }
              return named(_rule7 != null && _rule7.parserName || "<unknown>", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = _rule7(o);
                if (!result) {
                  return false;
                } else {
                  return _mutator(result, o, index, line);
                }
              });
            }());
          }());
          _rule5 = (function () {
            function _mutator() {
              return [];
            }
            return named(MaybeComma != null && MaybeComma.parserName || "MaybeComma", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = MaybeComma(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
          return function (o) {
            return _rule4(o) || _rule5(o);
          };
        }());
        return (function () {
          function _rule4(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return _rule(clone) && (result.first = _rule2(clone)) && (result.rest = _rule3(clone)) && (o.update(clone), result);
          }
          function _mutator(x, o, i) {
            return __toArray(x.first).concat(__toArray(x.rest));
          }
          return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule4(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      InvocationArguments = cache(named("InvocationArguments", function (o) {
        return ClosedArguments(o) || UnclosedArguments(o);
      }));
      MaybeExclamationPointNoSpace = cache(named("MaybeExclamationPointNoSpace", (function () {
        var _rule;
        _rule = (function () {
          function _rule2(o) {
            if (o.data.charCodeAt(o.index) === 33) {
              o.index = __num(o.index) + 1;
              return 33;
            } else {
              o.fail('"!"');
              return false;
            }
          }
          return function (o) {
            var clone;
            clone = o.clone();
            return NoSpace(clone) && _rule2(clone) && (o.update(clone), "!");
          };
        }());
        return named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "?", function (o) {
          return _rule(o) || true;
        });
      }())));
      InvocationOrAccessPart = named("InvocationOrAccessPart", (function () {
        var _rule, _rule2, _rule3;
        _rule = (function () {
          var _rule4;
          _rule4 = named(__strnum(AtSign != null && AtSign.parserName || "AtSign") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return AtSign(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
          function _rule5(o) {
            return Period(o) || DoubleColon(o);
          }
          return (function () {
            function _rule6(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.existential = MaybeExistentialSymbolNoSpace(clone)) && (result.owns = MaybeExclamationPointNoSpace(clone)) && (result.bind = _rule4(clone)) && EmptyLines(clone) && Space(clone) && (result.type = _rule5(clone)) && (result.child = IdentifierNameConstOrNumberLiteral(clone)) && (o.update(clone), result);
            }
            function _mutator(x) {
              return {
                type: x.type === "::" ? "protoAccess" : "access",
                child: x.child,
                existential: x.existential === "?",
                owns: x.owns === "!",
                bind: x.bind !== NOTHING
              };
            }
            return named(_rule6 != null && _rule6.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule6(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        _rule2 = (function () {
          var _rule4, _rule5;
          _rule4 = named(__strnum(AtSign != null && AtSign.parserName || "AtSign") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return AtSign(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
          _rule5 = named(__strnum(DoubleColon != null && DoubleColon.parserName || "DoubleColon") + "?", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = DoubleColon(o);
            if (!result) {
              return "accessIndex";
            } else {
              return "protoAccessIndex";
            }
          });
          return (function () {
            function _rule6(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.existential = MaybeExistentialSymbolNoSpace(clone)) && (result.owns = MaybeExclamationPointNoSpace(clone)) && (result.bind = _rule4(clone)) && (result.type = _rule5(clone)) && OpenSquareBracketChar(clone) && (result.child = Index(clone)) && CloseSquareBracket(clone) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              if (x.child.type === "single") {
                return {
                  type: x.type === "accessIndex" ? "access" : "protoAccess",
                  child: x.child.node,
                  existential: x.existential === "?",
                  owns: x.owns === "!",
                  bind: x.bind !== NOTHING
                };
              } else {
                if (x.owns === "!") {
                  o.error("Cannot use ! when using a multiple or slicing index");
                }
                if (x.bind !== NOTHING) {
                  o.error("Cannot use @ when using a multiple or slicing index");
                }
                return { type: x.type, child: x.child, existential: x.existential === "?" };
              }
            }
            return named(_rule6 != null && _rule6.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule6(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        _rule3 = (function () {
          var _rule4;
          _rule4 = named(__strnum(AtSign != null && AtSign.parserName || "AtSign") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return AtSign(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
          return (function () {
            function _rule5(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.existential = MaybeExistentialSymbolNoSpace(clone)) && (result.isApply = _rule4(clone)) && (result.args = InvocationArguments(clone)) && (o.update(clone), result);
            }
            function _mutator(x) {
              return {
                type: "call",
                args: x.args,
                existential: x.existential === "?",
                isNew: false,
                isApply: x.isApply !== NOTHING
              };
            }
            return named(_rule5 != null && _rule5.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule5(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return function (o) {
          return _rule(o) || _rule2(o) || _rule3(o);
        };
      }()));
      convertInvocationOrAccess = (function () {
        var linkTypes;
        linkTypes = {
          access: (function () {
            var indexTypes;
            indexTypes = {
              multi: function (o, i, child) {
                return function (parent) {
                  var result, setParent, tmp, tmpIds;
                  setParent = parent;
                  tmpIds = [];
                  if (parent.cacheable) {
                    tmp = o.tmp(i, getTmpId(), "ref", parent.type(o));
                    tmpIds.push(tmp.id);
                    setParent = o.assign(i, tmp, "=", parent.doWrap(o));
                    parent = tmp;
                  }
                  result = o.array(i, (function () {
                    var _arr, _arr2, _len, element, j;
                    for (_arr = [], _arr2 = __toArray(child.elements), j = 0, _len = _arr2.length; j < _len; ++j) {
                      element = _arr2[j];
                      _arr.push(o.access(
                        i,
                        j === 0 ? setParent : parent,
                        element
                      ));
                    }
                    return _arr;
                  }()));
                  if (tmpIds.length) {
                    return o.tmpWrapper(i, result, tmpIds);
                  } else {
                    return result;
                  }
                };
              }
            };
            return function (o, i, head, link, j, links) {
              var bindAccess, child, existentialOp, makeAccess, result, setChild, setHead, tmp, tmpIds;
              if (link.bind) {
                bindAccess = function (parent, child) {
                  return o.call(
                    i,
                    o.ident(i, "__bind"),
                    [parent, child]
                  );
                };
              } else {
                bindAccess = function (parent, child) {
                  return o.access(i, parent, child);
                };
              }
              if (link.owns) {
                tmpIds = [];
                setHead = head;
                if (head.cacheable) {
                  tmp = o.tmp(i, getTmpId(), "ref", head.type(o));
                  tmpIds.push(tmp.id);
                  setHead = o.assign(i, tmp, "=", head.doWrap(o));
                  head = tmp;
                }
                child = link.child;
                setChild = child;
                if (child.cacheable) {
                  tmp = o.tmp(i, getTmpId(), "ref", child.type(o));
                  tmpIds.push(tmp.id);
                  setChild = o.assign(i, tmp, "=", child.doWrap(o));
                  child = tmp;
                }
                result = o["if"](
                  i,
                  (function () {
                    var existentialOp, ownershipOp;
                    ownershipOp = o.macros.getByLabel("ownership");
                    if (!ownershipOp) {
                      throw Error("Cannot use ownership access until the ownership operator has been defined");
                    }
                    if (link.existential) {
                      existentialOp = o.macros.getByLabel("existential");
                      if (!existentialOp) {
                        throw Error("Cannot use existential access until the existential operator has been defined");
                      }
                      return o.binary(
                        i,
                        existentialOp.func(
                          { op: "", node: setHead },
                          o,
                          i,
                          o.line
                        ),
                        "&&",
                        ownershipOp.func(
                          { left: head, op: "", right: setChild },
                          o,
                          i,
                          o.line
                        )
                      );
                    } else {
                      return ownershipOp.func(
                        { left: setHead, op: "", right: setChild },
                        o,
                        i,
                        o.line
                      );
                    }
                  }()),
                  convertCallChain(
                    o,
                    i,
                    bindAccess(head, child),
                    __num(j) + 1,
                    links
                  )
                );
                if (tmpIds.length) {
                  return o.tmpWrapper(i, result, tmpIds);
                } else {
                  return result;
                }
              } else {
                switch (link.type) {
                case "access":
                  makeAccess = function (parent) {
                    return bindAccess(parent, link.child);
                  };
                  break;
                case "accessIndex":
                  if (!__owns.call(indexTypes, link.child.type)) {
                    throw Error("Unknown index type: " + __strnum(link.child.type));
                  }
                  makeAccess = indexTypes[link.child.type](o, i, link.child);
                  break;
                default: throw Error("Unknown link type: " + __strnum(link.type));
                }
                if (link.existential) {
                  tmpIds = [];
                  setHead = head;
                  if (head.cacheable) {
                    tmp = o.tmp(i, getTmpId(), "ref", head.type(o));
                    tmpIds.push(tmp.id);
                    setHead = o.assign(i, tmp, "=", head.doWrap(o));
                    head = tmp;
                  }
                  existentialOp = o.macros.getByLabel("existential");
                  if (!existentialOp) {
                    throw Error("Cannot use existential access until the existential operator has been defined");
                  }
                  result = o["if"](
                    i,
                    existentialOp.func(
                      { op: "", node: setHead },
                      o,
                      i,
                      o.line
                    ),
                    convertCallChain(
                      o,
                      i,
                      makeAccess(head),
                      __num(j) + 1,
                      links
                    )
                  );
                  if (tmpIds.length) {
                    return o.tmpWrapper(i, result, tmpIds);
                  } else {
                    return result;
                  }
                } else {
                  return convertCallChain(
                    o,
                    i,
                    makeAccess(head),
                    __num(j) + 1,
                    links
                  );
                }
              }
            };
          }()),
          call: (function () {
            return function (o, i, head, link, j, links) {
              var child, parent, result, setChild, setHead, setParent, tmp, tmpIds;
              if (!link.existential) {
                return convertCallChain(
                  o,
                  i,
                  o.call(
                    i,
                    head,
                    link.args,
                    link.isNew,
                    link.isApply
                  ),
                  __num(j) + 1,
                  links
                );
              } else {
                tmpIds = [];
                setHead = head;
                if (head instanceof AccessNode && !link.isApply && !link.isNew) {
                  parent = head.parent;
                  child = head.child;
                  setParent = parent;
                  setChild = child;
                  if (parent.cacheable) {
                    tmp = o.tmp(i, getTmpId(), "ref", parent.type(o));
                    tmpIds.push(tmp.id);
                    setParent = o.assign(i, tmp, "=", parent.doWrap(o));
                    parent = tmp;
                  }
                  if (child.cacheable) {
                    tmp = o.tmp(i, getTmpId(), "ref", child.type(o));
                    tmpIds.push(tmp.id);
                    setChild = o.assign(i, tmp, "=", child.doWrap(o));
                    child = tmp;
                  }
                  if (parent !== setParent || child !== setChild) {
                    setHead = o.access(i, setParent, setChild);
                    head = o.access(i, parent, child);
                  }
                } else if (head.cacheable) {
                  tmp = o.tmp(i, getTmpId(), "ref", head.type(o));
                  tmpIds.push(tmp.id);
                  setHead = o.assign(i, tmp, "=", head.doWrap(o));
                  head = tmp;
                }
                result = o["if"](
                  i,
                  o.binary(
                    i,
                    o.unary(i, "typeof", setHead),
                    "===",
                    o["const"](i, "function")
                  ),
                  convertCallChain(
                    o,
                    i,
                    o.call(
                      i,
                      head,
                      link.args,
                      link.isNew,
                      link.isApply
                    ),
                    __num(j) + 1,
                    links
                  )
                );
                if (tmpIds.length) {
                  return o.tmpWrapper(i, result, tmpIds);
                } else {
                  return result;
                }
              }
            };
          }())
        };
        linkTypes.accessIndex = linkTypes.access;
        function convertCallChain(o, i, head, j, links) {
          var link;
          if (!__lt(j, links.length)) {
            return head;
          } else {
            link = links[j];
            if (!__owns.call(linkTypes, link.type)) {
              throw Error("Unknown call-chain link: " + __strnum(link.type));
            }
            return linkTypes[link.type](
              o,
              i,
              head,
              link,
              j,
              links
            );
          }
        }
        return function (isNew, head, tail, o, i) {
          var _arr, _i, _len, clone, links, part;
          if (tail.length === 0 && !isNew && head.type === "normal") {
            return head.node;
          }
          links = [];
          if (head.type === "thisAccess") {
            links.push({ type: "access", child: head.child, existential: head.existential });
          }
          for (_arr = __toArray(tail), _i = 0, _len = _arr.length; _i < _len; ++_i) {
            part = _arr[_i];
            switch (part.type) {
            case "protoAccess":
            case "protoAccessIndex":
              links.push({
                type: "access",
                child: o["const"](i, "prototype"),
                existential: part.existential
              });
              clone = copy(part);
              clone.type = part.type === "protoAccess" ? "access" : "accessIndex";
              links.push(clone);
              break;
            case "access":
            case "accessIndex":
              links.push(part);
              break;
            case "call":
              if (isNew && part.isApply) {
                o.error("Cannot call with both new and @ at the same time");
              }
              clone = copy(part);
              clone.isNew = isNew;
              isNew = false;
              links.push(clone);
              break;
            default: o.error("Unknown link type: " + __strnum(part.type));
            }
          }
          if (isNew) {
            links.push({
              type: "call",
              args: [],
              existential: false,
              isNew: true,
              isApply: false
            });
          }
          return convertCallChain(
            o,
            i,
            head.node,
            0,
            links
          );
        };
      }());
      BasicInvocationOrAccess = named("BasicInvocationOrAccess", (function () {
        var _rule, _rule2, _rule3;
        _rule = (function () {
          var _rule4;
          _rule4 = word("new");
          return named(__strnum(_rule4 != null && _rule4.parserName || "<unknown>") + "?", function (o) {
            var index, line;
            index = o.index;
            line = o.line;
            return _rule4(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
          });
        }());
        _rule2 = (function () {
          var _rule4, _rule5;
          _rule4 = (function () {
            var _rule6;
            _rule6 = named(__strnum(AtSign != null && AtSign.parserName || "AtSign") + "?", function (o) {
              var index, line;
              index = o.index;
              line = o.line;
              return AtSign(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
            });
            return (function () {
              function _rule7(o) {
                var clone, result;
                clone = o.clone();
                result = {};
                return (result.node = ThisShorthandLiteral(clone)) && (result.existential = MaybeExistentialSymbolNoSpace(clone)) && (result.owns = MaybeExclamationPointNoSpace(clone)) && (result.bind = _rule6(clone)) && (result.child = IdentifierNameConstOrNumberLiteral(clone)) && (o.update(clone), result);
              }
              function _mutator(x, o, i) {
                return {
                  type: "thisAccess",
                  node: x.node,
                  child: x.child,
                  existential: x.existential === "?",
                  owns: x.owns === "!",
                  bind: x.bind !== NOTHING
                };
              }
              return named(_rule7 != null && _rule7.parserName || "<unknown>", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = _rule7(o);
                if (!result) {
                  return false;
                } else {
                  return _mutator(result, o, index, line);
                }
              });
            }());
          }());
          _rule5 = (function () {
            function _mutator(x) {
              return { type: "normal", node: x };
            }
            return named(PrimaryExpression != null && PrimaryExpression.parserName || "PrimaryExpression", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = PrimaryExpression(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
          return function (o) {
            return _rule4(o) || _rule5(o);
          };
        }());
        _rule3 = named(__strnum(InvocationOrAccessPart != null && InvocationOrAccessPart.parserName || "InvocationOrAccessPart") + "*", function (o) {
          var clone, item, result;
          clone = o.clone();
          result = [];
          while (item = InvocationOrAccessPart(clone)) {
            result.push(item);
          }
          o.update(clone);
          return result;
        });
        return (function () {
          function _rule4(o) {
            var clone, result;
            clone = o.clone();
            result = {};
            return (result.isNew = _rule(clone)) && (result.head = _rule2(clone)) && (result.tail = _rule3(clone)) && (o.update(clone), result);
          }
          function _mutator(_p, o, i) {
            var head, isNew, tail;
            isNew = _p.isNew;
            head = _p.head;
            tail = _p.tail;
            return convertInvocationOrAccess(
              isNew !== NOTHING,
              head,
              tail,
              o,
              i
            );
          }
          return named(_rule4 != null && _rule4.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule4(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
      }()));
      SuperToken = cache(named("SuperToken", word("super")));
      SuperInvocation = named("SuperInvocation", (function () {
        var _backend;
        _backend = (function () {
          var _rule;
          _rule = (function () {
            var _rule2;
            _rule2 = (function () {
              function _rule3(o) {
                var clone, result;
                clone = o.clone();
                return EmptyLines(clone) && Space(clone) && Period(clone) && (result = IdentifierNameConstOrNumberLiteral(clone)) && (o.update(clone), result);
              }
              function _rule4(o) {
                var clone, result;
                clone = o.clone();
                return OpenSquareBracketChar(clone) && (result = Expression(clone)) && CloseSquareBracket(clone) && (o.update(clone), result);
              }
              return function (o) {
                return _rule3(o) || _rule4(o);
              };
            }());
            return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "?", function (o) {
              var index, line;
              index = o.index;
              line = o.line;
              return _rule2(o) || (typeof NOTHING === "function" ? NOTHING(void 0, o, index, line) : NOTHING);
            });
          }());
          return (function () {
            function _rule2(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return SuperToken(clone) && (result.child = _rule(clone)) && (result.args = InvocationArguments(clone)) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              return o["super"](
                i,
                x.child !== NOTHING ? x.child : void 0,
                x.args
              );
            }
            return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule2(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!SuperToken(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      EvalToken = cache(named("EvalToken", word("eval")));
      Eval = named("Eval", (function () {
        var _backend;
        _backend = (function () {
          function _rule(o) {
            var clone, result;
            clone = o.clone();
            return EvalToken(clone) && (result = InvocationArguments(clone)) && (o.update(clone), result);
          }
          function _mutator(args, o, i) {
            if (args.length !== 1) {
              o.error("Expected only one argument to eval");
            }
            return o["eval"](i, args[0]);
          }
          return named(_rule != null && _rule.parserName || "<unknown>", function (o) {
            var index, line, result;
            index = o.index;
            line = o.line;
            result = _rule(o);
            if (!result) {
              return false;
            } else {
              return _mutator(result, o, index, line);
            }
          });
        }());
        return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
          var result;
          if (!EvalToken(o.clone())) {
            return false;
          } else {
            result = _backend(o);
            if (!result) {
              throw SHORT_CIRCUIT;
            }
            return result;
          }
        });
      }()));
      InvocationOrAccess = named("InvocationOrAccess", (function () {
        function _rule(o) {
          var args, clone, i;
          if (_inAst.peek()) {
            i = o.index;
            clone = o.clone();
            Space(clone);
            if (!DollarSign(clone)) {
              return false;
            }
            _inAst.push(false);
            try {
              args = InvocationArguments(clone);
              if (!args) {
                return false;
              }
              o.update(clone);
              return o.call(
                i,
                o.ident(i, "$"),
                args
              );
            } finally {
              _inAst.pop();
            }
          }
        }
        return function (o) {
          return _rule(o) || BasicInvocationOrAccess(o) || SuperInvocation(o) || Eval(o);
        };
      }()));
      CustomPostfixUnary = named("CustomPostfixUnary", function (o) {
        var _arr, _i, clone, line, node, op, operator, rule, startIndex;
        startIndex = o.index;
        line = o.line;
        node = InvocationOrAccess(o);
        if (!node) {
          return false;
        } else {
          for (_arr = __toArray(o.macros.postfixUnaryOperators), _i = _arr.length; _i--; ) {
            operator = _arr[_i];
            clone = o.clone();
            rule = operator.rule;
            op = rule(clone);
            if (!op) {
              continue;
            }
            o.update(clone);
            return operator.func(
              { op: op, node: node },
              o,
              startIndex,
              line
            );
          }
          return node;
        }
      });
      CustomPrefixUnary = named("CustomPrefixUnary", function (o) {
        var _arr, _i, clone, line, node, op, operator, rule, startIndex;
        startIndex = o.index;
        line = o.line;
        for (_arr = __toArray(o.macros.prefixUnaryOperators), _i = _arr.length; _i--; ) {
          operator = _arr[_i];
          clone = o.clone();
          rule = operator.rule;
          op = rule(clone);
          if (!op) {
            continue;
          }
          node = CustomPrefixUnary(clone);
          if (!node) {
            continue;
          }
          o.update(clone);
          return operator.func(
            { op: op, node: node },
            o,
            startIndex,
            line
          );
        }
        return CustomPostfixUnary(o);
      });
      getUseCustomBinaryOperator = (function () {
        var precedenceCache;
        precedenceCache = [];
        return function (precedence) {
          var _ref;
          if ((_ref = precedenceCache[precedence]) == null) {
            return precedenceCache[precedence] = cache(function (o) {
              var _arr, _i, _i2, _len, binaryOperators, clone, head, inverted, j, left, line, nextRule, node, op, operator, operators, part, right, rule, startIndex, tail;
              startIndex = o.index;
              line = o.line;
              binaryOperators = o.macros.binaryOperators;
              if (__lt(binaryOperators.length, precedence)) {
                return CustomPrefixUnary(o);
              } else {
                nextRule = getUseCustomBinaryOperator(__num(precedence) + 1);
                head = nextRule(o);
                if (!head) {
                  return false;
                } else {
                  operators = binaryOperators[precedence];
                  if (operators) {
                    for (_arr = __toArray(operators), _i = _arr.length; _i--; ) {
                      operator = _arr[_i];
                      rule = operator.rule;
                      tail = [];
                      while (true) {
                        clone = o.clone();
                        inverted = false;
                        if (operator.invertible) {
                          inverted = MaybeNotToken(clone);
                          if (!inverted) {
                            break;
                          }
                        }
                        op = rule(clone);
                        if (!op) {
                          break;
                        }
                        node = nextRule(clone);
                        if (!node) {
                          break;
                        }
                        o.update(clone);
                        tail.push({ inverted: inverted === "not", op: op, node: node });
                        if (operator.maximum && tail.length >= __num(operator.maximum)) {
                          break;
                        }
                      }
                      if (tail.length) {
                        if (!operator.rightToLeft) {
                          left = head;
                          for (_i2 = 0, _len = tail.length; _i2 < _len; ++_i2) {
                            part = tail[_i2];
                            left = operator.func(
                              { left: left, inverted: part.inverted, op: part.op, right: part.node },
                              o,
                              startIndex,
                              line
                            );
                          }
                          return left;
                        } else {
                          right = tail[tail.length - 1].node;
                          for (j = tail.length; j--; ) {
                            part = tail[j];
                            right = operator.func(
                              {
                                left: j === 0 ? head : tail[j - 1].node,
                                inverted: part.inverted,
                                op: part.op,
                                right: right
                              },
                              o,
                              startIndex,
                              line
                            );
                          }
                          return right;
                        }
                      }
                    }
                  }
                  return head;
                }
              }
            });
          } else {
            return _ref;
          }
        };
      }());
      Logic = named("Logic", getUseCustomBinaryOperator(0));
      ExpressionAsStatement = named("ExpressionAsStatement", function (o) {
        return UseMacro(o) || Logic(o);
      });
      Expression = cache(named("Expression", inExpression(ExpressionAsStatement)));
      Statement = named("Statement", (function () {
        var _rule;
        _rule = inStatement(function (o) {
          return DefineMacro(o) || DefineHelper(o) || DefineOperator(o) || DefineSyntax(o) || Assignment(o) || ExpressionAsStatement(o);
        });
        return function (o) {
          var clone, result;
          clone = o.clone();
          return (result = _rule(clone)) && Space(clone) && (o.update(clone), result);
        };
      }()));
      Line = named("Line", (function () {
        function _rule(o) {
          return LicenseComment(o) || Statement(o);
        }
        return function (o) {
          var clone, result;
          clone = o.clone();
          return CheckIndent(clone) && (result = _rule(clone)) && (o.update(clone), result);
        };
      }()));
      _Block = (function () {
        var runSync;
        function mutator(lines, o, i) {
          var _arr, _i, _len, item, nodes;
          nodes = [];
          for (_arr = __toArray(lines), _i = 0, _len = _arr.length; _i < _len; ++_i) {
            item = _arr[_i];
            if (item instanceof BlockNode && item.label == null) {
              nodes.push.apply(nodes, __toArray(item.nodes));
            } else if (!(item instanceof NothingNode)) {
              nodes.push(item);
            }
          }
          switch (nodes.length) {
          case 0: return o.nothing(i);
          case 1: return nodes[0];
          default:
            return o.block(i, nodes);
          }
        }
        runSync = (function () {
          var _rule;
          _rule = (function () {
            function _rule2(o) {
              var clone, result;
              clone = o.clone();
              return Newline(clone) && EmptyLines(clone) && (result = Line(clone)) && (o.update(clone), result);
            }
            return named(__strnum(_rule2 != null && _rule2.parserName || "<unknown>") + "*", function (o) {
              var clone, item, result;
              clone = o.clone();
              result = [];
              while (item = _rule2(clone)) {
                result.push(item);
              }
              o.update(clone);
              return result;
            });
          }());
          return (function () {
            function _rule2(o) {
              var clone, result;
              clone = o.clone();
              result = {};
              return (result.head = Line(clone)) && (result.tail = _rule(clone)) && (o.update(clone), result);
            }
            function _mutator(x, o, i) {
              return mutator([x.head].concat(__toArray(x.tail)), o, i);
            }
            return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
              var index, line, result;
              index = o.index;
              line = o.line;
              result = _rule2(o);
              if (!result) {
                return false;
              } else {
                return _mutator(result, o, index, line);
              }
            });
          }());
        }());
        function runAsync(o, callback) {
          var head, i, lines;
          i = o.index;
          try {
            head = Line(o);
          } catch (e) {
            return callback(e);
          }
          if (!head) {
            return callback(null, head);
          }
          lines = [head];
          function next() {
            var clone, line, startTime;
            try {
              startTime = new Date().getTime();
              while (true) {
                if (__num(new Date().getTime()) - __num(startTime) > 17) {
                  return nextTick(next);
                }
                clone = o.clone();
                if (!Newline(clone) || !EmptyLines(clone)) {
                  break;
                }
                line = Line(clone);
                if (!line) {
                  break;
                }
                o.update(clone);
                lines.push(line);
              }
            } catch (e) {
              return callback(e);
            }
            return callback(null, mutator(lines, o, i));
          }
          return next();
        }
        return function (o, callback) {
          if (callback != null) {
            return runAsync(o, callback);
          } else {
            return runSync(o);
          }
        };
      }());
      Block = named("Block", (function () {
        function _rule(o) {
          var clone, result;
          clone = o.clone();
          return CheckIndent(clone) && (result = IndentedUnclosedObjectLiteralInner(clone)) && (o.update(clone), result);
        }
        function _rule2(o) {
          var clone, result;
          clone = o.clone();
          return CheckIndent(clone) && (result = IndentedUnclosedArrayLiteralInner(clone)) && (o.update(clone), result);
        }
        return function (o) {
          return _rule(o) || _rule2(o) || _Block(o);
        };
      }()));
      BOM = (function () {
        function _rule(o) {
          if (o.data.charCodeAt(o.index) === 65279) {
            o.index = __num(o.index) + 1;
            return 65279;
          } else {
            o.fail('"\ufeff"');
            return false;
          }
        }
        return named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "?", function (o) {
          return _rule(o) || true;
        });
      }());
      Shebang = (function () {
        var _rule;
        _rule = (function () {
          var _rule4;
          function _rule2(o) {
            if (o.data.charCodeAt(o.index) === 35) {
              o.index = __num(o.index) + 1;
              return 35;
            } else {
              o.fail('"#"');
              return false;
            }
          }
          function _rule3(o) {
            if (o.data.charCodeAt(o.index) === 33) {
              o.index = __num(o.index) + 1;
              return 33;
            } else {
              o.fail('"!"');
              return false;
            }
          }
          _rule4 = (function () {
            var _rule5;
            _rule5 = named("!" + __strnum(Newline != null && Newline.parserName || "Newline"), function (o) {
              return !Newline(o.clone()) && AnyChar(o);
            });
            return named(__strnum(_rule5 != null && _rule5.parserName || "<unknown>") + "*", function (o) {
              var clone, item, result;
              clone = o.clone();
              result = [];
              while (item = _rule5(clone)) {
                result.push(item);
              }
              o.update(clone);
              return result;
            });
          }());
          return function (o) {
            var clone;
            clone = o.clone();
            return _rule2(clone) && _rule3(clone) && _rule4(clone) && (o.update(clone), true);
          };
        }());
        return named(__strnum(_rule != null && _rule.parserName || "<unknown>") + "?", function (o) {
          return _rule(o) || true;
        });
      }());
      function Root(o, callback) {
        var i;
        o.clearCache();
        i = o.index;
        BOM(o);
        Shebang(o);
        EmptyLines(o);
        function next(block) {
          var result, x;
          x = block || o.nothing(i);
          EmptyLines(o);
          Space(o);
          result = o.root(i, x);
          o.clearCache();
          if (callback != null) {
            return callback(null, result);
          } else {
            return result;
          }
        }
        if (callback != null) {
          return _Block(o, function (err, block) {
            if (err != null) {
              o.clearCache();
              return callback(err);
            }
            return next(block);
          });
        } else {
          return next(_Block(o));
        }
      }
      ParserError = (function (Error) {
        var _Error_prototype, _ParserError_prototype;
        function ParserError(message, text, index, line) {
          var _this, err;
          _this = this instanceof ParserError ? this : __create(_ParserError_prototype);
          if (typeof message !== "string") {
            throw TypeError("Expected message to be a String, got " + __typeof(message));
          }
          if (typeof text !== "string") {
            throw TypeError("Expected text to be a String, got " + __typeof(text));
          }
          if (typeof index !== "number") {
            throw TypeError("Expected index to be a Number, got " + __typeof(index));
          }
          if (typeof line !== "number") {
            throw TypeError("Expected line to be a Number, got " + __typeof(line));
          }
          err = Error.call(_this, message + " at line #" + line);
          _this.message = err.message;
          if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(_this, ParserError);
          } else if ("stack" in err) {
            _this.stack = err.stack;
          }
          _this.text = text;
          _this.index = index;
          _this.line = line;
          return _this;
        }
        _Error_prototype = Error.prototype;
        _ParserError_prototype = ParserError.prototype = __create(_Error_prototype);
        _ParserError_prototype.constructor = ParserError;
        ParserError.displayName = "ParserError";
        _ParserError_prototype.name = ParserError.name;
        return ParserError;
      }(Error));
      MacroError = (function (Error) {
        var _Error_prototype, _MacroError_prototype;
        function MacroError(inner, text, index, line) {
          var _this, err, innerType;
          _this = this instanceof MacroError ? this : __create(_MacroError_prototype);
          if (!(inner instanceof Error)) {
            throw TypeError("Expected inner to be an Error, got " + __typeof(inner));
          }
          if (typeof text !== "string") {
            throw TypeError("Expected text to be a String, got " + __typeof(text));
          }
          if (typeof index !== "number") {
            throw TypeError("Expected index to be a Number, got " + __typeof(index));
          }
          if (typeof line !== "number") {
            throw TypeError("Expected line to be a Number, got " + __typeof(line));
          }
          innerType = __typeof(inner);
          err = Error.call(_this, (innerType === "Error" ? "" : innerType + ": ") + String(inner != null ? inner.message : void 0) + " at line #" + line);
          _this.message = err.message;
          if ("stack" in inner && typeof inner.stack === "string") {
            _this.stack = "MacroError: " + __strnum(inner.stack);
          } else if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(_this, MacroError);
          } else if ("stack" in err) {
            _this.stack = err.stack;
          }
          _this.inner = inner;
          _this.text = text;
          _this.index = index;
          _this.line = line;
          return _this;
        }
        _Error_prototype = Error.prototype;
        _MacroError_prototype = MacroError.prototype = __create(_Error_prototype);
        _MacroError_prototype.constructor = MacroError;
        MacroError.displayName = "MacroError";
        _MacroError_prototype.name = MacroError.name;
        return MacroError;
      }(Error));
      function map(array, func, arg) {
        var _arr, _i, _len, changed, item, newItem, result;
        result = [];
        changed = false;
        for (_arr = __toArray(array), _i = 0, _len = _arr.length; _i < _len; ++_i) {
          item = _arr[_i];
          newItem = func(item, arg);
          result.push(newItem);
          if (item !== newItem) {
            changed = true;
          }
        }
        if (changed) {
          return result;
        } else {
          return array;
        }
      }
      function mapAsync(array, func) {
        var _ref, args, callback, changed;
        args = 2 < (_ref = arguments.length - 1) ? __slice.call(arguments, 2, _ref) : (_ref = 2, []);
        callback = arguments[_ref];
        changed = false;
        return __asyncResult(
          1,
          __num(array.length),
          function (_i, next) {
            var item;
            item = array[_i];
            return func.apply(void 0, [item].concat(__toArray(args), [
              function (_e, newItem) {
                if (_e != null) {
                  return next(_e);
                }
                if (item !== newItem) {
                  changed = true;
                }
                return next(null, newItem);
              }
            ]));
          },
          function (err, result) {
            if (typeof err !== "undefined" && err !== null) {
              return callback(err);
            } else {
              return callback(null, changed ? result : array);
            }
          }
        );
      }
      FailureManager = (function () {
        var _FailureManager_prototype;
        function FailureManager() {
          var _this;
          _this = this instanceof FailureManager ? this : __create(_FailureManager_prototype);
          _this.messages = [];
          _this.index = 0;
          _this.line = 0;
          return _this;
        }
        _FailureManager_prototype = FailureManager.prototype;
        FailureManager.displayName = "FailureManager";
        _FailureManager_prototype.add = function (message, index, line) {
          if (!__lte(index, this.index)) {
            this.messages = [];
            this.index = index;
          }
          if (__lt(this.line, line)) {
            this.line = line;
          }
          if (!__lt(index, this.index)) {
            this.messages.push(message);
          }
        };
        return FailureManager;
      }());
      nodeToType = (function () {
        var identToType;
        identToType = {
          Boolean: Type.boolean,
          String: Type.string,
          Number: Type.number,
          Array: Type.array,
          Object: Type.object,
          Function: Type["function"],
          RegExp: Type.regexp,
          Date: Type.date,
          Error: Type.error,
          RangeError: Type.error,
          ReferenceError: Type.error,
          SyntaxError: Type.error,
          TypeError: Type.error,
          URIError: Type.error
        };
        return function (node) {
          var _arr, _i, _len, _ref, current, data, key, type, value;
          if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          if (node instanceof IdentNode) {
            return (__owns.call(identToType, _ref = node.name) ? identToType[_ref] : void 0) || Type.any;
          } else if (node instanceof ConstNode) {
            if (node.value === null) {
              return Type["null"];
            } else if (node.value === void 0) {
              return Type["undefined"];
            } else {
              return Type.any;
            }
          } else if (node instanceof TypeArrayNode) {
            return nodeToType(node.subtype).array();
          } else if (node instanceof TypeFunctionNode) {
            return nodeToType(node.returnType)["function"]();
          } else if (node instanceof TypeUnionNode) {
            current = Type.none;
            for (_arr = __toArray(node.types), _i = _arr.length; _i--; ) {
              type = _arr[_i];
              current = current.union(nodeToType(type));
            }
            return current;
          } else if (node instanceof TypeObjectNode) {
            data = {};
            for (_arr = __toArray(node.pairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
              key = (_ref = _arr[_i]).key;
              value = _ref.value;
              if (key instanceof ConstNode) {
                data[key.value] = nodeToType(value);
              }
            }
            return Type.makeObject(data);
          } else {
            return Type.any;
          }
        };
      }());
      MacroHelper = (function () {
        var _MacroHelper_prototype, mutators;
        function MacroHelper(state, index, position, inGenerator) {
          var _this;
          _this = this instanceof MacroHelper ? this : __create(_MacroHelper_prototype);
          if (!(state instanceof State)) {
            throw TypeError("Expected state to be a State, got " + __typeof(state));
          }
          _this.unsavedTmps = [];
          _this.savedTmps = [];
          _this.state = state;
          _this.index = index;
          _this.position = position;
          _this.inGenerator = inGenerator;
          return _this;
        }
        _MacroHelper_prototype = MacroHelper.prototype;
        MacroHelper.displayName = "MacroHelper";
        _MacroHelper_prototype.doWrap = function (node) {
          if (node instanceof Node) {
            return node.doWrap(this.state);
          } else {
            return node;
          }
        };
        _MacroHelper_prototype["let"] = function (ident, isMutable, type) {
          if (!(ident instanceof TmpNode) && !(ident instanceof IdentNode)) {
            throw TypeError("Expected ident to be a TmpNode or IdentNode, got " + __typeof(ident));
          }
          if (isMutable == null) {
            isMutable = false;
          } else if (typeof isMutable !== "boolean") {
            throw TypeError("Expected isMutable to be a Boolean, got " + __typeof(isMutable));
          }
          if (type == null) {
            type = Type.any;
          } else if (!(type instanceof Type)) {
            throw TypeError("Expected type to be a Type, got " + __typeof(type));
          }
          if (ident instanceof IdentNode && isMutable && type.isSubsetOf(Type.undefinedOrNull)) {
            type = Type.any;
          }
          return this.state.scope.add(ident, isMutable, type);
        };
        _MacroHelper_prototype.hasVariable = function (ident) {
          if (!(ident instanceof TmpNode) && !(ident instanceof IdentNode)) {
            throw TypeError("Expected ident to be a TmpNode or IdentNode, got " + __typeof(ident));
          }
          return this.state.scope.has(ident);
        };
        _MacroHelper_prototype["var"] = function (ident, isMutable) {
          if (!(ident instanceof IdentNode) && !(ident instanceof TmpNode)) {
            throw TypeError("Expected ident to be an IdentNode or TmpNode, got " + __typeof(ident));
          }
          if (isMutable == null) {
            isMutable = false;
          } else if (typeof isMutable !== "boolean") {
            throw TypeError("Expected isMutable to be a Boolean, got " + __typeof(isMutable));
          }
          return this.state["var"](this.index, ident, isMutable);
        };
        _MacroHelper_prototype.def = function (key, value) {
          if (key == null) {
            key = NothingNode(0, 0, this.state.scope.id);
          } else if (!(key instanceof Node)) {
            throw TypeError("Expected key to be a Node, got " + __typeof(key));
          }
          if (value == null) {
            value = void 0;
          } else if (!(value instanceof Node)) {
            throw TypeError("Expected value to be a Node or undefined, got " + __typeof(value));
          }
          return this.state.def(this.index, key, this.doWrap(value));
        };
        _MacroHelper_prototype.noop = function () {
          return this.state.nothing(this.index);
        };
        _MacroHelper_prototype.block = function (nodes, label) {
          var _i, _len;
          if (!__isArray(nodes)) {
            throw TypeError("Expected nodes to be an Array, got " + __typeof(nodes));
          } else {
            for (_i = 0, _len = nodes.length; _i < _len; ++_i) {
              if (!(nodes[_i] instanceof Node)) {
                throw TypeError("Expected nodes[" + _i + "] to be a Node, got " + __typeof(nodes[_i]));
              }
            }
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return this.state.block(this.index, nodes, label).reduce(this.state);
        };
        _MacroHelper_prototype["if"] = function (test, whenTrue, whenFalse, label) {
          if (test == null) {
            test = NothingNode(0, 0, this.state.scope.id);
          } else if (!(test instanceof Node)) {
            throw TypeError("Expected test to be a Node, got " + __typeof(test));
          }
          if (whenTrue == null) {
            whenTrue = NothingNode(0, 0, this.state.scope.id);
          } else if (!(whenTrue instanceof Node)) {
            throw TypeError("Expected whenTrue to be a Node, got " + __typeof(whenTrue));
          }
          if (whenFalse == null) {
            whenFalse = null;
          } else if (!(whenFalse instanceof Node)) {
            throw TypeError("Expected whenFalse to be a Node or null, got " + __typeof(whenFalse));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return this.state["if"](
            this.index,
            this.doWrap(test),
            whenTrue,
            whenFalse,
            label
          ).reduce(this.state);
        };
        _MacroHelper_prototype["switch"] = function (node, cases, defaultCase, label) {
          var _this;
          _this = this;
          if (node == null) {
            node = NothingNode(0, 0, this.state.scope.id);
          } else if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          if (!__isArray(cases)) {
            throw TypeError("Expected cases to be an Array, got " + __typeof(cases));
          }
          if (defaultCase == null) {
            defaultCase = null;
          } else if (!(defaultCase instanceof Node)) {
            throw TypeError("Expected defaultCase to be a Node or null, got " + __typeof(defaultCase));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return this.state["switch"](
            this.index,
            this.doWrap(node),
            (function () {
              var _arr, _i, _len, case_;
              for (_arr = [], _i = 0, _len = cases.length; _i < _len; ++_i) {
                case_ = cases[_i];
                _arr.push({ node: _this.doWrap(case_.node), body: case_.body, fallthrough: case_.fallthrough });
              }
              return _arr;
            }()),
            defaultCase,
            label
          ).reduce(this.state);
        };
        _MacroHelper_prototype["for"] = function (init, test, step, body, label) {
          if (init == null) {
            init = null;
          } else if (!(init instanceof Node)) {
            throw TypeError("Expected init to be a Node or null, got " + __typeof(init));
          }
          if (test == null) {
            test = null;
          } else if (!(test instanceof Node)) {
            throw TypeError("Expected test to be a Node or null, got " + __typeof(test));
          }
          if (step == null) {
            step = null;
          } else if (!(step instanceof Node)) {
            throw TypeError("Expected step to be a Node or null, got " + __typeof(step));
          }
          if (body == null) {
            body = NothingNode(0, 0, this.state.scope.id);
          } else if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return this.state["for"](
            this.index,
            this.doWrap(init),
            this.doWrap(test),
            this.doWrap(step),
            body,
            label
          ).reduce(this.state);
        };
        _MacroHelper_prototype.forIn = function (key, object, body, label) {
          if (!(key instanceof IdentNode)) {
            throw TypeError("Expected key to be an IdentNode, got " + __typeof(key));
          }
          if (object == null) {
            object = NothingNode(0, 0);
          } else if (!(object instanceof Node)) {
            throw TypeError("Expected object to be a Node, got " + __typeof(object));
          }
          if (body == null) {
            body = NothingNode(0, 0, this.state.scope.id);
          } else if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return this.state.forIn(
            this.index,
            key,
            this.doWrap(object),
            body,
            label
          ).reduce(this.state);
        };
        _MacroHelper_prototype.tryCatch = function (tryBody, catchIdent, catchBody, label) {
          if (tryBody == null) {
            tryBody = NothingNode(0, 0, this.state.scope.id);
          } else if (!(tryBody instanceof Node)) {
            throw TypeError("Expected tryBody to be a Node, got " + __typeof(tryBody));
          }
          if (catchIdent == null) {
            catchIdent = NothingNode(0, 0, this.state.scope.id);
          } else if (!(catchIdent instanceof Node)) {
            throw TypeError("Expected catchIdent to be a Node, got " + __typeof(catchIdent));
          }
          if (catchBody == null) {
            catchBody = NothingNode(0, 0, this.state.scope.id);
          } else if (!(catchBody instanceof Node)) {
            throw TypeError("Expected catchBody to be a Node, got " + __typeof(catchBody));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return this.state.tryCatch(
            this.index,
            tryBody,
            catchIdent,
            catchBody,
            label
          ).reduce(this.state);
        };
        _MacroHelper_prototype.tryFinally = function (tryBody, finallyBody, label) {
          if (tryBody == null) {
            tryBody = NothingNode(0, 0, this.state.scope.id);
          } else if (!(tryBody instanceof Node)) {
            throw TypeError("Expected tryBody to be a Node, got " + __typeof(tryBody));
          }
          if (finallyBody == null) {
            finallyBody = NothingNode(0, 0, this.state.scope.id);
          } else if (!(finallyBody instanceof Node)) {
            throw TypeError("Expected finallyBody to be a Node, got " + __typeof(finallyBody));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return this.state.tryFinally(this.index, tryBody, finallyBody, label).reduce(this.state);
        };
        _MacroHelper_prototype.assign = function (left, op, right) {
          if (left == null) {
            left = NothingNode(0, 0, this.state.scope.id);
          } else if (!(left instanceof Node)) {
            throw TypeError("Expected left to be a Node, got " + __typeof(left));
          }
          if (typeof op !== "string") {
            throw TypeError("Expected op to be a String, got " + __typeof(op));
          }
          if (right == null) {
            right = NothingNode(0, 0, this.state.scope.id);
          } else if (!(right instanceof Node)) {
            throw TypeError("Expected right to be a Node, got " + __typeof(right));
          }
          return this.state.assign(this.index, left, op, this.doWrap(right)).reduce(this.state);
        };
        _MacroHelper_prototype.binary = function (left, op, right) {
          if (left == null) {
            left = NothingNode(0, 0, this.state.scope.id);
          } else if (!(left instanceof Node)) {
            throw TypeError("Expected left to be a Node, got " + __typeof(left));
          }
          if (typeof op !== "string") {
            throw TypeError("Expected op to be a String, got " + __typeof(op));
          }
          if (right == null) {
            right = NothingNode(0, 0, this.state.scope.id);
          } else if (!(right instanceof Node)) {
            throw TypeError("Expected right to be a Node, got " + __typeof(right));
          }
          return this.state.binary(this.index, this.doWrap(left), op, this.doWrap(right)).reduce(this.state);
        };
        _MacroHelper_prototype.unary = function (op, node) {
          if (typeof op !== "string") {
            throw TypeError("Expected op to be a String, got " + __typeof(op));
          }
          if (node == null) {
            node = NothingNode(0, 0, this.state.scope.id);
          } else if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          return this.state.unary(this.index, op, this.doWrap(node)).reduce(this.state);
        };
        _MacroHelper_prototype["throw"] = function (node) {
          if (node == null) {
            node = NothingNode(0, 0, this.state.scope.id);
          } else if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          return this.state["throw"](this.index, this.doWrap(node)).reduce(this.state);
        };
        _MacroHelper_prototype["return"] = function (node) {
          if (node == null) {
            node = void 0;
          } else if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node or undefined, got " + __typeof(node));
          }
          return this.state["return"](this.index, this.doWrap(node)).reduce(this.state);
        };
        _MacroHelper_prototype["yield"] = function (node) {
          if (node == null) {
            node = NothingNode(0, 0, this.state.scope.id);
          } else if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          return this.state["yield"](this.index, this.doWrap(node)).reduce(this.state);
        };
        _MacroHelper_prototype["debugger"] = function () {
          return this.state["debugger"](this.index);
        };
        _MacroHelper_prototype["break"] = function (label) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return this.state["break"](this.index, label);
        };
        _MacroHelper_prototype["continue"] = function (label) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return this.state["continue"](this.index, label);
        };
        _MacroHelper_prototype.isLabeledBlock = function (node) {
          node = this.macroExpand1(node);
          if (node instanceof BlockNode || node instanceof IfNode || node instanceof SwitchNode || node instanceof ForNode || node instanceof ForInNode || node instanceof TryCatchNode || node instanceof TryCatchFinallyNode) {
            return node.label != null;
          } else {
            return false;
          }
        };
        _MacroHelper_prototype.isBreak = function (node) {
          return this.macroExpand1(node) instanceof BreakNode;
        };
        _MacroHelper_prototype.isContinue = function (node) {
          return this.macroExpand1(node) instanceof ContinueNode;
        };
        _MacroHelper_prototype.label = function (node) {
          node = this.macroExpand1(node);
          if (node instanceof BreakNode || node instanceof ContinueNode || node instanceof BlockNode || node instanceof IfNode || node instanceof SwitchNode || node instanceof ForNode || node instanceof ForInNode || node instanceof TryCatchNode || node instanceof TryCatchFinallyNode) {
            return node.label;
          } else {
            return null;
          }
        };
        _MacroHelper_prototype.withLabel = function (node, label) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return node.withLabel(label, this.state);
        };
        _MacroHelper_prototype.macroExpand1 = function (node) {
          var expanded;
          if (node instanceof Node) {
            expanded = this.state.macroExpand1(node);
            if (expanded instanceof Node) {
              return expanded.reduce(this.state);
            } else {
              return expanded;
            }
          } else {
            return node;
          }
        };
        _MacroHelper_prototype.macroExpandAll = function (node) {
          var expanded;
          if (node instanceof Node) {
            expanded = this.state.macroExpandAll(node);
            if (expanded instanceof Node) {
              return expanded.reduce(this.state);
            } else {
              return expanded;
            }
          } else {
            return node;
          }
        };
        _MacroHelper_prototype.tmp = function (name, save, type) {
          var id;
          if (name == null) {
            name = "ref";
          } else if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (save == null) {
            save = false;
          } else if (typeof save !== "boolean") {
            throw TypeError("Expected save to be a Boolean, got " + __typeof(save));
          }
          id = getTmpId();
          (save ? this.savedTmps : this.unsavedTmps).push(id);
          if (type == null) {
            type = Type.any;
          } else if (typeof type === "string") {
            if (!((__owns.call(Type, type) ? Type[type] : void 0) instanceof Type)) {
              throw Error(__strnum(type) + " is not a known type name");
            }
            type = __owns.call(Type, type) ? Type[type] : void 0;
          } else if (!(type instanceof Type)) {
            throw Error("Must provide a Type or a string for type, got " + __typeof(type));
          }
          return this.state.tmp(this.index, id, name, type);
        };
        _MacroHelper_prototype.getTmps = function () {
          return { unsaved: this.unsavedTmps.slice(), saved: this.savedTmps.slice() };
        };
        _MacroHelper_prototype.isConst = function (node) {
          return node === void 0 || node instanceof Node && this.macroExpand1(node).isConst();
        };
        _MacroHelper_prototype.value = function (node) {
          var expanded;
          if (node === void 0) {
            return;
          } else if (node instanceof Node) {
            expanded = this.macroExpand1(node);
            if (expanded.isConst()) {
              return expanded.constValue();
            }
          }
        };
        _MacroHelper_prototype["const"] = function (value) {
          return this.state["const"](this.index, value);
        };
        _MacroHelper_prototype.isNode = function (node) {
          return node instanceof Node;
        };
        _MacroHelper_prototype.isIdent = function (node) {
          return this.macroExpand1(node) instanceof IdentNode;
        };
        _MacroHelper_prototype.isTmp = function (node) {
          return this.macroExpand1(node) instanceof TmpNode;
        };
        _MacroHelper_prototype.isIdentOrTmp = function (node) {
          var _ref;
          return (_ref = this.macroExpand1(node)) instanceof IdentNode || _ref instanceof TmpNode;
        };
        _MacroHelper_prototype.name = function (node) {
          node = this.macroExpand1(node);
          if (this.isIdent(node)) {
            return node.name;
          }
        };
        _MacroHelper_prototype.ident = function (name) {
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (require("./ast").isAcceptableIdent(name, true)) {
            return this.state.ident(this.index, name);
          }
        };
        _MacroHelper_prototype.isCall = function (node) {
          return this.macroExpand1(node) instanceof CallNode;
        };
        _MacroHelper_prototype.callFunc = function (node) {
          node = this.macroExpand1(node);
          if (node instanceof CallNode) {
            return node.func;
          }
        };
        _MacroHelper_prototype.callArgs = function (node) {
          node = this.macroExpand1(node);
          if (node instanceof CallNode) {
            return node.args;
          }
        };
        _MacroHelper_prototype.isSuper = function (node) {
          return this.macroExpand1(node) instanceof SuperNode;
        };
        _MacroHelper_prototype.superChild = function (node) {
          node = this.macroExpand1(node);
          if (this.isSuper(node)) {
            return node.child;
          }
        };
        _MacroHelper_prototype.superArgs = function (node) {
          node = this.macroExpand1(node);
          if (this.isSuper(node)) {
            return node.args;
          }
        };
        _MacroHelper_prototype.callIsNew = function (node) {
          node = this.macroExpand1(node);
          if (node instanceof CallNode) {
            return !!node.isNew;
          } else {
            return false;
          }
        };
        _MacroHelper_prototype.callIsApply = function (node) {
          node = this.macroExpand1(node);
          if (node instanceof CallNode) {
            return !!node.isApply;
          } else {
            return false;
          }
        };
        _MacroHelper_prototype.call = function (func, args, isNew, isApply) {
          var _i, _len, _this;
          _this = this;
          if (!(func instanceof Node)) {
            throw TypeError("Expected func to be a Node, got " + __typeof(func));
          }
          if (args == null) {
            args = [];
          } else if (!__isArray(args)) {
            throw TypeError("Expected args to be an Array, got " + __typeof(args));
          } else {
            for (_i = 0, _len = args.length; _i < _len; ++_i) {
              if (!(args[_i] instanceof Node)) {
                throw TypeError("Expected args[" + _i + "] to be a Node, got " + __typeof(args[_i]));
              }
            }
          }
          if (isNew == null) {
            isNew = false;
          } else if (typeof isNew !== "boolean") {
            throw TypeError("Expected isNew to be a Boolean, got " + __typeof(isNew));
          }
          if (isApply == null) {
            isApply = false;
          } else if (typeof isApply !== "boolean") {
            throw TypeError("Expected isApply to be a Boolean, got " + __typeof(isApply));
          }
          if (isNew && isApply) {
            throw Error("Cannot specify both is-new and is-apply");
          }
          return this.state.call(
            func.startIndex,
            this.doWrap(func),
            (function () {
              var _arr, _i, _len, arg;
              for (_arr = [], _i = 0, _len = args.length; _i < _len; ++_i) {
                arg = args[_i];
                _arr.push(_this.doWrap(arg));
              }
              return _arr;
            }()),
            isNew,
            isApply
          ).reduce(this.state);
        };
        _MacroHelper_prototype.func = function (params, body, autoReturn, bound) {
          var _this, clone;
          _this = this;
          if (autoReturn == null) {
            autoReturn = true;
          }
          if (bound == null) {
            bound = false;
          } else if (!(bound instanceof Node) && typeof bound !== "boolean") {
            throw TypeError("Expected bound to be a Node or Boolean, got " + __typeof(bound));
          }
          clone = this.state.clone(this.state.cloneScope());
          params = (function () {
            var _arr, _arr2, _i, _len, p, param;
            for (_arr = [], _arr2 = __toArray(params), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
              param = _arr2[_i];
              p = param.rescope(clone.scope.id, clone);
              addParamToScope(clone, p);
              _arr.push(p);
            }
            return _arr;
          }());
          return this.state["function"](
            0,
            params,
            body.rescope(clone.scope.id, clone),
            autoReturn,
            bound
          ).reduce(this.state);
        };
        _MacroHelper_prototype.isFunc = function (node) {
          return this.macroExpand1(node) instanceof FunctionNode;
        };
        _MacroHelper_prototype.funcBody = function (node) {
          node = this.macroExpand1(node);
          if (this.isFunc(node)) {
            return node.body;
          }
        };
        _MacroHelper_prototype.funcParams = function (node) {
          node = this.macroExpand1(node);
          if (this.isFunc(node)) {
            return node.params;
          }
        };
        _MacroHelper_prototype.funcIsAutoReturn = function (node) {
          node = this.macroExpand1(node);
          if (this.isFunc(node)) {
            return !!node.autoReturn;
          }
        };
        _MacroHelper_prototype.funcIsBound = function (node) {
          node = this.macroExpand1(node);
          if (this.isFunc(node)) {
            return !!node.bound && !(node.bound instanceof Node);
          }
        };
        _MacroHelper_prototype.param = function (ident, defaultValue, spread, isMutable, asType) {
          return this.state.param(
            0,
            ident,
            defaultValue,
            spread,
            isMutable,
            asType
          ).reduce(this.state);
        };
        _MacroHelper_prototype.isParam = function (node) {
          return this.macroExpand1(node) instanceof ParamNode;
        };
        _MacroHelper_prototype.paramIdent = function (node) {
          node = this.macroExpand1(node);
          if (this.isParam(node)) {
            return node.ident;
          }
        };
        _MacroHelper_prototype.paramDefaultValue = function (node) {
          node = this.macroExpand1(node);
          if (this.isParam(node)) {
            return node.defaultValue;
          }
        };
        _MacroHelper_prototype.paramIsSpread = function (node) {
          node = this.macroExpand1(node);
          if (this.isParam(node)) {
            return !!node.spread;
          }
        };
        _MacroHelper_prototype.paramIsMutable = function (node) {
          node = this.macroExpand1(node);
          if (this.isParam(node)) {
            return !!node.isMutable;
          }
        };
        _MacroHelper_prototype.paramType = function (node) {
          node = this.macroExpand1(node);
          if (this.isParam(node)) {
            return node.asType;
          }
        };
        _MacroHelper_prototype.isArray = function (node) {
          return this.macroExpand1(node) instanceof ArrayNode;
        };
        _MacroHelper_prototype.elements = function (node) {
          node = this.macroExpand1(node);
          if (this.isArray(node)) {
            return node.elements;
          }
        };
        _MacroHelper_prototype.isObject = function (node) {
          return this.macroExpand1(node) instanceof ObjectNode;
        };
        _MacroHelper_prototype.pairs = function (node) {
          node = this.macroExpand1(node);
          if (this.isObject(node) || this.isTypeObject(node)) {
            return node.pairs;
          }
        };
        _MacroHelper_prototype.isBlock = function (node) {
          return this.macroExpand1(node) instanceof BlockNode;
        };
        _MacroHelper_prototype.nodes = function (node) {
          node = this.macroExpand1(node);
          if (this.isBlock(node)) {
            return node.nodes;
          }
        };
        _MacroHelper_prototype.array = function (elements) {
          var _i, _len, _this;
          _this = this;
          if (!__isArray(elements)) {
            throw TypeError("Expected elements to be an Array, got " + __typeof(elements));
          } else {
            for (_i = 0, _len = elements.length; _i < _len; ++_i) {
              if (!(elements[_i] instanceof Node)) {
                throw TypeError("Expected elements[" + _i + "] to be a Node, got " + __typeof(elements[_i]));
              }
            }
          }
          return this.state.array(0, (function () {
            var _arr, _i, _len, element;
            for (_arr = [], _i = 0, _len = elements.length; _i < _len; ++_i) {
              element = elements[_i];
              _arr.push(_this.doWrap(element));
            }
            return _arr;
          }())).reduce(this.state);
        };
        _MacroHelper_prototype.object = function (pairs) {
          var _i, _len, _this;
          _this = this;
          if (!__isArray(pairs)) {
            throw TypeError("Expected pairs to be an Array, got " + __typeof(pairs));
          } else {
            for (_i = 0, _len = pairs.length; _i < _len; ++_i) {
              if (!__isObject(pairs[_i])) {
                throw TypeError("Expected pairs[" + _i + "] to be an Object, got " + __typeof(pairs[_i]));
              } else {
                if (!(pairs[_i].key instanceof Node)) {
                  throw TypeError("Expected pairs[" + _i + "].key to be a Node, got " + __typeof(pairs[_i].key));
                }
                if (!(pairs[_i].value instanceof Node)) {
                  throw TypeError("Expected pairs[" + _i + "].value to be a Node, got " + __typeof(pairs[_i].value));
                }
              }
            }
          }
          return this.state.object(0, (function () {
            var _arr, _i, _len, _ref, key, property, value;
            for (_arr = [], _i = 0, _len = pairs.length; _i < _len; ++_i) {
              key = (_ref = pairs[_i]).key;
              value = _ref.value;
              property = _ref.property;
              _arr.push({ key: _this.doWrap(key), value: _this.doWrap(value)(property) });
            }
            return _arr;
          }())).reduce(this.state);
        };
        _MacroHelper_prototype.type = function (node) {
          var _this;
          _this = this;
          if (typeof node === "string") {
            return __owns.call(Type, node) && Type[node] || (function () {
              throw Error("Unknown type " + __strnum(node));
            }());
          } else if (node instanceof Node) {
            return node.type(this.state);
          } else {
            throw Error("Can only retrieve type from a String or Node, got " + __typeof(node));
          }
        };
        _MacroHelper_prototype.toType = nodeToType;
        _MacroHelper_prototype.isComplex = function (node) {
          node = this.macroExpand1(node);
          return node != null && !(node instanceof ConstNode) && !(node instanceof IdentNode) && !(node instanceof TmpNode) && !(node instanceof ThisNode) && !(node instanceof ArgsNode) && (!(node instanceof BlockNode) || node.nodes.length !== 0);
        };
        _MacroHelper_prototype.isTypeArray = function (node) {
          return this.macroExpand1(node) instanceof TypeArrayNode;
        };
        _MacroHelper_prototype.subtype = function (node) {
          node = this.macroExpand1(node);
          return this.isTypeArray(node) && node.subtype;
        };
        _MacroHelper_prototype.isTypeObject = function (node) {
          return this.macroExpand1(node) instanceof TypeObjectNode;
        };
        _MacroHelper_prototype.isTypeFunction = function (node) {
          return this.macroExpand1(node) instanceof TypeFunctionNode;
        };
        _MacroHelper_prototype.returnType = function (node) {
          node = this.macroExpand1(node);
          return this.isTypeFunction(node) && node.returnType;
        };
        _MacroHelper_prototype.isTypeUnion = function (node) {
          return this.macroExpand1(node) instanceof TypeUnionNode;
        };
        _MacroHelper_prototype.types = function (node) {
          node = this.macroExpand1(node);
          return this.isTypeUnion(node) && node.types;
        };
        _MacroHelper_prototype.isThis = function (node) {
          return this.macroExpand1(node) instanceof ThisNode;
        };
        _MacroHelper_prototype.isArguments = function (node) {
          node = this.macroExpand1(node);
          return node instanceof ArgsNode;
        };
        _MacroHelper_prototype.isDef = function (node) {
          return this.macroExpand1(node) instanceof DefNode;
        };
        _MacroHelper_prototype.isAssign = function (node) {
          return this.macroExpand1(node) instanceof AssignNode;
        };
        _MacroHelper_prototype.isBinary = function (node) {
          return this.macroExpand1(node) instanceof BinaryNode;
        };
        _MacroHelper_prototype.isUnary = function (node) {
          return this.macroExpand1(node) instanceof UnaryNode;
        };
        _MacroHelper_prototype.op = function (node) {
          node = this.macroExpand1(node);
          if (this.isAssign(node) || this.isBinary(node) || this.isUnary(node)) {
            return node.op;
          }
        };
        _MacroHelper_prototype.left = function (node) {
          node = this.macroExpand1(node);
          if (this.isDef(node) || this.isLet(node) || this.isBinary(node)) {
            return node.left;
          }
        };
        _MacroHelper_prototype.right = function (node) {
          node = this.macroExpand1(node);
          if (this.isDef(node) || this.isLet(node) || this.isBinary(node)) {
            return node.right;
          }
        };
        _MacroHelper_prototype.unaryNode = function (node) {
          node = this.macroExpand1(node);
          if (this.isUnary(node)) {
            return node.node;
          }
        };
        _MacroHelper_prototype.isAccess = function (node) {
          return this.macroExpand1(node) instanceof AccessNode;
        };
        _MacroHelper_prototype.parent = function (node) {
          node = this.macroExpand1(node);
          if (node instanceof AccessNode) {
            return node.parent;
          }
        };
        _MacroHelper_prototype.child = function (node) {
          node = this.macroExpand1(node);
          if (node instanceof AccessNode) {
            return node.child;
          }
        };
        _MacroHelper_prototype.isIf = function (node) {
          return this.macroExpand1(node) instanceof IfNode;
        };
        _MacroHelper_prototype.test = function (node) {
          node = this.macroExpand1(node);
          if (node instanceof IfNode) {
            return node.test;
          }
        };
        _MacroHelper_prototype.whenTrue = function (node) {
          node = this.macroExpand1(node);
          if (node instanceof IfNode) {
            return node.whenTrue;
          }
        };
        _MacroHelper_prototype.whenFalse = function (node) {
          node = this.macroExpand1(node);
          if (node instanceof IfNode) {
            return node.whenFalse;
          }
        };
        _MacroHelper_prototype.cache = function (node, init, name, save) {
          if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          if (name == null) {
            name = "ref";
          } else if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (save == null) {
            save = false;
          } else if (typeof save !== "boolean") {
            throw TypeError("Expected save to be a Boolean, got " + __typeof(save));
          }
          return this.maybeCache(
            node,
            function (setNode, node, cached) {
              if (cached) {
                init.push(setNode);
              }
              return node;
            },
            name,
            save
          );
        };
        _MacroHelper_prototype.maybeCache = function (node, func, name, save) {
          var tmp, type;
          if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          if (name == null) {
            name = "ref";
          } else if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (save == null) {
            save = false;
          } else if (typeof save !== "boolean") {
            throw TypeError("Expected save to be a Boolean, got " + __typeof(save));
          }
          node = this.macroExpand1(node);
          if (this.isComplex(node)) {
            type = node.type(this.state);
            tmp = this.tmp(name, save, type);
            this.state.scope.add(tmp, false, type);
            return func(
              this.state.block(this.index, [
                this.state["var"](this.index, tmp, false),
                this.state.assign(this.index, tmp, "=", this.doWrap(node))
              ]),
              tmp,
              true
            );
          } else {
            return func(node, node, false);
          }
        };
        _MacroHelper_prototype.maybeCacheAccess = function (node, func, parentName, childName, save) {
          var _this;
          _this = this;
          if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          if (parentName == null) {
            parentName = "ref";
          } else if (typeof parentName !== "string") {
            throw TypeError("Expected parentName to be a String, got " + __typeof(parentName));
          }
          if (childName == null) {
            childName = "ref";
          } else if (typeof childName !== "string") {
            throw TypeError("Expected childName to be a String, got " + __typeof(childName));
          }
          if (save == null) {
            save = false;
          } else if (typeof save !== "boolean") {
            throw TypeError("Expected save to be a Boolean, got " + __typeof(save));
          }
          node = this.macroExpand1(node);
          if (this.isAccess(node)) {
            return this.maybeCache(
              this.parent(node),
              function (setParent, parent, parentCached) {
                return _this.maybeCache(
                  _this.child(node),
                  function (setChild, child, childCached) {
                    if (parentCached || childCached) {
                      return func(
                        _this.state.access(_this.index, setParent, setChild),
                        _this.state.access(_this.index, parent, child),
                        true
                      );
                    } else {
                      return func(node, node, false);
                    }
                  },
                  childName,
                  save
                );
              },
              parentName,
              save
            );
          } else {
            return func(node, node, false);
          }
        };
        _MacroHelper_prototype.empty = function (node) {
          var _this;
          _this = this;
          if (node == null) {
            return true;
          } else if (!(node instanceof Node)) {
            return false;
          } else if (node instanceof BlockNode) {
            return (function () {
              var _arr, _i, item;
              for (_arr = __toArray(node.nodes), _i = _arr.length; _i--; ) {
                item = _arr[_i];
                if (!_this.empty(item)) {
                  return false;
                }
              }
              return true;
            }());
          } else {
            return node instanceof NothingNode;
          }
        };
        function constifyObject(obj, startIndex, endIndex, scopeId) {
          if (!obj || typeof obj !== "object" || obj instanceof RegExp) {
            return ConstNode(startIndex, endIndex, scopeId, obj);
          } else if (__isArray(obj)) {
            return ArrayNode(startIndex, endIndex, scopeId, (function () {
              var _arr, _arr2, _i, _len, item;
              for (_arr = [], _arr2 = __toArray(obj), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                item = _arr2[_i];
                _arr.push(constifyObject(item, startIndex, endIndex, scopeId));
              }
              return _arr;
            }()));
          } else if (obj instanceof IdentNode && __num(obj.name.length) > 1 && obj.name.charCodeAt(0) === 36) {
            return CallNode(
              obj.startIndex,
              obj.endIndex,
              obj.scopeId,
              IdentNode(obj.startIndex, obj.endIndex, obj.scopeId, "__wrap"),
              [
                IdentNode(obj.startIndex, obj.endIndex, obj.scopeId, obj.name.substring(1)),
                ConstNode(obj.startIndex, obj.endIndex, obj.scopeId, obj.scopeId)
              ]
            );
          } else if (obj instanceof CallNode && !obj.isNew && !obj.isApply && obj.func instanceof IdentNode && obj.func.name === "$") {
            if (obj.args.length !== 1 || obj.args[0] instanceof SpreadNode) {
              throw Error("Can only use $() in an AST if it has one argument.");
            }
            return CallNode(
              obj.startIndex,
              obj.endIndex,
              obj.scopeId,
              IdentNode(obj.startIndex, obj.endIndex, obj.scopeId, "__wrap"),
              [
                obj.args[0],
                ConstNode(obj.startIndex, obj.endIndex, obj.scopeId, obj.scopeId)
              ]
            );
          } else if (obj instanceof Node) {
            if (obj.constructor === Node) {
              throw Error("Cannot constify a raw node");
            }
            return CallNode(
              obj.startIndex,
              obj.endIndex,
              obj.scopeId,
              IdentNode(obj.startIndex, obj.endIndex, obj.scopeId, "__node"),
              [
                ConstNode(obj.startIndex, obj.endIndex, obj.scopeId, obj.constructor.cappedName),
                ConstNode(obj.startIndex, obj.endIndex, obj.scopeId, obj.startIndex),
                ConstNode(obj.startIndex, obj.endIndex, obj.scopeId, obj.endIndex)
              ].concat((function () {
                var _arr, _arr2, _i, _len, k;
                for (_arr = [], _arr2 = __toArray(obj.constructor.argNames), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                  k = _arr2[_i];
                  _arr.push(constifyObject(obj[k], obj.startIndex, obj.endIndex, obj.scopeId));
                }
                return _arr;
              }()))
            );
          } else {
            return ObjectNode(startIndex, endIndex, scopeId, (function () {
              var _arr, k, v;
              _arr = [];
              for (k in obj) {
                if (__owns.call(obj, k)) {
                  v = obj[k];
                  _arr.push({
                    key: ConstNode(startIndex, endIndex, scopeId, k),
                    value: constifyObject(v, startIndex, endIndex, scopeId)
                  });
                }
              }
              return _arr;
            }()));
          }
        }
        MacroHelper.constifyObject = constifyObject;
        function walk(node, func) {
          var _ref;
          if (!node || typeof node !== "object" || node instanceof RegExp) {
            return node;
          }
          if (!(node instanceof Node)) {
            throw Error("Unexpected type to walk through: " + __typeof(node));
          }
          if (!(node instanceof BlockNode) && (_ref = func(node)) != null) {
            return _ref;
          }
          return node.walk(function (x) {
            return walk(x, func);
          });
        }
        _MacroHelper_prototype.wrap = function (value) {
          var _ref;
          if (__isArray(value)) {
            return BlockNode(0, 0, this.state.scope.id, value).reduce(this.state);
          } else if (value instanceof Node) {
            return value;
          } else if (value == null) {
            return NothingNode(0, 0, this.state.scope.id);
          } else if (value instanceof RegExp || (_ref = typeof value) === "string" || _ref === "boolean" || _ref === "number") {
            return ConstNode(0, 0, this.state.scope.id, value);
          } else {
            return value;
          }
        };
        _MacroHelper_prototype.node = function (type, startIndex, endIndex) {
          var args;
          args = __slice.call(arguments, 3);
          return Node[type].apply(Node, [startIndex, endIndex, this.state.scope.id].concat(__toArray(args))).reduce(this.state);
        };
        _MacroHelper_prototype.walk = function (node, func) {
          if (node != void 0 && !(node instanceof Node)) {
            throw TypeError("Expected node to be a Node or undefined or null, got " + __typeof(node));
          }
          if (typeof func !== "function") {
            throw TypeError("Expected func to be a Function, got " + __typeof(func));
          }
          if (node != null) {
            return walk(node, func);
          } else {
            return node;
          }
        };
        _MacroHelper_prototype.hasFunc = function (node) {
          var FOUND, walker;
          if (this._hasFunc != null) {
            return this._hasFunc;
          } else {
            FOUND = {};
            walker = function (x) {
              if (x instanceof FunctionNode) {
                throw FOUND;
              } else {
                return x.walk(walker);
              }
            };
            try {
              walk(this.macroExpandAll(node), walker);
            } catch (e) {
              if (e !== FOUND) {
                throw e;
              }
              return this._hasFunc = true;
            }
            return this._hasFunc = false;
          }
        };
        _MacroHelper_prototype.isStatement = function (node) {
          node = this.macroExpand1(node);
          return node instanceof Node && node.isStatement();
        };
        _MacroHelper_prototype.isType = function (node, name) {
          var type;
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (__owns.call(Type, name)) {
            type = Type[name];
          }
          if (type == null || !(type instanceof Type)) {
            throw Error(name + " is not a known type name");
          }
          return node.type(this.state).isSubsetOf(type);
        };
        _MacroHelper_prototype.hasType = function (node, name) {
          var type;
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (__owns.call(Type, name)) {
            type = Type[name];
          }
          if (type == null || !(type instanceof Type)) {
            throw Error(name + " is not a known type name");
          }
          return node.type(this.state).overlaps(type);
        };
        mutators = {
          Block: function (x, func) {
            var lastNode, len, nodes;
            nodes = x.nodes;
            len = nodes.length;
            if (len !== 0) {
              lastNode = this.mutateLast(nodes[__num(len) - 1], func);
              if (lastNode !== nodes[__num(len) - 1]) {
                return BlockNode(
                  x.startIndex,
                  x.endIndex,
                  x.scopeId,
                  __toArray(__slice.call(nodes, 0, -1)).concat([lastNode]),
                  x.label
                );
              }
            }
            return x;
          },
          If: function (x, func) {
            var whenFalse, whenTrue;
            whenTrue = this.mutateLast(x.whenTrue, func);
            whenFalse = this.mutateLast(x.whenFalse, func);
            if (whenTrue !== x.whenTrue || whenFalse !== x.whenFalse) {
              return IfNode(
                x.startIndex,
                x.endIndex,
                x.scopeId,
                x.test,
                whenTrue,
                whenFalse,
                x.label
              );
            } else {
              return x;
            }
          },
          Switch: function (x, func) {
            var _this, cases, defaultCase;
            _this = this;
            cases = map(x.cases, function (case_) {
              var body;
              if (case_.fallthrough) {
                return case_;
              } else {
                body = _this.mutateLast(case_.body, func);
                if (body !== case_.body) {
                  return { node: case_.node, body: body, fallthrough: case_.fallthrough };
                } else {
                  return case_;
                }
              }
            });
            defaultCase = this.mutateLast(x.defaultCase || this.noop(), func);
            if (cases !== x.cases || defaultCase !== x.defaultCase) {
              return SwitchNode(
                x.startIndex,
                x.endIndex,
                x.scopeId,
                x.node,
                cases,
                defaultCase,
                x.label
              );
            } else {
              return x;
            }
          },
          TmpWrapper: function (x, func) {
            var node;
            node = this.mutateLast(x.node, func);
            if (node !== x.node) {
              return TmpWrapperNode(
                x.startIndex,
                x.endIndex,
                x.scopeId,
                node,
                x.tmps
              );
            } else {
              return x;
            }
          },
          MacroAccess: function (x, func) {
            return this.mutateLast(this.macroExpand1(x), func);
          },
          Break: identity,
          Continue: identity,
          Nothing: identity,
          Return: identity,
          Debugger: identity,
          Throw: identity
        };
        _MacroHelper_prototype.mutateLast = function (node, func, includeNoop) {
          var _ref;
          if (typeof func !== "function") {
            throw TypeError("Expected func to be a Function, got " + __typeof(func));
          }
          if (!node || typeof node !== "object" || node instanceof RegExp) {
            return node;
          }
          if (!(node instanceof Node)) {
            throw Error("Unexpected type to mutate-last through: " + __typeof(node));
          }
          if (!__owns.call(mutators, node.constructor.cappedName) || includeNoop && node instanceof NothingNode) {
            if ((_ref = func(node)) != null) {
              return _ref;
            } else {
              return node;
            }
          } else {
            return mutators[node.constructor.cappedName].call(this, node, func);
          }
        };
        _MacroHelper_prototype.canMutateLast = function (node) {
          return node instanceof Node && __owns.call(mutators, node.constructor.cappedName);
        };
        return MacroHelper;
      }());
      function oneOf(rules) {
        var _i, _len, i, name, rule;
        if (!__isArray(rules)) {
          throw TypeError("Expected rules to be an Array, got " + __typeof(rules));
        } else {
          for (_i = 0, _len = rules.length; _i < _len; ++_i) {
            if (typeof rules[_i] !== "function") {
              throw TypeError("Expected rules[" + _i + "] to be a Function, got " + __typeof(rules[_i]));
            }
          }
        }
        name = ["("];
        for (i = 0, _len = rules.length; i < _len; ++i) {
          rule = rules[i];
          if (i > 0) {
            name.push(" | ");
          }
          name.push(rule.parserName || "<unknown>");
        }
        name.push(")");
        return named(name.join(""), function (o) {
          var _i, _len, result, rule;
          for (_i = 0, _len = rules.length; _i < _len; ++_i) {
            rule = rules[_i];
            result = rule(o);
            if (result) {
              return result;
            }
          }
          return false;
        });
      }
      AnyObjectLiteral = named("AnyObjectLiteral", function (o) {
        return UnclosedObjectLiteral(o) || ObjectLiteral(o) || IndentedUnclosedObjectLiteral(o);
      });
      AnyArrayLiteral = named("AnyArrayLiteral", function (o) {
        return ArrayLiteral(o) || IndentedUnclosedArrayLiteral(o);
      });
      MacroHolder = (function () {
        var _MacroHolder_prototype;
        function MacroHolder() {
          var _this;
          _this = this instanceof MacroHolder ? this : __create(_MacroHolder_prototype);
          _this.byName = {};
          _this.byId = [];
          _this.byLabel = {};
          _this.typeById = [];
          _this.operatorNames = {};
          _this.binaryOperators = [];
          _this.assignOperators = [];
          _this.prefixUnaryOperators = [];
          _this.postfixUnaryOperators = [];
          _this.serialization = {};
          _this.syntaxes = {
            Logic: preventUnclosedObjectLiteral(Logic),
            Expression: Expression,
            Assignment: Assignment,
            ExpressionOrAssignment: ExpressionOrAssignment,
            FunctionDeclaration: FunctionDeclaration,
            Statement: Statement,
            Body: Body,
            Identifier: Identifier,
            SimpleAssignable: SimpleAssignable,
            Parameter: Parameter,
            ObjectLiteral: AnyObjectLiteral,
            ArrayLiteral: AnyArrayLiteral,
            DedentedBody: DedentedBody,
            ObjectKey: ObjectKey,
            Type: TypeReference,
            NoSpace: NoSpace
          };
          return _this;
        }
        _MacroHolder_prototype = MacroHolder.prototype;
        MacroHolder.displayName = "MacroHolder";
        _MacroHolder_prototype.clone = function () {
          var clone;
          clone = MacroHolder();
          clone.byName = copy(this.byName);
          clone.byId = this.byId.slice();
          clone.byLabel = copy(this.byLabel);
          clone.typeById = this.typeById.slice();
          clone.operatorNames = copy(this.operatorNames);
          clone.binaryOperators = this.binaryOperators.slice();
          clone.assignOperators = this.assignOperators.slice();
          clone.prefixUnaryOperators = this.prefixUnaryOperators.slice();
          clone.postfixUnaryOperators = this.postfixUnaryOperators.slice();
          clone.serialization = copy(this.serialization);
          clone.syntaxes = copy(this.syntaxes);
          return clone;
        };
        _MacroHolder_prototype.getByName = function (name) {
          var _ref;
          if (__owns.call(_ref = this.byName, name)) {
            return _ref[name];
          }
        };
        _MacroHolder_prototype.getOrAddByName = function (name) {
          var _this, byName, m, token;
          _this = this;
          byName = this.byName;
          if (__owns.call(byName, name)) {
            return byName[name];
          } else {
            token = macroName(name);
            m = (function () {
              var _backend;
              _backend = named("<" + __strnum(name) + " macro>", function (o) {
                var _arr, _i, _len, item, result;
                for (_arr = __toArray(m.data), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                  item = _arr[_i];
                  result = item(o);
                  if (result) {
                    return result;
                  }
                }
                return false;
              });
              return named(_backend != null && _backend.parserName || "<unknown>", function (o) {
                var result;
                if (!token(o.clone())) {
                  return false;
                } else {
                  result = _backend(o);
                  if (!result) {
                    throw SHORT_CIRCUIT;
                  }
                  return result;
                }
              });
            }());
            m.token = token;
            m.data = [];
            return byName[name] = m;
          }
        };
        _MacroHolder_prototype.getOrAddByNames = function (names) {
          var _arr, _i, _len, name;
          if (!__isArray(names)) {
            throw TypeError("Expected names to be an Array, got " + __typeof(names));
          } else {
            for (_i = 0, _len = names.length; _i < _len; ++_i) {
              if (typeof names[_i] !== "string") {
                throw TypeError("Expected names[" + _i + "] to be a String, got " + __typeof(names[_i]));
              }
            }
          }
          for (_arr = [], _i = 0, _len = names.length; _i < _len; ++_i) {
            name = names[_i];
            _arr.push(this.getOrAddByName(name));
          }
          return _arr;
        };
        _MacroHolder_prototype.setTypeById = function (id, type) {
          if (typeof id !== "number") {
            throw TypeError("Expected id to be a Number, got " + __typeof(id));
          }
          if (!(type instanceof Type)) {
            throw TypeError("Expected type to be a Type, got " + __typeof(type));
          }
          this.typeById[id] = type;
        };
        _MacroHolder_prototype.getTypeById = function (id) {
          return this.typeById[id];
        };
        _MacroHolder_prototype.getById = function (id) {
          var byId;
          byId = this.byId;
          if (__num(id) >= 0 && __lt(id, byId.length)) {
            return byId[id];
          }
        };
        _MacroHolder_prototype.addMacro = function (m, macroId, type) {
          var byId;
          if (macroId == null) {
            macroId = void 0;
          } else if (typeof macroId !== "number") {
            throw TypeError("Expected macroId to be a Number or undefined, got " + __typeof(macroId));
          }
          if (type == null) {
            type = void 0;
          } else if (!(type instanceof Type)) {
            throw TypeError("Expected type to be a Type or undefined, got " + __typeof(type));
          }
          byId = this.byId;
          if (macroId != null) {
            if (__owns.call(byId, macroId)) {
              throw Error("Cannot add macro #" + __strnum(macroId) + ", as it already exists");
            }
            byId[macroId] = m;
          } else {
            byId.push(m);
            macroId = __num(byId.length) - 1;
          }
          if (type != null) {
            this.typeById[macroId] = type;
          }
          return macroId;
        };
        _MacroHolder_prototype.replaceMacro = function (id, m, type) {
          var byId;
          if (type == null) {
            type = void 0;
          } else if (!(type instanceof Type)) {
            throw TypeError("Expected type to be a Type or undefined, got " + __typeof(type));
          }
          byId = this.byId;
          byId[id] = m;
          if (type != null) {
            this.typeById[id] = type;
          }
        };
        _MacroHolder_prototype.hasMacroOrOperator = function (name) {
          return __owns.call(this.byName, name) || __owns.call(this.operatorNames, name);
        };
        _MacroHolder_prototype.getMacroAndOperatorNames = function () {
          var _obj, name, names;
          names = [];
          _obj = this.byName;
          for (name in _obj) {
            if (__owns.call(_obj, name)) {
              names.push(name);
            }
          }
          _obj = this.operatorNames;
          for (name in _obj) {
            if (__owns.call(_obj, name)) {
              names.push(name);
            }
          }
          return names;
        };
        _MacroHolder_prototype.addBinaryOperator = function (operators, m, options, macroId) {
          var _arr, _i, _ref, _ref2, _this, binaryOperators, data, op, precedence;
          _this = this;
          for (_arr = __toArray(operators), _i = _arr.length; _i--; ) {
            op = _arr[_i];
            this.operatorNames[op] = true;
          }
          precedence = Number(options.precedence) || 0;
          if ((_ref = (_ref2 = this.binaryOperators)[precedence]) != null) {
            binaryOperators = _ref;
          } else {
            binaryOperators = _ref2[precedence] = [];
          }
          data = {
            rule: oneOf((function () {
              var _arr, _arr2, _i, _len, op;
              for (_arr = [], _arr2 = __toArray(operators), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                op = _arr2[_i];
                _arr.push(wordOrSymbol(op));
              }
              return _arr;
            }())),
            func: m,
            rightToLeft: !!options.rightToLeft,
            maximum: options.maximum || 0,
            minimum: options.minimum || 0,
            invertible: !!options.invertible
          };
          binaryOperators.push(data);
          if (options.label) {
            this.addByLabel(options.label, data);
          }
          return this.addMacro(m, macroId, options.type != null && __owns.call(Type, _ref = options.type) ? Type[_ref] : void 0);
        };
        _MacroHolder_prototype.getByLabel = function (label) {
          var _ref;
          if (__owns.call(_ref = this.byLabel, label)) {
            return _ref[label];
          }
        };
        _MacroHolder_prototype.addByLabel = function (label, data) {
          if (typeof label !== "string") {
            throw TypeError("Expected label to be a String, got " + __typeof(label));
          }
          return this.byLabel[label] = data;
        };
        _MacroHolder_prototype.addAssignOperator = function (operators, m, options, macroId) {
          var _arr, _i, _ref, _this, data, op;
          _this = this;
          for (_arr = __toArray(operators), _i = _arr.length; _i--; ) {
            op = _arr[_i];
            this.operatorNames[op] = true;
          }
          data = {
            rule: oneOf((function () {
              var _arr, _arr2, _i, _len, op;
              for (_arr = [], _arr2 = __toArray(operators), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                op = _arr2[_i];
                _arr.push(wordOrSymbol(op));
              }
              return _arr;
            }())),
            func: m
          };
          this.assignOperators.push(data);
          if (options.label) {
            this.addByLabel(options.label, data);
          }
          return this.addMacro(m, macroId, options.type != null && __owns.call(Type, _ref = options.type) ? Type[_ref] : void 0);
        };
        _MacroHolder_prototype.addUnaryOperator = function (operators, m, options, macroId) {
          var _arr, _i, _ref, _this, data, op, store;
          _this = this;
          for (_arr = __toArray(operators), _i = _arr.length; _i--; ) {
            op = _arr[_i];
            this.operatorNames[op] = true;
          }
          if (options.postfix) {
            store = this.postfixUnaryOperators;
          } else {
            store = this.prefixUnaryOperators;
          }
          data = {
            rule: oneOf((function () {
              var _arr, _arr2, _i, _len, op, rule;
              for (_arr = [], _arr2 = __toArray(operators), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                op = _arr2[_i];
                rule = wordOrSymbol(op);
                if (!/[a-zA-Z]/.test(op)) {
                  if (options.postfix) {
                    _arr.push(sequential([
                      NoSpace,
                      ["this", rule]
                    ]));
                  } else {
                    _arr.push(sequential([
                      ["this", rule],
                      NoSpace
                    ]));
                  }
                } else {
                  _arr.push(rule);
                }
              }
              return _arr;
            }())),
            func: m,
            standalone: __owns.call(!options, "standalone") || !!options.standalone
          };
          store.push(data);
          if (options.label) {
            this.addByLabel(options.label, data);
          }
          return this.addMacro(m, macroId, options.type != null && __owns.call(Type, _ref = options.type) ? Type[_ref] : void 0);
        };
        _MacroHolder_prototype.addSerializedHelper = function (name, helper, type, dependencies) {
          var _ref, _ref2, helpers;
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if ((_ref = (_ref2 = this.serialization).helpers) != null) {
            helpers = _ref;
          } else {
            helpers = _ref2.helpers = {};
          }
          helpers[name] = { helper: helper, type: type, dependencies: dependencies };
        };
        _MacroHolder_prototype.addMacroSerialization = function (serialization) {
          var _ref, _ref2, _ref3, byType, obj;
          if (!__isObject(serialization)) {
            throw TypeError("Expected serialization to be an Object, got " + __typeof(serialization));
          }
          if (typeof serialization.type !== "string") {
            throw Error("Expected a string type");
          }
          obj = copy(serialization);
          delete obj.type;
          if ((_ref = (_ref2 = this.serialization)[_ref3 = serialization.type]) != null) {
            byType = _ref;
          } else {
            byType = _ref2[_ref3] = [];
          }
          byType.push(obj);
        };
        _MacroHolder_prototype.addSyntax = function (name, value) {
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (typeof value !== "function") {
            throw TypeError("Expected value to be a Function, got " + __typeof(value));
          }
          if (__owns.call(this.syntaxes, name)) {
            throw Error("Cannot override already-defined syntax: " + name);
          }
          this.syntaxes[name] = value;
        };
        _MacroHolder_prototype.hasSyntax = function (name) {
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          return __owns.call(this.syntaxes, name);
        };
        _MacroHolder_prototype.getSyntax = function (name) {
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (__owns.call(this.syntaxes, name)) {
            return this.syntaxes[name];
          } else {
            throw Error("Unknown syntax: " + name);
          }
        };
        _MacroHolder_prototype.serialize = function () {
          return JSON.stringify(this.serialization);
        };
        _MacroHolder_prototype.deserialize = function (data) {
          var _obj, _ref, ast, dependencies, helper, name, translator, type;
          translator = require("./translator");
          ast = require("./ast");
          _obj = (_ref = __owns.call(data, "helpers") ? data.helpers : void 0) != null ? _ref : {};
          for (name in _obj) {
            if (__owns.call(_obj, name)) {
              helper = (_ref = _obj[name]).helper;
              type = _ref.type;
              dependencies = _ref.dependencies;
              translator.defineHelper(name, ast.fromJSON(helper), Type.fromJSON(type), dependencies);
            }
          }
          State("", this).deserializeMacros(data);
        };
        return MacroHolder;
      }());
      Node = (function () {
        var _Node_prototype;
        function Node() {
          var _this;
          _this = this instanceof Node ? this : __create(_Node_prototype);
          throw Error("Node should not be instantiated directly");
        }
        _Node_prototype = Node.prototype;
        Node.displayName = "Node";
        _Node_prototype.type = function () {
          return Type.any;
        };
        _Node_prototype.walk = function (f) {
          return this;
        };
        _Node_prototype.walkAsync = function (f, callback) {
          return callback(null, this);
        };
        _Node_prototype.cacheable = true;
        _Node_prototype.scope = function (o) {
          return o.getScope(this.scopeId);
        };
        _Node_prototype.withLabel = function (label) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return BlockNode(
            this.startIndex,
            this.endIndex,
            this.scopeId,
            [this],
            label
          );
        };
        _Node_prototype._reduce = function (o) {
          return this.walk(function (node) {
            return node.reduce(o);
          });
        };
        _Node_prototype.reduce = function (o) {
          var reduced;
          if (!(o instanceof State)) {
            throw TypeError("Expected o to be a State, got " + __typeof(o));
          }
          if (this._reduced != null) {
            return this._reduced;
          } else {
            reduced = this._reduce(o);
            if (reduced === this) {
              return this._reduced = this;
            } else {
              return this._reduced = reduced.reduce(o);
            }
          }
        };
        _Node_prototype.isConst = function () {
          return false;
        };
        _Node_prototype.constValue = function () {
          throw Error("Not a const: " + (typeof node === "undefined" ? "Undefined" : __typeof(node)));
        };
        _Node_prototype.isNoop = function (o) {
          return this.reduce(o)._isNoop(o);
        };
        _Node_prototype._isNoop = function (o) {
          return false;
        };
        _Node_prototype.isStatement = function () {
          return false;
        };
        _Node_prototype.rescope = function (newScopeId, o) {
          var oldScopeId;
          oldScopeId = this.scopeId;
          if (oldScopeId === newScopeId) {
            return this;
          } else {
            this.scopeId = newScopeId;
            return this.walk(function (node) {
              var nodeScope, parentId;
              if (node.scopeId === oldScopeId) {
                return node.rescope(newScopeId, o);
              } else if (node.scopeId !== newScopeId) {
                nodeScope = node.scope(o);
                if (nodeScope.parent != null) {
                  parentId = nodeScope.parent.id;
                  if (parentId === oldScopeId) {
                    nodeScope.reparent(o.getScope(newScopeId));
                  }
                }
                return node;
              } else {
                return node;
              }
            });
          }
        };
        _Node_prototype.doWrap = function (o) {
          var innerScope;
          if (this.isStatement()) {
            innerScope = o.cloneScope(o.getScope(this.scopeId));
            return CallNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              FunctionNode(
                this.startIndex,
                this.endIndex,
                this.scopeId,
                [],
                this.rescope(innerScope.id, o),
                true,
                true
              ),
              []
            );
          } else {
            return this;
          }
        };
        return Node;
      }());
      function inspectHelper(depth, name) {
        var _arr, _i, _len, arg, args, d, found, hasLarge, parts;
        args = __slice.call(arguments, 2);
        if (depth != null) {
          d = __num(depth) - 1;
        } else {
          d = null;
        }
        found = false;
        for (_i = args.length; _i--; ) {
          arg = args[_i];
          if (!arg || arg instanceof NothingNode || __isArray(arg) && arg.length === 0) {
            args.pop();
          } else {
            break;
          }
        }
        for (_arr = [], _i = 0, _len = args.length; _i < _len; ++_i) {
          arg = args[_i];
          _arr.push(inspect(arg, null, d));
        }
        parts = _arr;
        hasLarge = (function () {
          var _i, _len, part;
          for (_i = 0, _len = parts.length; _i < _len; ++_i) {
            part = parts[_i];
            if (parts.length > 50 || part.indexOf("\n") !== -1) {
              return true;
            }
          }
          return false;
        }());
        if (hasLarge) {
          parts = (function () {
            var _arr, _i, _len, part;
            for (_arr = [], _i = 0, _len = parts.length; _i < _len; ++_i) {
              part = parts[_i];
              _arr.push("  " + __strnum(part.split("\n").join("\n  ")));
            }
            return _arr;
          }());
          return __strnum(name) + "(\n" + __strnum(parts.join(",\n")) + ")";
        } else {
          return __strnum(name) + "(" + __strnum(parts.join(", ")) + ")";
        }
      }
      Scope = (function () {
        var _Scope_prototype;
        function Scope(id, parent) {
          var _this;
          _this = this instanceof Scope ? this : __create(_Scope_prototype);
          if (parent == null) {
            parent = null;
          } else if (!(parent instanceof Scope)) {
            throw TypeError("Expected parent to be a Scope or null, got " + __typeof(parent));
          }
          _this.id = id;
          _this.parent = parent;
          _this.variables = {};
          _this.tmps = [];
          return _this;
        }
        _Scope_prototype = Scope.prototype;
        Scope.displayName = "Scope";
        _Scope_prototype.clone = function (id) {
          return Scope(id, this);
        };
        _Scope_prototype.reparent = function (parent) {
          if (!(parent instanceof Scope)) {
            throw TypeError("Expected parent to be a Scope, got " + __typeof(parent));
          }
          if (parent === this) {
            throw Error("Trying to reparent to own scope");
          }
          this.parent = parent;
        };
        _Scope_prototype.add = function (ident, isMutable, type) {
          if (!(ident instanceof IdentNode) && !(ident instanceof TmpNode)) {
            throw TypeError("Expected ident to be an IdentNode or TmpNode, got " + __typeof(ident));
          }
          if (isMutable == null) {
            isMutable = false;
          } else if (typeof isMutable !== "boolean") {
            throw TypeError("Expected isMutable to be a Boolean, got " + __typeof(isMutable));
          }
          if (!(type instanceof Type)) {
            throw TypeError("Expected type to be a Type, got " + __typeof(type));
          }
          if (ident instanceof TmpNode) {
            this.tmps[ident.id] = { isMutable: isMutable, type: type };
          } else {
            this.variables[ident.name] = { isMutable: isMutable, type: type };
          }
        };
        _Scope_prototype.owns = function (ident) {
          if (!(ident instanceof IdentNode) && !(ident instanceof TmpNode)) {
            throw TypeError("Expected ident to be an IdentNode or TmpNode, got " + __typeof(ident));
          }
          if (ident instanceof TmpNode) {
            return __owns.call(this.tmps, ident.id);
          } else {
            return __owns.call(this.variables, ident.name);
          }
        };
        _Scope_prototype.has = function (ident) {
          if (!(ident instanceof IdentNode) && !(ident instanceof TmpNode)) {
            throw TypeError("Expected ident to be an IdentNode or TmpNode, got " + __typeof(ident));
          }
          if (this.owns(ident)) {
            return true;
          } else if (this.parent != null) {
            return this.parent.has(ident);
          } else {
            return false;
          }
        };
        function get(ident) {
          if (ident instanceof TmpNode) {
            if (__owns.call(this.tmps, ident.id)) {
              return this.tmps[ident.id];
            } else if (this.parent != null) {
              return get.call(this.parent, ident);
            }
          } else if (__owns.call(this.variables, ident.name)) {
            return this.variables[ident.name];
          } else if (this.parent != null) {
            return get.call(this.parent, ident);
          }
        }
        _Scope_prototype.isMutable = function (ident) {
          var data;
          if (!(ident instanceof IdentNode) && !(ident instanceof TmpNode)) {
            throw TypeError("Expected ident to be an IdentNode or TmpNode, got " + __typeof(ident));
          }
          data = get.call(this, ident);
          if (data) {
            return data.isMutable;
          } else {
            return false;
          }
        };
        _Scope_prototype.type = function (ident) {
          var data;
          if (!(ident instanceof IdentNode) && !(ident instanceof TmpNode)) {
            throw TypeError("Expected ident to be an IdentNode or TmpNode, got " + __typeof(ident));
          }
          data = get.call(this, ident);
          if (data) {
            return data.type;
          } else {
            return Type.any;
          }
        };
        return Scope;
      }());
      State = (function () {
        var _State_prototype, ASSIGN_OPERATOR, BINARY_OPERATOR, DEFINE_SYNTAX, macroDeserializers, macroSyntaxConstLiterals, macroSyntaxTypes, UNARY_OPERATOR;
        function State(data, macros, options, index, line, failures, cache, indent, currentMacro, preventFailures, knownScopes, scope) {
          var _this;
          _this = this instanceof State ? this : __create(_State_prototype);
          if (macros == null) {
            macros = MacroHolder();
          }
          if (options == null) {
            options = {};
          }
          if (index == null) {
            index = 0;
          }
          if (line == null) {
            line = 1;
          }
          if (failures == null) {
            failures = FailureManager();
          }
          if (cache == null) {
            cache = [];
          }
          if (indent == null) {
            indent = Stack(1);
          }
          if (currentMacro == null) {
            currentMacro = null;
          }
          if (preventFailures == null) {
            preventFailures = 0;
          }
          if (knownScopes == null) {
            knownScopes = [];
          }
          _this.data = data;
          _this.macros = macros;
          _this.options = options;
          _this.index = index;
          _this.line = line;
          _this.failures = failures;
          _this.cache = cache;
          _this.indent = indent;
          _this.currentMacro = currentMacro;
          _this.preventFailures = preventFailures;
          _this.knownScopes = knownScopes;
          if (!scope) {
            _this.scope = Scope(knownScopes.length);
            knownScopes.push(_this.scope);
          } else {
            _this.scope = scope;
          }
          _this.expandingMacros = false;
          return _this;
        }
        _State_prototype = State.prototype;
        State.displayName = "State";
        _State_prototype.clone = function (scope) {
          if (scope == null) {
            scope = void 0;
          } else if (!(scope instanceof Scope)) {
            throw TypeError("Expected scope to be a Scope or undefined, got " + __typeof(scope));
          }
          return State(
            this.data,
            this.macros,
            this.options,
            this.index,
            this.line,
            this.failures,
            this.cache,
            this.indent.clone(),
            this.currentMacro,
            this.preventFailures,
            this.knownScopes,
            scope || this.scope
          );
        };
        _State_prototype.clearCache = function () {
          this.cache.length = 0;
        };
        _State_prototype.cloneScope = function (outerScope) {
          var scope;
          scope = (outerScope || this.scope).clone(this.knownScopes.length);
          this.knownScopes.push(scope);
          return scope;
        };
        _State_prototype.getScope = function (id) {
          var _this;
          _this = this;
          if (typeof id !== "number") {
            throw TypeError("Expected id to be a Number, got " + __typeof(id));
          }
          return this.knownScopes[id] || (function () {
            throw Error("Unknown scope: " + id);
          }());
        };
        _State_prototype.update = function (clone) {
          this.index = clone.index;
          this.line = clone.line;
          this.indent = clone.indent.clone();
          this.macros = clone.macros;
        };
        _State_prototype.fail = function (message) {
          if (!this.preventFailures) {
            this.failures.add(message, this.index, this.line);
          }
        };
        _State_prototype.preventFail = function () {
          ++this.preventFailures;
        };
        _State_prototype.unpreventFail = function () {
          --this.preventFailures;
        };
        _State_prototype.error = function (message) {
          throw ParserError(message, this.data, this.index, this.line);
        };
        _State_prototype.enterMacro = function (names, func) {
          if (!names) {
            throw Error("Must provide a macro name");
          }
          if (this.currentMacro) {
            this.error("Attempting to define a macro " + String(names) + " inside a macro " + String(this.currentMacro));
          }
          try {
            this.currentMacro = names;
            func();
          } finally {
            this.currentMacro = null;
          }
          return this.nothing(this.index);
        };
        _State_prototype.defineHelper = function (i, name, value) {
          var _ref, dependencies, helper, node, translator, type;
          if (!(name instanceof IdentNode)) {
            throw TypeError("Expected name to be an IdentNode, got " + __typeof(name));
          }
          if (!(value instanceof Node)) {
            throw TypeError("Expected value to be a Node, got " + __typeof(value));
          }
          translator = require("./translator");
          node = this.macroExpandAll(value).reduce(this);
          type = node.type(this);
          helper = (_ref = translator.defineHelper(name, node, type)).helper;
          dependencies = _ref.dependencies;
          if (this.options.serializeMacros) {
            this.macros.addSerializedHelper(name.name, helper, type, dependencies);
          }
          return this.nothing(i);
        };
        macroSyntaxConstLiterals = {
          ",": Comma,
          ";": Semicolon,
          ":": Colon,
          "": Nothing,
          "\n": NewlineWithCheckIndent,
          "(": OpenParenthesis,
          ")": CloseParenthesis,
          "[": OpenSquareBracket,
          "]": CloseSquareBracket,
          "{": OpenCurlyBrace,
          "}": CloseCurlyBrace
        };
        function reduceObject(o, obj) {
          var _arr, _arr2, _i, _len, item, k, result, v;
          if (__isArray(obj)) {
            for (_arr = [], _arr2 = __toArray(obj), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
              item = _arr2[_i];
              _arr.push(reduceObject(o, item));
            }
            return _arr;
          } else if (obj instanceof Node) {
            return obj.reduce(o);
          } else if (typeof obj === "object" && obj !== null) {
            result = {};
            for (k in obj) {
              if (__owns.call(obj, k)) {
                v = obj[k];
                result[k] = reduceObject(o, v);
              }
            }
            return result;
          } else {
            return obj;
          }
        }
        function makeMacroRoot(index, params, body) {
          return this.root(index, this["return"](
            index,
            this["function"](
              index,
              [
                params,
                this.param(
                  index,
                  this.ident(index, "__wrap"),
                  void 0,
                  false,
                  true,
                  void 0
                ),
                this.param(
                  index,
                  this.ident(index, "__node"),
                  void 0,
                  false,
                  true,
                  void 0
                )
              ],
              body,
              true,
              false
            ),
            false
          ));
        }
        function serializeParamType(asType) {
          if (asType instanceof IdentNode) {
            return { type: "ident", name: asType.name };
          } else if (asType instanceof SyntaxSequenceNode) {
            return { type: "sequence", items: serializeParams(asType.params) };
          } else if (asType instanceof SyntaxChoiceNode) {
            return {
              type: "choice",
              choices: (function () {
                var _arr, _arr2, _i, _len, choice;
                for (_arr = [], _arr2 = __toArray(asType.choices), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                  choice = _arr2[_i];
                  _arr.push(serializeParamType(choice));
                }
                return _arr;
              }())
            };
          } else if (asType.isConst()) {
            return { type: "const", value: asType.constValue() };
          } else if (asType instanceof SyntaxManyNode) {
            return { type: "many", multiplier: asType.multiplier, inner: serializeParamType(asType.inner) };
          } else {
            throw Error();
          }
        }
        function serializeParams(params) {
          var _arr, _arr2, _i, _len, ident, param, value;
          for (_arr = [], _arr2 = __toArray(params), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
            param = _arr2[_i];
            if (param.isConst()) {
              _arr.push({ type: "const", value: param.constValue() });
            } else if (param instanceof SyntaxParamNode) {
              ident = param.ident;
              if (ident instanceof IdentNode) {
                value = { type: "ident", name: ident.name };
              } else if (ident instanceof ThisNode) {
                value = { type: "this" };
              } else {
                throw Error();
              }
              if (param.asType) {
                value.asType = serializeParamType(param.asType);
              }
              _arr.push(value);
            } else {
              throw Error();
            }
          }
          return _arr;
        }
        function deserializeParamType(asType, scopeId) {
          if (asType == null) {
            return;
          }
          switch (asType.type) {
          case "ident":
            return IdentNode(0, 0, scopeId, asType.name);
          case "sequence":
            return SyntaxSequenceNode(0, 0, scopeId, deserializeParams(asType.items, scopeId));
          case "choice":
            return SyntaxChoiceNode(0, 0, scopeId, (function () {
              var _arr, _arr2, _i, _len, choice;
              for (_arr = [], _arr2 = __toArray(asType.choices), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                choice = _arr2[_i];
                _arr.push(deserializeParamType(choice, scopeId));
              }
              return _arr;
            }()));
          case "const":
            return ConstNode(0, 0, scopeId, asType.value);
          case "many":
            return SyntaxManyNode(
              0,
              0,
              scopeId,
              deserializeParamType(asType.inner, scopeId),
              asType.multiplier
            );
          default: throw Error("Unknown as-type: " + String(asType.type));
          }
        }
        function deserializeParams(params, scopeId) {
          var _arr, _arr2, _i, _len, node, param;
          for (_arr = [], _arr2 = __toArray(params), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
            param = _arr2[_i];
            if (param.type === "const") {
              _arr.push(ConstNode(0, 0, scopeId, param.value));
            } else {
              if (param.type === "ident") {
                node = IdentNode(0, 0, scopeId, param.name);
              } else if (param.type === "this") {
                node = ThisNode(0, 0, scopeId);
              } else {
                throw Error("Unknown param: " + String(param.type));
              }
              _arr.push(SyntaxParamNode(
                0,
                0,
                scopeId,
                node,
                deserializeParamType(param.asType, scopeId)
              ));
            }
          }
          return _arr;
        }
        function calcParam(param) {
          var _this, calced, macros, multiplier, name, string;
          _this = this;
          if (param instanceof IdentNode) {
            name = param.name;
            macros = this.macros;
            if (macros.hasSyntax(name)) {
              return macros.getSyntax(name);
            } else {
              return named(name, function (o) {
                return macros.getSyntax(name).call(this, o);
              });
            }
          } else if (param instanceof SyntaxSequenceNode) {
            return handleParams.call(this, param.params);
          } else if (param instanceof SyntaxChoiceNode) {
            return cache(oneOf((function () {
              var _arr, _arr2, _i, _len, choice;
              for (_arr = [], _arr2 = __toArray(param.choices), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                choice = _arr2[_i];
                _arr.push(calcParam.call(_this, choice));
              }
              return _arr;
            }())));
          } else if (param.isConst()) {
            string = param.constValue();
            if (typeof string !== "string") {
              this.error("Expected a constant string parameter, got " + __typeof(string));
            }
            return __owns.call(macroSyntaxConstLiterals, string) && macroSyntaxConstLiterals[string] || wordOrSymbol(string);
          } else if (param instanceof SyntaxManyNode) {
            multiplier = param.multiplier;
            calced = calcParam.call(this, param.inner);
            switch (multiplier) {
            case "*":
              return named(__strnum(calced != null && calced.parserName || "calced") + "*", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = calced(clone)) {
                  result.push(item);
                }
                o.update(clone);
                return result;
              });
            case "+":
              return named(__strnum(calced != null && calced.parserName || "calced") + "+", function (o) {
                var clone, item, result;
                clone = o.clone();
                result = [];
                while (item = calced(clone)) {
                  result.push(item);
                }
                if (result.length < 1) {
                  return false;
                } else {
                  o.update(clone);
                  return result;
                }
              });
            case "?":
              return (function () {
                function _missing(x, o, i) {
                  return o.nothing(i);
                }
                return named(__strnum(calced != null && calced.parserName || "calced") + "?", function (o) {
                  var index, line;
                  index = o.index;
                  line = o.line;
                  return calced(o) || _missing(void 0, o, index, line);
                });
              }());
            default: throw Error("Unknown syntax multiplier: " + __strnum(multiplier));
            }
          } else {
            return this.error("Unexpected type: " + __typeof(param));
          }
        }
        function handleParams(params) {
          var _arr, _i, _len, _ref, ident, key, param, sequence, string, type;
          sequence = [];
          for (_arr = __toArray(params), _i = 0, _len = _arr.length; _i < _len; ++_i) {
            param = _arr[_i];
            if (param.isConst()) {
              string = param.constValue();
              if (typeof string !== "string") {
                this.error("Expected a constant string parameter, got " + __typeof(string));
              }
              sequence.push(__owns.call(macroSyntaxConstLiterals, string) && macroSyntaxConstLiterals[string] || wordOrSymbol(string));
            } else if (param instanceof SyntaxParamNode) {
              ident = param.ident;
              if (ident instanceof IdentNode) {
                key = ident.name;
              } else if (ident instanceof ThisNode) {
                key = "this";
              } else {
                throw Error("Don't know how to handle ident type: " + __typeof(ident));
              }
              if ((_ref = param.asType) != null) {
                type = _ref;
              } else {
                type = IdentNode(0, 0, -1, "Expression");
              }
              sequence.push([
                key,
                calcParam.call(this, type)
              ]);
            } else {
              this.error("Unexpected parameter type: " + __typeof(param));
            }
          }
          return sequential(sequence);
        }
        macroSyntaxTypes = {
          syntax: function (index, params, body, options, stateOptions) {
            var _this, compilation, funcParams, handler, rawFunc, serialization, state, translated;
            _this = this;
            funcParams = this.objectParam(index, [
              {
                key: this["const"](index, "macroName"),
                value: this.param(
                  index,
                  this.ident(index, "macroName"),
                  void 0,
                  false,
                  true,
                  void 0
                )
              },
              {
                key: this["const"](index, "macroData"),
                value: this.objectParam(index, (function () {
                  var _arr, _arr2, _i, _len, param;
                  for (_arr = [], _arr2 = __toArray(params), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                    param = _arr2[_i];
                    if (param instanceof SyntaxParamNode) {
                      _arr.push({
                        key: _this["const"](index, param.ident.name),
                        value: _this.param(
                          index,
                          param.ident,
                          void 0,
                          false,
                          true,
                          void 0
                        )
                      });
                    }
                  }
                  return _arr;
                }()))
              }
            ]);
            rawFunc = makeMacroRoot.call(this, index, funcParams, body);
            translated = require("./translator")(this.macroExpandAll(rawFunc).reduce(this), { "return": true });
            compilation = translated.node.toString();
            if (stateOptions.serializeMacros) {
              serialization = compilation;
            }
            handler = Function(compilation)();
            if (typeof handler !== "function") {
              throw Error("Error creating function for macro: " + String(this.currentMacro));
            }
            state = this;
            return {
              handler: function (args) {
                var rest;
                rest = __slice.call(arguments, 1);
                return handler.apply(this, [reduceObject(state, args)].concat(__toArray(rest))).reduce(state);
              },
              rule: handleParams.call(this, params),
              serialization: serialization != null
                ? {
                  type: "syntax",
                  code: serialization,
                  options: options,
                  params: serializeParams(params),
                  names: this.currentMacro
                }
                : void 0
            };
          },
          defineSyntax: function (index, params, body, options, stateOptions) {
            var _arr, _arr2, _i, _len, _this, funcParams, handler, param, serialization, state;
            _this = this;
            for (_arr = [], _arr2 = __toArray(params), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
              param = _arr2[_i];
              if (param instanceof SyntaxParamNode) {
                _arr.push({
                  key: this["const"](index, param.ident.name),
                  value: this.param(
                    index,
                    param.ident,
                    void 0,
                    false,
                    true,
                    void 0
                  )
                });
              }
            }
            funcParams = _arr;
            state = this;
            if (body != null) {
              handler = (function () {
                var compilation, handler, rawFunc, translated;
                rawFunc = makeMacroRoot.call(
                  _this,
                  index,
                  _this.objectParam(index, funcParams),
                  body
                );
                translated = require("./translator")(_this.macroExpandAll(rawFunc).reduce(state), { "return": true });
                compilation = translated.node.toString();
                if (stateOptions.serializeMacros) {
                  serialization = compilation;
                }
                handler = Function(compilation)();
                if (typeof handler !== "function") {
                  throw Error("Error creating function for syntax: " + __strnum(options.name));
                }
                return function (args) {
                  var rest;
                  rest = __slice.call(arguments, 1);
                  return reduceObject(state, handler.apply(this, [reduceObject(state, args)].concat(__toArray(rest))));
                };
              }());
            } else {
              handler = function (args) {
                var rest;
                rest = __slice.call(arguments, 1);
                return reduceObject(state, args);
              };
            }
            return {
              handler: handler,
              rule: handleParams.call(this, params),
              serialization: stateOptions.serializeMacros ? { type: "defineSyntax", code: serialization, options: options, params: serializeParams(params) } : void 0
            };
          },
          call: function (index, params, body, options, stateOptions) {
            var _this, compilation, funcParams, handler, rawFunc, serialization, state, translated;
            _this = this;
            funcParams = this.objectParam(index, [
              {
                key: this["const"](index, "macroName"),
                value: this.param(
                  index,
                  this.ident(index, "macroName"),
                  void 0,
                  false,
                  true,
                  void 0
                )
              },
              {
                key: this["const"](index, "macroData"),
                value: this.arrayParam(index, params)
              }
            ]);
            rawFunc = makeMacroRoot.call(this, index, funcParams, body);
            translated = require("./translator")(this.macroExpandAll(rawFunc).reduce(this), { "return": true });
            compilation = translated.node.toString();
            if (stateOptions.serializeMacros) {
              serialization = compilation;
            }
            handler = Function(compilation)();
            if (typeof handler !== "function") {
              throw Error("Error creating function for macro: " + __strnum(this.currentMacro));
            }
            state = this;
            handler = (function (inner) {
              return function (args) {
                var rest;
                rest = __slice.call(arguments, 1);
                return inner.apply(this, [reduceObject(state, args)].concat(__toArray(rest))).reduce(state);
              };
            }(handler));
            return {
              handler: handler,
              rule: InvocationArguments,
              serialization: serialization != null ? { type: "call", code: serialization, options: options, names: this.currentMacro } : void 0
            };
          },
          binaryOperator: function (index, operators, body, options, stateOptions) {
            var _this, compilation, handler, rawFunc, serialization, state, translated;
            _this = this;
            rawFunc = makeMacroRoot.call(
              this,
              index,
              this.objectParam(index, [
                {
                  key: this["const"](index, "left"),
                  value: this.param(
                    index,
                    this.ident(index, "left"),
                    void 0,
                    false,
                    true,
                    void 0
                  )
                },
                {
                  key: this["const"](index, "op"),
                  value: this.param(
                    index,
                    this.ident(index, "op"),
                    void 0,
                    false,
                    true,
                    void 0
                  )
                },
                {
                  key: this["const"](index, "right"),
                  value: this.param(
                    index,
                    this.ident(index, "right"),
                    void 0,
                    false,
                    true,
                    void 0
                  )
                }
              ]),
              body
            );
            translated = require("./translator")(this.macroExpandAll(rawFunc).reduce(this), { "return": true });
            compilation = translated.node.toString();
            if (stateOptions.serializeMacros) {
              serialization = compilation;
            }
            handler = Function(compilation)();
            if (typeof handler !== "function") {
              throw Error("Error creating function for binary operator " + __strnum(operators.join(", ")));
            }
            state = this;
            if (options.invertible) {
              handler = (function (inner) {
                return function (args) {
                  var rest, result;
                  rest = __slice.call(arguments, 1);
                  result = inner.apply(this, [reduceObject(state, args)].concat(__toArray(rest)));
                  if (args.inverted) {
                    return UnaryNode(
                      result.startIndex,
                      result.endIndex,
                      result.scopeId,
                      "!",
                      result
                    ).reduce(state);
                  } else {
                    return result.reduce(state);
                  }
                };
              }(handler));
            } else {
              handler = (function (inner) {
                return function (args) {
                  var rest;
                  rest = __slice.call(arguments, 1);
                  return inner.apply(this, [reduceObject(state, args)].concat(__toArray(rest))).reduce(state);
                };
              }(handler));
            }
            return {
              handler: handler,
              rule: void 0,
              serialization: serialization != null ? { type: "binaryOperator", code: serialization, operators: operators, options: options } : void 0
            };
          },
          assignOperator: function (index, operators, body, options, stateOptions) {
            var _this, compilation, handler, rawFunc, serialization, state, translated;
            _this = this;
            rawFunc = makeMacroRoot.call(
              this,
              index,
              this.objectParam(index, [
                {
                  key: this["const"](index, "left"),
                  value: this.param(
                    index,
                    this.ident(index, "left"),
                    void 0,
                    false,
                    true,
                    void 0
                  )
                },
                {
                  key: this["const"](index, "op"),
                  value: this.param(
                    index,
                    this.ident(index, "op"),
                    void 0,
                    false,
                    true,
                    void 0
                  )
                },
                {
                  key: this["const"](index, "right"),
                  value: this.param(
                    index,
                    this.ident(index, "right"),
                    void 0,
                    false,
                    true,
                    void 0
                  )
                }
              ]),
              body
            );
            translated = require("./translator")(this.macroExpandAll(rawFunc).reduce(this), { "return": true });
            compilation = translated.node.toString();
            if (stateOptions.serializeMacros) {
              serialization = compilation;
            }
            handler = Function(compilation)();
            if (typeof handler !== "function") {
              throw Error("Error creating function for assign operator " + __strnum(operators.join(", ")));
            }
            state = this;
            handler = (function (inner) {
              return function (args) {
                var rest;
                rest = __slice.call(arguments, 1);
                return inner.apply(this, [reduceObject(state, args)].concat(__toArray(rest))).reduce(state);
              };
            }(handler));
            return {
              handler: handler,
              rule: void 0,
              serialization: serialization != null ? { type: "assignOperator", code: serialization, operators: operators, options: options } : void 0
            };
          },
          unaryOperator: function (index, operators, body, options, stateOptions) {
            var _this, compilation, handler, rawFunc, serialization, state, translated;
            _this = this;
            rawFunc = makeMacroRoot.call(
              this,
              index,
              this.objectParam(index, [
                {
                  key: this["const"](index, "op"),
                  value: this.param(
                    index,
                    this.ident(index, "op"),
                    void 0,
                    false,
                    true,
                    void 0
                  )
                },
                {
                  key: this["const"](index, "node"),
                  value: this.param(
                    index,
                    this.ident(index, "node"),
                    void 0,
                    false,
                    true,
                    void 0
                  )
                }
              ]),
              body
            );
            translated = require("./translator")(this.macroExpandAll(rawFunc).reduce(this), { "return": true });
            compilation = translated.node.toString();
            if (stateOptions.serializeMacros) {
              serialization = compilation;
            }
            handler = Function(compilation)();
            if (typeof handler !== "function") {
              throw Error("Error creating function for unary operator " + __strnum(operators.join(", ")));
            }
            state = this;
            handler = (function (inner) {
              return function (args) {
                var rest;
                rest = __slice.call(arguments, 1);
                return inner.apply(this, [reduceObject(state, args)].concat(__toArray(rest))).reduce(state);
              };
            }(handler));
            return {
              handler: handler,
              rule: void 0,
              serialization: serialization != null ? { type: "unaryOperator", code: serialization, operators: operators, options: options } : void 0
            };
          }
        };
        macroDeserializers = {
          syntax: function (_p) {
            var _this, code, handler, id, names, options, params, state;
            _this = this;
            code = _p.code;
            params = _p.params;
            names = _p.names;
            options = _p.options;
            id = _p.id;
            handler = Function(code)();
            if (typeof handler !== "function") {
              throw Error("Error deserializing function for macro " + __strnum(name));
            }
            state = this;
            handler = (function (inner) {
              return function (args) {
                var rest;
                rest = __slice.call(arguments, 1);
                return inner.apply(this, [reduceObject(state, args)].concat(__toArray(rest))).reduce(state);
              };
            }(handler));
            return this.enterMacro(names, function () {
              return handleMacroSyntax.call(
                _this,
                0,
                "syntax",
                handler,
                handleParams.call(_this, deserializeParams(params, _this.scope.id)),
                null,
                options,
                id
              );
            });
          },
          call: function (_p) {
            var _this, code, handler, id, names, options, state;
            _this = this;
            code = _p.code;
            names = _p.names;
            options = _p.options;
            id = _p.id;
            handler = Function(code)();
            if (typeof handler !== "function") {
              throw Error("Error deserializing function for macro " + __strnum(name));
            }
            state = this;
            handler = (function (inner) {
              return function (args) {
                var rest;
                rest = __slice.call(arguments, 1);
                return inner.apply(this, [reduceObject(state, args)].concat(__toArray(rest))).reduce(state);
              };
            }(handler));
            return this.enterMacro(name, function () {
              return handleMacroSyntax.call(
                _this,
                0,
                "call",
                handler,
                InvocationArguments,
                null,
                options,
                id
              );
            });
          },
          defineSyntax: function (_p) {
            var _this, code, handler, id, options, params, state;
            _this = this;
            code = _p.code;
            params = _p.params;
            options = _p.options;
            id = _p.id;
            if (this.macros.hasSyntax(options.name)) {
              throw Error("Cannot override already-defined syntax: " + __strnum(options.name));
            }
            state = this;
            if (code != null) {
              handler = Function(code)();
              if (typeof handler !== "function") {
                throw Error("Error deserializing function for macro syntax " + __strnum(options.name));
              }
              handler = (function (inner) {
                return function (args) {
                  var rest;
                  rest = __slice.call(arguments, 1);
                  return reduceObject(state, inner.apply(this, [reduceObject(state, args)].concat(__toArray(rest))));
                };
              }(handler));
            } else {
              handler = function (args) {
                return reduceObject(state, args);
              };
            }
            return this.enterMacro(DEFINE_SYNTAX, function () {
              return handleMacroSyntax.call(
                _this,
                0,
                "defineSyntax",
                handler,
                handleParams.call(_this, deserializeParams(params, _this.scope.id)),
                null,
                options,
                id
              );
            });
          },
          binaryOperator: function (_p) {
            var _this, code, handler, id, operators, options, state;
            _this = this;
            code = _p.code;
            operators = _p.operators;
            options = _p.options;
            id = _p.id;
            handler = Function(code)();
            if (typeof handler !== "function") {
              throw Error("Error deserializing function for binary operator " + __strnum(operators.join(", ")));
            }
            state = this;
            if (options.invertible) {
              handler = (function (inner) {
                return function (args) {
                  var rest, result;
                  rest = __slice.call(arguments, 1);
                  result = inner.apply(this, [reduceObject(state, args)].concat(__toArray(rest)));
                  if (args.inverted) {
                    return UnaryNode(
                      result.startIndex,
                      result.endIndex,
                      result.scopeId,
                      "!",
                      result
                    ).reduce(state);
                  } else {
                    return result.reduce(state);
                  }
                };
              }(handler));
            } else {
              handler = (function (inner) {
                return function (args) {
                  var rest;
                  rest = __slice.call(arguments, 1);
                  return inner.apply(this, [reduceObject(state, args)].concat(__toArray(rest))).reduce(state);
                };
              }(handler));
            }
            return this.enterMacro(BINARY_OPERATOR, function () {
              return handleMacroSyntax.call(
                _this,
                0,
                "binaryOperator",
                handler,
                void 0,
                operators,
                options,
                id
              );
            });
          },
          assignOperator: function (_p) {
            var _this, code, handler, id, operators, options, state;
            _this = this;
            code = _p.code;
            operators = _p.operators;
            options = _p.options;
            id = _p.id;
            handler = Function(code)();
            if (typeof handler !== "function") {
              throw Error("Error deserializing function for assign operator " + __strnum(operators.join(", ")));
            }
            state = this;
            handler = (function (inner) {
              return function (args) {
                var rest;
                rest = __slice.call(arguments, 1);
                return inner.apply(this, [reduceObject(state, args)].concat(__toArray(rest))).reduce(state);
              };
            }(handler));
            return this.enterMacro(ASSIGN_OPERATOR, function () {
              return handleMacroSyntax.call(
                _this,
                0,
                "assignOperator",
                handler,
                void 0,
                operators,
                options,
                id
              );
            });
          },
          unaryOperator: function (_p) {
            var _this, code, handler, id, operators, options, state;
            _this = this;
            code = _p.code;
            operators = _p.operators;
            options = _p.options;
            id = _p.id;
            handler = Function(code)();
            if (typeof handler !== "function") {
              throw Error("Error deserializing function for unary operator " + __strnum(operators.join(", ")));
            }
            state = this;
            handler = (function (inner) {
              return function (args) {
                var rest;
                rest = __slice.call(arguments, 1);
                return inner.apply(this, [reduceObject(state, args)].concat(__toArray(rest))).reduce(state);
              };
            }(handler));
            this.enterMacro(UNARY_OPERATOR, function () {
              return handleMacroSyntax.call(
                _this,
                0,
                "unaryOperator",
                handler,
                void 0,
                operators,
                options,
                id
              );
            });
          }
        };
        function removeNoops(obj) {
          var _arr, _arr2, _i, _len, item, k, result, v;
          if (Array.isArray(obj)) {
            for (_arr = [], _arr2 = __toArray(obj), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
              item = _arr2[_i];
              if (item instanceof NothingNode) {
                _arr.push(void 0);
              } else {
                _arr.push(removeNoops(item));
              }
            }
            return _arr;
          } else if (obj instanceof Node) {
            return obj;
          } else if (obj && typeof obj === "object" && !(obj instanceof RegExp)) {
            result = {};
            for (k in obj) {
              if (__owns.call(obj, k)) {
                v = obj[k];
                if (!(v instanceof NothingNode)) {
                  result[k] = removeNoops(v);
                }
              }
            }
            return result;
          } else {
            return obj;
          }
        }
        _State_prototype.startMacroSyntax = function (index, params, options) {
          var _arr, _f, _i, _len, _ref, macroId, macros, rule;
          if (!__isArray(params)) {
            throw TypeError("Expected params to be an Array, got " + __typeof(params));
          }
          if (!this.currentMacro) {
            this.error("Attempting to specify a macro syntax when not in a macro");
          }
          rule = handleParams.call(this, params);
          macros = this.macros;
          function mutator(x, o, i, line) {
            if (_inAst.peek() || !o.expandingMacros) {
              return o.macroAccess(
                i,
                macroId,
                line,
                removeNoops(x),
                _position.peek(),
                _inGenerator.peek()
              );
            } else {
              throw Error("Cannot use macro until fully defined");
            }
          }
          for (_arr = __toArray(macros.getOrAddByNames(this.currentMacro)), _i = 0, _len = _arr.length, _f = function (m) {
            return m.data.push((function () {
              var _rule;
              _rule = m.token;
              return (function () {
                function _rule2(o) {
                  var clone, result;
                  clone = o.clone();
                  result = {};
                  return (result.macroName = _rule(clone)) && (result.macroData = rule(clone)) && (o.update(clone), result);
                }
                return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
                  var index, line, result;
                  index = o.index;
                  line = o.line;
                  result = _rule2(o);
                  if (!result) {
                    return false;
                  } else {
                    return mutator(result, o, index, line);
                  }
                });
              }());
            }()));
          }; _i < _len; ++_i) {
            _f.call(this, _arr[_i]);
          }
          macroId = macros.addMacro(mutator, void 0, options.type != null && __owns.call(Type, _ref = options.type) ? Type[_ref] : void 0);
          this.pendingMacroId = macroId;
          return params;
        };
        function handleMacroSyntax(index, type, handler, rule, params, options, macroId) {
          var _this, macros;
          _this = this;
          if (typeof handler !== "function") {
            throw TypeError("Expected handler to be a Function, got " + __typeof(handler));
          }
          macros = this.macros;
          function mutator(x, o, i, line, scopeId) {
            var clone, macroHelper, result, tmps, walker;
            if (_inAst.peek() || !o.expandingMacros) {
              return o.macroAccess(
                i,
                macroId,
                line,
                removeNoops(x),
                _position.peek(),
                _inGenerator.peek()
              );
            } else {
              clone = o.clone(o.getScope(scopeId));
              macroHelper = MacroHelper(clone, i, _position.peek(), _inGenerator.peek());
              result = (function () {
                try {
                  return handler.call(
                    macroHelper,
                    removeNoops(x),
                    __bind(macroHelper, "wrap"),
                    __bind(macroHelper, "node")
                  );
                } catch (e) {
                  if (e instanceof MacroError) {
                    e.line = line;
                    throw e;
                  } else {
                    throw MacroError(e, o.data, i, line);
                  }
                }
              }());
              o.update(clone);
              if (result instanceof Node) {
                walker = function (node) {
                  if (node instanceof MacroAccessNode) {
                    node.line = line;
                  }
                  return node.walk(walker);
                };
                result = walker(result.reduce(_this));
                tmps = macroHelper.getTmps();
                if (tmps.unsaved.length) {
                  return o.tmpWrapper(i, result, tmps.unsaved);
                } else {
                  return result;
                }
              } else {
                return result;
              }
            }
          }
          return macroId = (function () {
            var _arr, _f, _i, _len, _ref, id;
            switch (_this.currentMacro) {
            case BINARY_OPERATOR:
              return macros.addBinaryOperator(params, mutator, options, macroId);
            case ASSIGN_OPERATOR:
              return macros.addAssignOperator(params, mutator, options, macroId);
            case UNARY_OPERATOR:
              return macros.addUnaryOperator(params, mutator, options, macroId);
            case DEFINE_SYNTAX:
              assert(rule);
              macros.addSyntax(options.name, named(rule != null && rule.parserName || "rule", function (o) {
                var index, line, result;
                index = o.index;
                line = o.line;
                result = rule(o);
                if (!result) {
                  return false;
                } else {
                  return mutator(result, o, index, line);
                }
              }));
              return macros.addMacro(mutator, macroId, options.type != null && __owns.call(Type, _ref = options.type) ? Type[_ref] : void 0);
            default:
              assert(rule);
              for (_arr = __toArray(macros.getOrAddByNames(_this.currentMacro)), _i = 0, _len = _arr.length, _f = function (m) {
                var _this;
                _this = this;
                if (this.pendingMacroId != null) {
                  m.data.pop();
                }
                return m.data.push((function () {
                  var _rule;
                  _rule = m.token;
                  return (function () {
                    function _rule2(o) {
                      var clone, result;
                      clone = o.clone();
                      result = {};
                      return (result.macroName = _rule(clone)) && (result.macroData = rule(clone)) && (o.update(clone), result);
                    }
                    return named(_rule2 != null && _rule2.parserName || "<unknown>", function (o) {
                      var index, line, result;
                      index = o.index;
                      line = o.line;
                      result = _rule2(o);
                      if (!result) {
                        return false;
                      } else {
                        return mutator(result, o, index, line);
                      }
                    });
                  }());
                }()));
              }; _i < _len; ++_i) {
                _f.call(_this, _arr[_i]);
              }
              if (_this.pendingMacroId != null) {
                if (macroId != null) {
                  throw Error("Cannot provide the macro id if there is a pending macro id");
                }
                id = _this.pendingMacroId;
                _this.pendingMacroId = null;
                macros.replaceMacro(id, mutator, options.type != null && __owns.call(Type, _ref = options.type) ? Type[_ref] : void 0);
                return id;
              } else {
                return macros.addMacro(mutator, macroId, options.type != null && __owns.call(Type, _ref = options.type) ? Type[_ref] : void 0);
              }
            }
          }());
        }
        _State_prototype.macroSyntax = function (index, type, params, options, body) {
          var _ref, handler, macroId, rule, serialization;
          if (!__isArray(params)) {
            throw TypeError("Expected params to be an Array, got " + __typeof(params));
          }
          if (!__owns.call(macroSyntaxTypes, type)) {
            throw Error("Unknown macro-syntax type: " + __strnum(type));
          }
          if (!this.currentMacro) {
            this.error("Attempting to specify a macro syntax when not in a macro");
          }
          handler = (_ref = macroSyntaxTypes[type].call(
            this,
            index,
            params,
            body,
            options,
            this.options
          )).handler;
          rule = _ref.rule;
          serialization = _ref.serialization;
          macroId = handleMacroSyntax.call(
            this,
            index,
            type,
            handler,
            rule,
            params,
            options
          );
          if (serialization != null) {
            serialization.id = macroId;
            this.macros.addMacroSerialization(serialization);
          }
        };
        BINARY_OPERATOR = freeze({});
        _State_prototype.defineBinaryOperator = function (index, operators, options, body) {
          var _i, _len, _this;
          _this = this;
          if (typeof index !== "number") {
            throw TypeError("Expected index to be a Number, got " + __typeof(index));
          }
          if (!__isArray(operators)) {
            throw TypeError("Expected operators to be an Array, got " + __typeof(operators));
          } else {
            for (_i = 0, _len = operators.length; _i < _len; ++_i) {
              if (typeof operators[_i] !== "string") {
                throw TypeError("Expected operators[" + _i + "] to be a String, got " + __typeof(operators[_i]));
              }
            }
          }
          if (!__isObject(options)) {
            throw TypeError("Expected options to be an Object, got " + __typeof(options));
          }
          if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          return this.enterMacro(BINARY_OPERATOR, function () {
            return _this.macroSyntax(
              index,
              "binaryOperator",
              operators,
              options,
              body
            );
          });
        };
        ASSIGN_OPERATOR = freeze({});
        _State_prototype.defineAssignOperator = function (index, operators, options, body) {
          var _i, _len, _this;
          _this = this;
          if (typeof index !== "number") {
            throw TypeError("Expected index to be a Number, got " + __typeof(index));
          }
          if (!__isArray(operators)) {
            throw TypeError("Expected operators to be an Array, got " + __typeof(operators));
          } else {
            for (_i = 0, _len = operators.length; _i < _len; ++_i) {
              if (typeof operators[_i] !== "string") {
                throw TypeError("Expected operators[" + _i + "] to be a String, got " + __typeof(operators[_i]));
              }
            }
          }
          if (!__isObject(options)) {
            throw TypeError("Expected options to be an Object, got " + __typeof(options));
          }
          if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          return this.enterMacro(ASSIGN_OPERATOR, function () {
            return _this.macroSyntax(
              index,
              "assignOperator",
              operators,
              options,
              body
            );
          });
        };
        UNARY_OPERATOR = freeze({});
        _State_prototype.defineUnaryOperator = function (index, operators, options, body) {
          var _i, _len, _this;
          _this = this;
          if (typeof index !== "number") {
            throw TypeError("Expected index to be a Number, got " + __typeof(index));
          }
          if (!__isArray(operators)) {
            throw TypeError("Expected operators to be an Array, got " + __typeof(operators));
          } else {
            for (_i = 0, _len = operators.length; _i < _len; ++_i) {
              if (typeof operators[_i] !== "string") {
                throw TypeError("Expected operators[" + _i + "] to be a String, got " + __typeof(operators[_i]));
              }
            }
          }
          if (!__isObject(options)) {
            throw TypeError("Expected options to be an Object, got " + __typeof(options));
          }
          if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          return this.enterMacro(UNARY_OPERATOR, function () {
            return _this.macroSyntax(
              index,
              "unaryOperator",
              operators,
              options,
              body
            );
          });
        };
        DEFINE_SYNTAX = freeze({});
        _State_prototype.defineSyntax = function (index, name, params, body) {
          var _this;
          _this = this;
          return this.enterMacro(DEFINE_SYNTAX, function () {
            return _this.macroSyntax(
              index,
              "defineSyntax",
              params,
              { name: name },
              body
            );
          });
        };
        _State_prototype.deserializeMacros = function (data) {
          var _arr, _i, _len, _ref, deserializer, item, type;
          for (type in macroDeserializers) {
            if (__owns.call(macroDeserializers, type)) {
              deserializer = macroDeserializers[type];
              for (_arr = __toArray((_ref = __owns.call(data, type) ? data[type] : void 0) != null ? _ref : []), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                item = _arr[_i];
                deserializer.call(this, item);
              }
            }
          }
        };
        _State_prototype.macroExpand1 = function (node) {
          var _this, oldExpandingMacros, result;
          _this = this;
          if (node._macroExpanded != null) {
            return node._macroExpanded;
          } else if (node instanceof MacroAccessNode) {
            _position.push(node.position);
            _inGenerator.push(node.inGenerator);
            oldExpandingMacros = this.expandingMacros;
            this.expandingMacros = true;
            result = (function () {
              try {
                return _this.macros.getById(node.id)(
                  node.data,
                  _this,
                  node.startIndex,
                  node.line,
                  node.scopeId
                );
              } catch (e) {
                if (e instanceof MacroError) {
                  e.line = node.line;
                }
                throw e;
              } finally {
                _position.pop();
                _inGenerator.pop();
                _this.expandingMacros = oldExpandingMacros;
              }
            }());
            return node._macroExpanded = result instanceof MacroAccessNode ? this.macroExpand1(result) : result;
          } else {
            return node._macroExpanded = node;
          }
        };
        _State_prototype.macroExpandAllAsync = function (node, callback) {
          var _this, startTime;
          _this = this;
          startTime = new Date().getTime();
          function walker(node, callback) {
            var expanded;
            if (__num(new Date().getTime()) - __num(startTime) > 17) {
              return nextTick(function () {
                startTime = new Date().getTime();
                return walker(node, callback);
              });
            }
            if (node._macroExpandAlled != null) {
              return callback(null, node._macroExpandAlled);
            } else if (!(node instanceof MacroAccessNode)) {
              return node.walkAsync(walker, function (_e, walked) {
                if (_e != null) {
                  return callback(_e);
                }
                walked._macroExpanded = walked;
                return callback(null, walked);
              });
            } else {
              try {
                expanded = _this.macroExpand1(node);
              } catch (e) {
                return callback(e);
              }
              if (!(expanded instanceof Node)) {
                return callback(null, node._macroExpandAlled = expanded);
              }
              return walker(expanded, function (_e, walked) {
                if (_e != null) {
                  return callback(_e);
                }
                return callback(null, expanded._macroExpandAlled = walked._macroExpanded = walked);
              });
            }
          }
          return walker(node, callback);
        };
        _State_prototype.macroExpandAll = function (node, callback) {
          var _this;
          _this = this;
          function walker(node) {
            var expanded, walked;
            if (node._macroExpandAlled != null) {
              return node._macroExpandAlled;
            } else if (!(node instanceof MacroAccessNode)) {
              walked = node.walk(walker);
              return walked._macroExpanded = walked;
            } else {
              expanded = _this.macroExpand1(node);
              if (!(expanded instanceof Node)) {
                return node._macroExpandAlled = expanded;
              }
              walked = walker(expanded);
              return expanded._macroExpandAlled = walked._macroExpanded = walked;
            }
          }
          return walker(node);
        };
        State.addNodeFactory = function (name, type) {
          State.prototype[name] = function (index) {
            var args;
            args = __slice.call(arguments, 1);
            return type.apply(void 0, [index, this.index, this.scope.id].concat(__toArray(args)));
          };
        };
        return State;
      }());
      Node.Access = AccessNode = (function (Node) {
        var _AccessNode_prototype, _Node_prototype;
        function AccessNode(startIndex, endIndex, scopeId, parent, child) {
          var _this;
          _this = this instanceof AccessNode ? this : __create(_AccessNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(parent instanceof Node)) {
            throw TypeError("Expected parent to be a Node, got " + __typeof(parent));
          }
          if (!(child instanceof Node)) {
            throw TypeError("Expected child to be a Node, got " + __typeof(child));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.parent = parent;
          _this.child = child;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _AccessNode_prototype = AccessNode.prototype = __create(_Node_prototype);
        _AccessNode_prototype.constructor = AccessNode;
        AccessNode.displayName = "AccessNode";
        AccessNode.cappedName = "Access";
        AccessNode.argNames = ["parent", "child"];
        State.addNodeFactory("access", AccessNode);
        _AccessNode_prototype.type = function (o) {
          var _ref, _this;
          _this = this;
          if ((_ref = this._type) == null) {
            return this._type = (function () {
              var child, childType, childValue, isString, parentType;
              parentType = _this.parent.type(o);
              isString = parentType.isSubsetOf(Type.string);
              if (isString || parentType.isSubsetOf(Type.arrayLike)) {
                child = o.macroExpand1(_this.child).reduce(o);
                if (child.isConst()) {
                  childValue = child.constValue();
                  if (childValue === "length") {
                    return Type.number;
                  } else if (typeof childValue === "number") {
                    if (__num(childValue) >= 0 && __num(childValue) % 1 === 0) {
                      if (isString) {
                        return Type.string.union(Type["undefined"]);
                      } else if (parentType.subtype) {
                        return parentType.subtype.union(Type["undefined"]);
                      } else {
                        return Type.any;
                      }
                    } else {
                      return Type["undefined"];
                    }
                  }
                } else {
                  childType = child.type(o);
                  if (childType.isSubsetOf(Type.number)) {
                    if (isString) {
                      return Type.string.union(Type["undefined"]);
                    } else if (parentType.subtype) {
                      return parentType.subtype.union(Type["undefined"]);
                    } else {
                      return Type.any;
                    }
                  }
                }
              } else if (parentType.isSubsetOf(Type.object) && typeof parentType.value === "function") {
                child = o.macroExpand1(_this.child).reduce(o);
                if (child.isConst()) {
                  return parentType.value(String(child.constValue()));
                }
              }
              return Type.any;
            }());
          } else {
            return _ref;
          }
        };
        _AccessNode_prototype._reduce = function (o) {
          var _ref, args, cachedParent, child, cValue, end, hasEnd, hasStep, inclusive, parent, pValue, start, step, value;
          parent = this.parent.reduce(o).doWrap(o);
          cachedParent = null;
          function replaceLengthIdent(node) {
            var nodeParent;
            if (node instanceof IdentNode && node.name === CURRENT_ARRAY_LENGTH_NAME) {
              if (parent.cacheable && cachedParent == null) {
                cachedParent = TmpNode(
                  node.startIndex,
                  node.endIndex,
                  node.scopeId,
                  getTmpId(),
                  "ref",
                  parent.type(o)
                );
              }
              return AccessNode(
                node.startIndex,
                node.endIndex,
                node.scopeId,
                cachedParent != null ? cachedParent : parent,
                ConstNode(node.startIndex, node.endIndex, node.scopeId, "length")
              );
            } else if (node instanceof AccessNode) {
              nodeParent = replaceLengthIdent(node.parent);
              if (nodeParent !== node.parent) {
                return AccessNode(
                  node.startIndex,
                  node.endIndex,
                  node.scopeId,
                  nodeParent,
                  node.child
                ).walk(replaceLengthIdent);
              } else {
                return node.walk(replaceLengthIdent);
              }
            } else {
              return node.walk(replaceLengthIdent);
            }
          }
          child = replaceLengthIdent(this.child.reduce(o).doWrap(o));
          if (cachedParent != null) {
            return TmpWrapperNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              AccessNode(
                this.startIndex,
                this.endIndex,
                this.scopeId,
                AssignNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  cachedParent,
                  "=",
                  parent
                ),
                child
              ),
              [cachedParent.id]
            );
          }
          if (parent.isConst() && child.isConst()) {
            pValue = parent.constValue();
            cValue = child.constValue();
            if (cValue in Object(pValue)) {
              value = pValue[cValue];
              if (value === null || value instanceof RegExp || (_ref = typeof value) === "string" || _ref === "number" || _ref === "boolean" || _ref === "undefined") {
                return ConstNode(this.startIndex, this.endIndex, this.scopeId, value);
              }
            }
          }
          if (child instanceof CallNode && child.func instanceof IdentNode && child.func.name === "__range") {
            start = (_ref = child.args)[0];
            end = _ref[1];
            step = _ref[2];
            inclusive = _ref[3];
            hasStep = !step.isConst() || step.constValue() !== 1;
            if (!hasStep) {
              if (inclusive.isConst()) {
                if (inclusive.constValue()) {
                  end = end.isConst() && typeof end.constValue() === "number" ? ConstNode(end.startIndex, end.endIndex, end.scopeId, __num(end.constValue()) + 1 || 1/0)
                    : BinaryNode(
                      end.startIndex,
                      end.endIndex,
                      end.scopeId,
                      BinaryNode(
                        end.startIndex,
                        end.endIndex,
                        end.scopeId,
                        end,
                        "+",
                        ConstNode(inclusive.startIndex, inclusive.endIndex, inclusive.scopeId, 1)
                      ),
                      "||",
                      ConstNode(end.startIndex, end.endIndex, end.scopeId, 1/0)
                    );
                }
              } else {
                end = IfNode(
                  end.startIndex,
                  end.endIndex,
                  end.scopeId,
                  inclusive,
                  BinaryNode(
                    end.startIndex,
                    end.endIndex,
                    end.scopeId,
                    BinaryNode(
                      end.startIndex,
                      end.endIndex,
                      end.scopeId,
                      end,
                      "+",
                      ConstNode(inclusive.startIndex, inclusive.endIndex, inclusive.scopeId, 1)
                    ),
                    "||",
                    ConstNode(end.startIndex, end.endIndex, end.scopeId, 1/0)
                  ),
                  end
                );
              }
            }
            args = [parent];
            hasEnd = !end.isConst() || (_ref = end.constValue()) !== void 0 && _ref !== 1/0;
            if (!start.isConst() || start.constValue() !== 0 || hasEnd || hasStep) {
              args.push(start);
            }
            if (hasEnd || hasStep) {
              args.push(end);
            }
            if (hasStep) {
              args.push(step);
              if (!inclusive.isConst() || inclusive.constValue()) {
                args.push(inclusive);
              }
            }
            return CallNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              IdentNode(this.startIndex, this.endIndex, this.scopeId, hasStep ? "__sliceStep" : "__slice"),
              args,
              false,
              !hasStep
            ).reduce(o);
          } else if (parent !== this.parent || child !== this.child) {
            return AccessNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              parent,
              child
            );
          } else {
            return this;
          }
        };
        _AccessNode_prototype._isNoop = function (o) {
          var _ref;
          if ((_ref = this.__isNoop) == null) {
            return this.__isNoop = this.parent.isNoop(o) && this.child.isNoop(o);
          } else {
            return _ref;
          }
        };
        _AccessNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "AccessNode", this.parent, this.child);
        };
        _AccessNode_prototype.walk = function (f) {
          var child, parent;
          parent = f(this.parent);
          child = f(this.child);
          if (parent !== this.parent || child !== this.child) {
            return AccessNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              parent,
              child
            );
          } else {
            return this;
          }
        };
        _AccessNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.parent, function (_e, parent) {
            if (_e != null) {
              return callback(_e);
            }
            return f(_this.child, function (_e2, child) {
              if (_e2 != null) {
                return callback(_e2);
              }
              return callback(null, parent !== _this.parent || child !== _this.child
                ? AccessNode(
                  _this.startIndex,
                  _this.endIndex,
                  _this.scopeId,
                  parent,
                  child
                )
                : _this);
            });
          });
        };
        return AccessNode;
      }(Node));
      Node.AccessMulti = AccessMultiNode = (function (Node) {
        var _AccessMultiNode_prototype, _Node_prototype;
        function AccessMultiNode(startIndex, endIndex, scopeId, parent, elements) {
          var _i, _len, _this;
          _this = this instanceof AccessMultiNode ? this : __create(_AccessMultiNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(parent instanceof Node)) {
            throw TypeError("Expected parent to be a Node, got " + __typeof(parent));
          }
          if (!__isArray(elements)) {
            throw TypeError("Expected elements to be an Array, got " + __typeof(elements));
          } else {
            for (_i = 0, _len = elements.length; _i < _len; ++_i) {
              if (!(elements[_i] instanceof Node)) {
                throw TypeError("Expected elements[" + _i + "] to be a Node, got " + __typeof(elements[_i]));
              }
            }
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.parent = parent;
          _this.elements = elements;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _AccessMultiNode_prototype = AccessMultiNode.prototype = __create(_Node_prototype);
        _AccessMultiNode_prototype.constructor = AccessMultiNode;
        AccessMultiNode.displayName = "AccessMultiNode";
        AccessMultiNode.cappedName = "AccessMulti";
        AccessMultiNode.argNames = ["parent", "elements"];
        State.addNodeFactory("accessMulti", AccessMultiNode);
        _AccessMultiNode_prototype.type = function () {
          return Type.array;
        };
        _AccessMultiNode_prototype._reduce = function (o) {
          var _this, parent, result, setParent, tmp, tmpIds;
          _this = this;
          parent = this.parent.reduce(o);
          setParent = parent;
          tmpIds = [];
          if (parent.cacheable) {
            tmp = o.tmp(this.startIndex, getTmpId(), "ref", parent.type(o));
            tmpIds.push(tmp.id);
            setParent = o.assign(i, tmp, "=", parent.doWrap(o));
            parent = tmp;
          }
          result = o.array(this.startIndex, (function () {
            var _arr, _arr2, _len, element, j;
            for (_arr = [], _arr2 = __toArray(_this.elements), j = 0, _len = _arr2.length; j < _len; ++j) {
              element = _arr2[j];
              _arr.push(o.access(
                _this.startIndex,
                j === 0 ? setParent : parent,
                element.reduce(o)
              ));
            }
            return _arr;
          }()));
          if (tmpIds.length) {
            return o.tmpWrapper(this.startIndex, result, tmpIds);
          } else {
            return result;
          }
        };
        _AccessMultiNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "AccessMultiNode", this.parent, this.elements);
        };
        _AccessMultiNode_prototype.walk = function (f) {
          var elements, parent;
          parent = f(this.parent);
          elements = map(this.elements, f);
          if (parent !== this.parent || elements !== this.elements) {
            return AccessMultiNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              parent,
              elements
            );
          } else {
            return this;
          }
        };
        _AccessMultiNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.parent, function (_e, parent) {
            if (_e != null) {
              return callback(_e);
            }
            return mapAsync(_this.elements, f, function (_e2, elements) {
              if (_e2 != null) {
                return callback(_e2);
              }
              return callback(null, parent !== _this.parent || elements !== _this.elements
                ? AccessMultiNode(
                  _this.startIndex,
                  _this.endIndex,
                  _this.scopeId,
                  parent,
                  elements
                )
                : _this);
            });
          });
        };
        return AccessMultiNode;
      }(Node));
      Node.Args = ArgsNode = (function (Node) {
        var _ArgsNode_prototype, _Node_prototype;
        function ArgsNode(startIndex, endIndex, scopeId) {
          var _this;
          _this = this instanceof ArgsNode ? this : __create(_ArgsNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _ArgsNode_prototype = ArgsNode.prototype = __create(_Node_prototype);
        _ArgsNode_prototype.constructor = ArgsNode;
        ArgsNode.displayName = "ArgsNode";
        ArgsNode.cappedName = "Args";
        ArgsNode.argNames = [];
        State.addNodeFactory("args", ArgsNode);
        _ArgsNode_prototype.type = function () {
          return Type.args;
        };
        _ArgsNode_prototype.cacheable = false;
        _ArgsNode_prototype._isNoop = function () {
          return true;
        };
        _ArgsNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "ArgsNode");
        };
        return ArgsNode;
      }(Node));
      Node.Array = ArrayNode = (function (Node) {
        var _ArrayNode_prototype, _Node_prototype;
        function ArrayNode(startIndex, endIndex, scopeId, elements) {
          var _i, _len, _this;
          _this = this instanceof ArrayNode ? this : __create(_ArrayNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!__isArray(elements)) {
            throw TypeError("Expected elements to be an Array, got " + __typeof(elements));
          } else {
            for (_i = 0, _len = elements.length; _i < _len; ++_i) {
              if (!(elements[_i] instanceof Node)) {
                throw TypeError("Expected elements[" + _i + "] to be a Node, got " + __typeof(elements[_i]));
              }
            }
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.elements = elements;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _ArrayNode_prototype = ArrayNode.prototype = __create(_Node_prototype);
        _ArrayNode_prototype.constructor = ArrayNode;
        ArrayNode.displayName = "ArrayNode";
        ArrayNode.cappedName = "Array";
        ArrayNode.argNames = ["elements"];
        State.addNodeFactory("array", ArrayNode);
        _ArrayNode_prototype.type = function () {
          return Type.array;
        };
        _ArrayNode_prototype._reduce = function (o) {
          var elements;
          elements = map(this.elements, function (x) {
            return x.reduce(o).doWrap(o);
          });
          if (elements !== this.elements) {
            return ArrayNode(this.startIndex, this.endIndex, this.scopeId, elements);
          } else {
            return this;
          }
        };
        _ArrayNode_prototype._isNoop = function (o) {
          var _ref, _this;
          _this = this;
          if ((_ref = this.__isNoop) == null) {
            return this.__isNoop = (function () {
              var _arr, _i, _len, element;
              for (_arr = __toArray(_this.elements), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                element = _arr[_i];
                if (!element.isNoop(o)) {
                  return false;
                }
              }
              return true;
            }());
          } else {
            return _ref;
          }
        };
        _ArrayNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "ArrayNode", this.elements);
        };
        _ArrayNode_prototype.walk = function (f) {
          var elements;
          elements = map(this.elements, f);
          if (elements !== this.elements) {
            return ArrayNode(this.startIndex, this.endIndex, this.scopeId, elements);
          } else {
            return this;
          }
        };
        _ArrayNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return mapAsync(this.elements, f, function (_e, elements) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, elements !== _this.elements ? ArrayNode(_this.startIndex, _this.endIndex, _this.scopeId, elements) : _this);
          });
        };
        return ArrayNode;
      }(Node));
      State.prototype.arrayParam = State.prototype.array;
      Node.Assign = AssignNode = (function (Node) {
        var _AssignNode_prototype, _Node_prototype;
        function AssignNode(startIndex, endIndex, scopeId, left, op, right) {
          var _this;
          _this = this instanceof AssignNode ? this : __create(_AssignNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(left instanceof Node)) {
            throw TypeError("Expected left to be a Node, got " + __typeof(left));
          }
          if (typeof op !== "string") {
            throw TypeError("Expected op to be a String, got " + __typeof(op));
          }
          if (!(right instanceof Node)) {
            throw TypeError("Expected right to be a Node, got " + __typeof(right));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.left = left;
          _this.op = op;
          _this.right = right;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _AssignNode_prototype = AssignNode.prototype = __create(_Node_prototype);
        _AssignNode_prototype.constructor = AssignNode;
        AssignNode.displayName = "AssignNode";
        AssignNode.cappedName = "Assign";
        AssignNode.argNames = ["left", "op", "right"];
        State.addNodeFactory("assign", AssignNode);
        _AssignNode_prototype.type = (function () {
          var ops;
          ops = {
            "=": function (left, right) {
              return right;
            },
            "+=": function (left, right) {
              if (left.isSubsetOf(Type.numeric) && right.isSubsetOf(Type.numeric)) {
                return Type.number;
              } else if (left.overlaps(Type.numeric) && right.overlaps(Type.numeric)) {
                return Type.stringOrNumber;
              } else {
                return Type.string;
              }
            },
            "-=": Type.number,
            "*=": Type.number,
            "/=": Type.number,
            "%=": Type.number,
            "<<=": Type.number,
            ">>=": Type.number,
            ">>>=": Type.number,
            "&=": Type.number,
            "^=": Type.number,
            "|=": Type.number
          };
          return function (o) {
            var _ref, _this;
            _this = this;
            if ((_ref = this._type) == null) {
              return this._type = (function () {
                var _ref, type;
                if (__owns.call(ops, _ref = _this.op)) {
                  type = ops[_ref];
                }
                if (!type) {
                  return Type.any;
                } else if (typeof type === "function") {
                  return type(_this.left.type(o), _this.right.type(o));
                } else {
                  return type;
                }
              }());
            } else {
              return _ref;
            }
          };
        }());
        _AssignNode_prototype._reduce = function (o) {
          var left, right;
          left = this.left.reduce(o);
          right = this.right.reduce(o).doWrap(o);
          if (left !== this.left || right !== this.right) {
            return AssignNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              left,
              this.op,
              right
            );
          } else {
            return this;
          }
        };
        _AssignNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "AssignNode",
            this.left,
            this.op,
            this.right
          );
        };
        _AssignNode_prototype.walk = function (f) {
          var left, right;
          left = f(this.left);
          right = f(this.right);
          if (left !== this.left || right !== this.right) {
            return AssignNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              left,
              this.op,
              right
            );
          } else {
            return this;
          }
        };
        _AssignNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.left, function (_e, left) {
            if (_e != null) {
              return callback(_e);
            }
            return f(_this.right, function (_e2, right) {
              if (_e2 != null) {
                return callback(_e2);
              }
              return callback(null, left !== _this.left || right !== _this.right
                ? AssignNode(
                  _this.startIndex,
                  _this.endIndex,
                  _this.scopeId,
                  left,
                  _this.op,
                  right
                )
                : _this);
            });
          });
        };
        return AssignNode;
      }(Node));
      Node.Binary = BinaryNode = (function (Node) {
        var _BinaryNode_prototype, _Node_prototype;
        function BinaryNode(startIndex, endIndex, scopeId, left, op, right) {
          var _this;
          _this = this instanceof BinaryNode ? this : __create(_BinaryNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(left instanceof Node)) {
            throw TypeError("Expected left to be a Node, got " + __typeof(left));
          }
          if (typeof op !== "string") {
            throw TypeError("Expected op to be a String, got " + __typeof(op));
          }
          if (!(right instanceof Node)) {
            throw TypeError("Expected right to be a Node, got " + __typeof(right));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.left = left;
          _this.op = op;
          _this.right = right;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _BinaryNode_prototype = BinaryNode.prototype = __create(_Node_prototype);
        _BinaryNode_prototype.constructor = BinaryNode;
        BinaryNode.displayName = "BinaryNode";
        BinaryNode.cappedName = "Binary";
        BinaryNode.argNames = ["left", "op", "right"];
        State.addNodeFactory("binary", BinaryNode);
        _BinaryNode_prototype.type = (function () {
          var ops;
          ops = {
            "*": Type.number,
            "/": Type.number,
            "%": Type.number,
            "+": function (left, right) {
              if (left.isSubsetOf(Type.numeric) && right.isSubsetOf(Type.numeric)) {
                return Type.number;
              } else if (left.overlaps(Type.numeric) && right.overlaps(Type.numeric)) {
                return Type.stringOrNumber;
              } else {
                return Type.string;
              }
            },
            "-": Type.number,
            "<<": Type.number,
            ">>": Type.number,
            ">>>": Type.number,
            "<": Type.boolean,
            "<=": Type.boolean,
            ">": Type.boolean,
            ">=": Type.boolean,
            "in": Type.boolean,
            "instanceof": Type.boolean,
            "==": Type.boolean,
            "!=": Type.boolean,
            "===": Type.boolean,
            "!==": Type.boolean,
            "&": Type.number,
            "^": Type.number,
            "|": Type.number,
            "&&": function (left, right) {
              return left.intersect(Type.potentiallyFalsy).union(right);
            },
            "||": function (left, right) {
              return left.intersect(Type.potentiallyTruthy).union(right);
            }
          };
          return function (o) {
            var _ref, _this;
            _this = this;
            if ((_ref = this._type) == null) {
              return this._type = (function () {
                var _ref, type;
                if (__owns.call(ops, _ref = _this.op)) {
                  type = ops[_ref];
                }
                if (!type) {
                  return Type.any;
                } else if (typeof type === "function") {
                  return type(_this.left.type(o), _this.right.type(o));
                } else {
                  return type;
                }
              }());
            } else {
              return _ref;
            }
          };
        }());
        _BinaryNode_prototype._reduce = (function () {
          var constOps, leftConstOps, nonConstOps, rightConstOps;
          constOps = {
            "*": function (x, y) {
              return x * y;
            },
            "/": function (x, y) {
              return x / y;
            },
            "%": function (x, y) {
              return x % y;
            },
            "+": (function () {
              function isJSNumeric(x) {
                var _ref;
                return x === null || (_ref = typeof x) === "number" || _ref === "boolean" || _ref === "undefined";
              }
              return function (left, right) {
                if (isJSNumeric(left) && isJSNumeric(right)) {
                  return left - -right;
                } else {
                  return "" + left + right;
                }
              };
            }()),
            "-": function (x, y) {
              return x - y;
            },
            "<<": function (x, y) {
              return x << y;
            },
            ">>": function (x, y) {
              return x >> y;
            },
            ">>>": function (x, y) {
              return x >>> y;
            },
            "<": function (x, y) {
              return x < y;
            },
            "<=": function (x, y) {
              return x <= y;
            },
            ">": function (x, y) {
              return x > y;
            },
            ">=": function (x, y) {
              return x >= y;
            },
            "==": function (x, y) {
              return x == y;
            },
            "!=": function (x, y) {
              return x != y;
            },
            "===": function (x, y) {
              return x === y;
            },
            "!==": function (x, y) {
              return x !== y;
            },
            "&": function (x, y) {
              return x & y;
            },
            "^": function (x, y) {
              return x ^ y;
            },
            "|": function (x, y) {
              return x | y;
            },
            "&&": function (x, y) {
              return x && y;
            },
            "||": function (x, y) {
              return x || y;
            }
          };
          function leftConstNan(x, y) {
            var _ref;
            if ((_ref = x.constValue()) !== _ref) {
              return BlockNode(this.startIndex, this.endIndex, this.scopeId, [y, x]);
            }
          }
          leftConstOps = {
            "*": function (x, y) {
              var _ref;
              if (x.constValue() === 1) {
                return UnaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  "+",
                  y
                );
              } else if (x.constValue() === -1) {
                return UnaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  "-",
                  y
                );
              } else if ((_ref = x.constValue()) !== _ref) {
                return BlockNode(this.startIndex, this.endIndex, this.scopeId, [y, x]);
              }
            },
            "/": leftConstNan,
            "%": leftConstNan,
            "+": function (x, y, o) {
              var _ref;
              if (x.constValue() === 0 && y.type(o).isSubsetOf(Type.number)) {
                return UnaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  "+",
                  y
                );
              } else if (x.constValue() === "" && y.type(o).isSubsetOf(Type.string)) {
                return y;
              } else if (typeof x.constValue() === "string" && y instanceof BinaryNode && y.op === "+" && y.left.isConst() && typeof y.left.constValue() === "string") {
                return BinaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  ConstNode(x.startIndex, y.left.endIndex, this.scopeId, __strnum(x.constValue()) + __strnum(y.left.constValue())),
                  "+",
                  y.right
                );
              } else if ((_ref = x.constValue()) !== _ref) {
                return BlockNode(this.startIndex, this.endIndex, this.scopeId, [y, x]);
              }
            },
            "-": function (x, y) {
              var _ref;
              if (x.constValue() === 0) {
                return UnaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  "-",
                  y
                );
              } else if ((_ref = x.constValue()) !== _ref) {
                return BlockNode(this.startIndex, this.endIndex, this.scopeId, [y, x]);
              }
            },
            "<<": leftConstNan,
            ">>": leftConstNan,
            ">>>": leftConstNan,
            "&": leftConstNan,
            "|": leftConstNan,
            "^": leftConstNan,
            "&&": function (x, y) {
              if (x.constValue()) {
                return y;
              } else {
                return x;
              }
            },
            "||": function (x, y) {
              if (x.constValue()) {
                return x;
              } else {
                return y;
              }
            }
          };
          function rightConstNan(x, y) {
            var _ref;
            if ((_ref = y.constValue()) !== _ref) {
              return BlockNode(this.startIndex, this.endIndex, this.scopeId, [x, y]);
            }
          }
          rightConstOps = {
            "*": function (x, y) {
              var _ref;
              if (y.constValue() === 1) {
                return UnaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  "+",
                  x
                );
              } else if (y.constValue() === -1) {
                return UnaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  "-",
                  x
                );
              } else if ((_ref = y.constValue()) !== _ref) {
                return BlockNode(this.startIndex, this.endIndex, this.scopeId, [x, y]);
              }
            },
            "/": function (x, y) {
              var _ref;
              if (y.constValue() === 1) {
                return UnaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  "+",
                  x
                );
              } else if (y.constValue() === -1) {
                return UnaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  "-",
                  x
                );
              } else if ((_ref = y.constValue()) !== _ref) {
                return BlockNode(this.startIndex, this.endIndex, this.scopeId, [x, y]);
              }
            },
            "%": rightConstNan,
            "+": function (x, y, o) {
              var _ref;
              if (y.constValue() === 0 && x.type(o).isSubsetOf(Type.number)) {
                return UnaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  "+",
                  x
                );
              } else if (typeof y.constValue() === "number" && __num(y.value) < 0 && x.type(o).isSubsetOf(Type.number)) {
                return BinaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  x,
                  "-",
                  ConstNode(y.startIndex, y.endIndex, this.scopeId, -__num(y.constValue()))
                );
              } else if (y.constValue() === "" && x.type(o).isSubsetOf(Type.string)) {
                return x;
              } else if (typeof y.constValue() === "string" && x instanceof BinaryNode && x.op === "+" && x.right.isConst() && typeof x.right.constValue() === "string") {
                return BinaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  x.left,
                  "+",
                  ConstNode(x.right.startIndex, y.endIndex, this.scopeId, __strnum(x.right.constValue()) + __strnum(y.constValue()))
                );
              } else if ((_ref = y.constValue()) !== _ref) {
                return BlockNode(this.startIndex, this.endIndex, this.scopeId, [x, y]);
              }
            },
            "-": function (x, y, o) {
              var _ref;
              if (y.constValue() === 0) {
                return UnaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  "+",
                  x
                );
              } else if (typeof y.constValue() === "number" && __num(y.constValue()) < 0 && x.type(o).isSubsetOf(Type.number)) {
                return BinaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  x,
                  "+",
                  ConstNode(y.startIndex, y.endIndex, this.scopeId, -__num(y.constValue()))
                );
              } else if ((_ref = y.constValue()) !== _ref) {
                return BlockNode(this.startIndex, this.endIndex, this.scopeId, [x, y]);
              }
            },
            "<<": rightConstNan,
            ">>": rightConstNan,
            ">>>": rightConstNan,
            "&": rightConstNan,
            "|": rightConstNan,
            "^": rightConstNan
          };
          nonConstOps = {
            "&&": function (x, y, o) {
              var truthy, xRightType, xType;
              xType = x.type(o);
              if (xType.isSubsetOf(Type.alwaysTruthy)) {
                return BlockNode(this.startIndex, this.endIndex, this.scopeId, [x, y]);
              } else if (xType.isSubsetOf(Type.alwaysFalsy)) {
                return x;
              } else if (x instanceof BinaryNode && x.op === "&&") {
                if (x.right.isConst()) {
                  truthy = !!x.right.constValue();
                } else {
                  xRightType = x.right.type(o);
                  if (xRightType.isSubsetOf(Type.alwaysTruthy)) {
                    truthy = true;
                  } else if (xRightType.isSubsetOf(Type.alwaysFalsy)) {
                    truthy = false;
                  } else {
                    truthy = null;
                  }
                }
                if (truthy === true) {
                  return BinaryNode(
                    this.startIndex,
                    this.endIndex,
                    this.scopeId,
                    x.left,
                    "&&",
                    BlockNode(this.startIndex, this.endIndex, this.scopeId, [x.right, y])
                  );
                } else if (truthy === false) {
                  return x;
                }
              }
            },
            "||": function (x, y, o) {
              var test, truthy, whenTrue, xRightType, xType;
              xType = x.type(o);
              if (xType.isSubsetOf(Type.alwaysTruthy)) {
                return x;
              } else if (xType.isSubsetOf(Type.alwaysFalsy)) {
                return BlockNode(this.startIndex, this.endIndex, this.scopeId, [x, y]);
              } else if (x instanceof BinaryNode && x.op === "||") {
                if (x.right.isConst()) {
                  truthy = !!x.right.constValue();
                } else {
                  xRightType = x.right.type(o);
                  if (xRightType.isSubsetOf(Type.alwaysTruthy)) {
                    truthy = true;
                  } else if (xRightType.isSubsetOf(Type.alwaysFalsy)) {
                    truthy = false;
                  } else {
                    truthy = null;
                  }
                }
                if (truthy === true) {
                  return x;
                } else if (truthy === false) {
                  return BinaryNode(
                    this.startIndex,
                    this.endIndex,
                    this.scopeId,
                    x.left,
                    "||",
                    BlockNode(this.startIndex, this.endIndex, this.scopeId, [x.right, y])
                  );
                }
              } else if (x instanceof IfNode && x.whenFalse.isConst() && !x.whenFalse.constValue()) {
                test = x.test;
                whenTrue = x.whenTrue;
                while (whenTrue instanceof IfNode && whenTrue.whenFalse.isConst() && !whenTrue.whenFalse.constValue()) {
                  test = BinaryNode(
                    x.startIndex,
                    x.endIndex,
                    x.scopeId,
                    test,
                    "&&",
                    whenTrue.test
                  );
                  whenTrue = whenTrue.whenTrue;
                }
                return BinaryNode(
                  this.startIndex,
                  this.endIndex,
                  this.scopeId,
                  BinaryNode(
                    x.startIndex,
                    x.endIndex,
                    x.scopeId,
                    test,
                    "&&",
                    whenTrue
                  ),
                  "||",
                  y
                );
              }
            }
          };
          return function (o) {
            var _ref, left, op, right;
            left = this.left.reduce(o).doWrap(o);
            right = this.right.reduce(o).doWrap(o);
            op = this.op;
            if (left.isConst()) {
              if (right.isConst() && __owns.call(constOps, op)) {
                return ConstNode(this.startIndex, this.endIndex, this.scopeId, constOps[op](left.constValue(), right.constValue()));
              }
              if (__owns.call(leftConstOps, op) && (_ref = leftConstOps[op].call(this, left, right, o)) != null) {
                return _ref;
              }
            }
            if (right.isConst() && __owns.call(rightConstOps, op) && (_ref = rightConstOps[op].call(this, left, right, o)) != null) {
              return _ref;
            }
            if (__owns.call(nonConstOps, op) && (_ref = nonConstOps[op].call(this, left, right, o)) != null) {
              return _ref;
            }
            if (left !== this.left || right !== this.right) {
              return BinaryNode(
                this.startIndex,
                this.endIndex,
                this.scopeId,
                left,
                op,
                right
              );
            } else {
              return this;
            }
          };
        }());
        _BinaryNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "BinaryNode",
            this.left,
            this.op,
            this.right
          );
        };
        _BinaryNode_prototype.walk = function (f) {
          var left, right;
          left = f(this.left);
          right = f(this.right);
          if (left !== this.left || right !== this.right) {
            return BinaryNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              left,
              this.op,
              right
            );
          } else {
            return this;
          }
        };
        _BinaryNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.left, function (_e, left) {
            if (_e != null) {
              return callback(_e);
            }
            return f(_this.right, function (_e2, right) {
              if (_e2 != null) {
                return callback(_e2);
              }
              return callback(null, left !== _this.left || right !== _this.right
                ? BinaryNode(
                  _this.startIndex,
                  _this.endIndex,
                  _this.scopeId,
                  left,
                  _this.op,
                  right
                )
                : _this);
            });
          });
        };
        return BinaryNode;
      }(Node));
      Node.Block = BlockNode = (function (Node) {
        var _BlockNode_prototype, _Node_prototype;
        function BlockNode(startIndex, endIndex, scopeId, nodes, label) {
          var _i, _len, _this;
          _this = this instanceof BlockNode ? this : __create(_BlockNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!__isArray(nodes)) {
            throw TypeError("Expected nodes to be an Array, got " + __typeof(nodes));
          } else {
            for (_i = 0, _len = nodes.length; _i < _len; ++_i) {
              if (!(nodes[_i] instanceof Node)) {
                throw TypeError("Expected nodes[" + _i + "] to be a Node, got " + __typeof(nodes[_i]));
              }
            }
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.nodes = nodes;
          _this.label = label;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _BlockNode_prototype = BlockNode.prototype = __create(_Node_prototype);
        _BlockNode_prototype.constructor = BlockNode;
        BlockNode.displayName = "BlockNode";
        BlockNode.cappedName = "Block";
        BlockNode.argNames = ["nodes", "label"];
        State.addNodeFactory("block", BlockNode);
        _BlockNode_prototype.type = function (o) {
          var nodes;
          nodes = this.nodes;
          if (nodes.length === 0) {
            return Type["undefined"];
          } else {
            return nodes[__num(nodes.length) - 1].type(o);
          }
        };
        _BlockNode_prototype.withLabel = function (label, o) {
          var _ref, _this;
          _this = this;
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          if (this.label == null) {
            if (this.nodes.length === 1) {
              return this.nodes[0].withLabel(label, o);
            } else if (__num(this.nodes.length) > 1 && (_ref = this.nodes)[__num(_ref.length) - 1] instanceof ForInNode && (function () {
              var _arr, _end, _i, _len, node;
              for (_arr = __toArray(_this.nodes), _i = 0, _len = _arr.length, _end = -1, _end += _len, _end > _len && (_end = _len); _i < _end; ++_i) {
                node = _arr[_i];
                if (!(node instanceof AssignNode) && !(node instanceof VarNode)) {
                  return false;
                }
              }
              return true;
            }())) {
              return BlockNode(this.startIndex, this.endIndex, this.scopeId, __slice.call(this.nodes, 0, -1).concat([(_ref = this.nodes)[__num(_ref.length) - 1].withLabel(label, o)]));
            }
          }
          return BlockNode(
            this.startIndex,
            this.endIndex,
            this.scopeId,
            this.nodes,
            label
          );
        };
        _BlockNode_prototype._reduce = function (o) {
          var _arr, body, changed, i, label, len, node, reduced;
          changed = false;
          body = [];
          for (_arr = __toArray(this.nodes), i = 0, len = _arr.length; i < len; ++i) {
            node = _arr[i];
            reduced = node.reduce(o);
            if (reduced instanceof BlockNode && reduced.label == null) {
              body.push.apply(body, __toArray(reduced.nodes));
              changed = true;
            } else if (reduced instanceof NothingNode) {
              changed = true;
            } else if (reduced instanceof BreakNode || reduced instanceof ContinueNode || reduced instanceof ThrowNode || reduced instanceof ReturnNode) {
              body.push(reduced);
              if (reduced !== node || i < len - 1) {
                changed = true;
              }
              break;
            } else {
              body.push(reduced);
              if (reduced !== node) {
                changed = true;
              }
            }
          }
          if (this.label != null) {
            label = this.label.reduce(o);
          } else {
            label = this.label;
          }
          if (body.length === 0) {
            return NothingNode(this.startIndex, this.endIndex, this.scopeId);
          } else if (label == null && body.length === 1) {
            return body[0];
          } else if (changed || label !== this.label) {
            return BlockNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              body,
              label
            );
          } else {
            return this;
          }
        };
        _BlockNode_prototype.isStatement = function () {
          var _this;
          _this = this;
          return (function () {
            var _arr, _i, node;
            for (_arr = __toArray(_this.nodes), _i = _arr.length; _i--; ) {
              node = _arr[_i];
              if (node.isStatement()) {
                return true;
              }
            }
            return false;
          }());
        };
        _BlockNode_prototype._isNoop = function (o) {
          var _ref, _this;
          _this = this;
          if ((_ref = this.__isNoop) == null) {
            return this.__isNoop = (function () {
              var _arr, _i, node;
              for (_arr = __toArray(_this.nodes), _i = _arr.length; _i--; ) {
                node = _arr[_i];
                if (!node.isNoop(o)) {
                  return false;
                }
              }
              return true;
            }());
          } else {
            return _ref;
          }
        };
        _BlockNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "BlockNode", this.nodes, this.label);
        };
        _BlockNode_prototype.walk = function (f) {
          var label, nodes;
          nodes = map(this.nodes, f);
          if (this.label instanceof Node) {
            label = f(this.label);
          } else {
            label = this.label;
          }
          if (nodes !== this.nodes || label !== this.label) {
            return BlockNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              nodes,
              label
            );
          } else {
            return this;
          }
        };
        _BlockNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return mapAsync(this.nodes, f, function (_e, nodes) {
            if (_e != null) {
              return callback(_e);
            }
            function next(label) {
              return callback(null, nodes !== _this.nodes || label !== _this.label
                ? BlockNode(
                  _this.startIndex,
                  _this.endIndex,
                  _this.scopeId,
                  nodes,
                  label
                )
                : _this);
            }
            if (_this.label instanceof Node) {
              return f(_this.label, function (_e2, label) {
                if (_e2 != null) {
                  return callback(_e2);
                }
                return next(label);
              });
            } else {
              return next(_this.label);
            }
          });
        };
        return BlockNode;
      }(Node));
      Node.Break = BreakNode = (function (Node) {
        var _BreakNode_prototype, _Node_prototype;
        function BreakNode(startIndex, endIndex, scopeId, label) {
          var _this;
          _this = this instanceof BreakNode ? this : __create(_BreakNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.label = label;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _BreakNode_prototype = BreakNode.prototype = __create(_Node_prototype);
        _BreakNode_prototype.constructor = BreakNode;
        BreakNode.displayName = "BreakNode";
        BreakNode.cappedName = "Break";
        BreakNode.argNames = ["label"];
        State.addNodeFactory("break", BreakNode);
        _BreakNode_prototype.type = function () {
          return Type["undefined"];
        };
        _BreakNode_prototype.isStatement = function () {
          return true;
        };
        _BreakNode_prototype.withLabel = function (label) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return BreakNode(this.startIndex, this.endIndex, this.scopeId, label);
        };
        _BreakNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "BreakNode", this.label);
        };
        _BreakNode_prototype.walk = function (f) {
          var label;
          if (this.label instanceof Node) {
            label = f(this.label);
          } else {
            label = this.label;
          }
          if (label !== this.label) {
            return BreakNode(this.startIndex, this.endIndex, this.scopeId, label);
          } else {
            return this;
          }
        };
        _BreakNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          function next(label) {
            return callback(null, label !== _this.label ? BreakNode(_this.startIndex, _this.endIndex, _this.scopeId, label) : _this);
          }
          if (this.label instanceof Node) {
            return f(this.label, function (_e, label) {
              if (_e != null) {
                return callback(_e);
              }
              return next(label);
            });
          } else {
            return next(this.label);
          }
        };
        return BreakNode;
      }(Node));
      Node.Call = CallNode = (function (Node) {
        var _CallNode_prototype, _Node_prototype;
        function CallNode(startIndex, endIndex, scopeId, func, args, isNew, isApply) {
          var _i, _len, _this;
          _this = this instanceof CallNode ? this : __create(_CallNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(func instanceof Node)) {
            throw TypeError("Expected func to be a Node, got " + __typeof(func));
          }
          if (!__isArray(args)) {
            throw TypeError("Expected args to be an Array, got " + __typeof(args));
          } else {
            for (_i = 0, _len = args.length; _i < _len; ++_i) {
              if (!(args[_i] instanceof Node)) {
                throw TypeError("Expected args[" + _i + "] to be a Node, got " + __typeof(args[_i]));
              }
            }
          }
          if (isNew == null) {
            isNew = false;
          } else if (typeof isNew !== "boolean") {
            throw TypeError("Expected isNew to be a Boolean, got " + __typeof(isNew));
          }
          if (isApply == null) {
            isApply = false;
          } else if (typeof isApply !== "boolean") {
            throw TypeError("Expected isApply to be a Boolean, got " + __typeof(isApply));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.func = func;
          _this.args = args;
          _this.isNew = isNew;
          _this.isApply = isApply;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _CallNode_prototype = CallNode.prototype = __create(_Node_prototype);
        _CallNode_prototype.constructor = CallNode;
        CallNode.displayName = "CallNode";
        CallNode.cappedName = "Call";
        CallNode.argNames = ["func", "args", "isNew", "isApply"];
        State.addNodeFactory("call", CallNode);
        _CallNode_prototype.type = (function () {
          var PRIMORDIAL_FUNCTIONS, PRIMORDIAL_METHODS, PRIMORDIAL_SUBFUNCTIONS;
          PRIMORDIAL_FUNCTIONS = {
            Object: Type.object,
            String: Type.string,
            Number: Type.number,
            Boolean: Type.boolean,
            Function: Type["function"],
            Array: Type.array,
            Date: Type.string,
            RegExp: Type.regexp,
            Error: Type.error,
            RangeError: Type.error,
            ReferenceError: Type.error,
            SyntaxError: Type.error,
            TypeError: Type.error,
            URIError: Type.error,
            escape: Type.string,
            unescape: Type.string,
            parseInt: Type.number,
            parseFloat: Type.number,
            isNaN: Type.boolean,
            isFinite: Type.boolean,
            decodeURI: Type.string,
            decodeURIComponent: Type.string,
            encodeURI: Type.string,
            encodeURIComponent: Type.string
          };
          PRIMORDIAL_SUBFUNCTIONS = {
            Object: {
              getPrototypeOf: Type.object,
              getOwnPropertyDescriptor: Type.object,
              getOwnPropertyNames: Type.string.array(),
              create: Type.object,
              defineProperty: Type.object,
              defineProperties: Type.object,
              seal: Type.object,
              freeze: Type.object,
              preventExtensions: Type.object,
              isSealed: Type.boolean,
              isFrozen: Type.boolean,
              isExtensible: Type.boolean,
              keys: Type.string.array()
            },
            String: { fromCharCode: Type.string },
            Number: { isFinite: Type.boolean, isNaN: Type.boolean },
            Array: { isArray: Type.boolean },
            Math: {
              abs: Type.number,
              acos: Type.number,
              asin: Type.number,
              atan: Type.number,
              atan2: Type.number,
              ceil: Type.number,
              cos: Type.number,
              exp: Type.number,
              floor: Type.number,
              log: Type.number,
              max: Type.number,
              min: Type.number,
              pow: Type.number,
              random: Type.number,
              round: Type.number,
              sin: Type.number,
              sqrt: Type.number,
              tan: Type.number
            },
            JSON: { stringify: Type.string.union(Type["undefined"]), parse: Type.string.union(Type.number).union(Type.boolean).union(Type["null"]).union(Type.array).union(Type.object) },
            Date: { UTC: Type.number, now: Type.number }
          };
          PRIMORDIAL_METHODS = {
            String: {
              toString: Type.string,
              valueOf: Type.string,
              charAt: Type.string,
              charCodeAt: Type.number,
              concat: Type.string,
              indexOf: Type.number,
              lastIndexOf: Type.number,
              localeCompare: Type.number,
              match: Type.array.union(Type["null"]),
              replace: Type.string,
              search: Type.number,
              slice: Type.string,
              split: Type.string.array(),
              substring: Type.string,
              toLowerCase: Type.string,
              toLocaleLowerCase: Type.string,
              toUpperCase: Type.string,
              toLocaleUpperCase: Type.string,
              trim: Type.string
            },
            Boolean: { toString: Type.string, valueOf: Type.boolean },
            Number: {
              toString: Type.string,
              valueOf: Type.number,
              toLocaleString: Type.string,
              toFixed: Type.string,
              toExponential: Type.string,
              toPrecision: Type.string
            },
            Date: {
              toString: Type.string,
              toDateString: Type.string,
              toTimeString: Type.string,
              toLocaleString: Type.string,
              toLocaleDateString: Type.string,
              toLocaleTimeString: Type.string,
              valueOf: Type.number,
              getTime: Type.number,
              getFullYear: Type.number,
              getUTCFullYear: Type.number,
              getMonth: Type.number,
              getUTCMonth: Type.number,
              getDate: Type.number,
              getUTCDate: Type.number,
              getDay: Type.number,
              getUTCDay: Type.number,
              getHours: Type.number,
              getUTCHours: Type.number,
              getMinutes: Type.number,
              getUTCMinutes: Type.number,
              getSeconds: Type.number,
              getUTCSeconds: Type.number,
              getMilliseconds: Type.number,
              getUTCMilliseconds: Type.number,
              getTimezoneOffset: Type.number,
              setTime: Type.number,
              setMilliseconds: Type.number,
              setUTCMilliseconds: Type.number,
              setSeconds: Type.number,
              setUTCSeconds: Type.number,
              setMinutes: Type.number,
              setUTCMinutes: Type.number,
              setHours: Type.number,
              setUTCHours: Type.number,
              setDate: Type.number,
              setUTCDate: Type.number,
              setMonth: Type.number,
              setUTCMonth: Type.number,
              setFullYear: Type.number,
              setUTCFullYear: Type.number,
              toUTCString: Type.string,
              toISOString: Type.string,
              toJSON: Type.string
            },
            RegExp: { exec: Type.array.union(Type["null"]), test: Type.boolean, toString: Type.string },
            Error: { toString: Type.string }
          };
          return function (o) {
            var _ref, _this;
            _this = this;
            if ((_ref = this._type) == null) {
              return this._type = (function () {
                var _ref, _ref2, _ref3, _ref4, child, func, funcType, helpers, name, parent, parentType;
                func = _this.func;
                funcType = func.type(o);
                if (funcType.isSubsetOf(Type["function"])) {
                  return funcType.returnType;
                } else if (func instanceof IdentNode) {
                  name = func.name;
                  if (__owns.call(PRIMORDIAL_FUNCTIONS, name)) {
                    return PRIMORDIAL_FUNCTIONS[name];
                  } else if (__num(name.length) > 2 && name.charCodeAt(0) === 95 && name.charCodeAt(1) === 95) {
                    helpers = require("./translator").helpers;
                    if (helpers.has(name)) {
                      funcType = helpers.type(name);
                      if (funcType.isSubsetOf(Type["function"])) {
                        return funcType.returnType;
                      }
                    }
                  }
                } else if (func instanceof AccessNode) {
                  parent = func.parent;
                  child = func.child;
                  if (child instanceof ConstNode) {
                    if ((_ref = child.value) === "call" || _ref === "apply") {
                      parentType = parent.type(o);
                      if (parentType.isSubsetOf(Type["function"])) {
                        return parentType.returnType;
                      }
                    } else if (parent instanceof IdentNode && __owns.call(PRIMORDIAL_SUBFUNCTIONS, _ref = parent.name) && __owns.call(_ref2 = PRIMORDIAL_SUBFUNCTIONS[_ref], _ref3 = child.value) && (_ref4 = _ref2[_ref3]) != null) {
                      return _ref4;
                    }
                  }
                }
                return Type.any;
              }());
            } else {
              return _ref;
            }
          };
        }());
        _CallNode_prototype._reduce = (function () {
          var PURE_PRIMORDIAL_FUNCTIONS, PURE_PRIMORDIAL_SUBFUNCTIONS;
          PURE_PRIMORDIAL_FUNCTIONS = {
            escape: true,
            unescape: true,
            parseInt: true,
            parseFloat: true,
            isNaN: true,
            isFinite: true,
            decodeURI: true,
            decodeURIComponent: true,
            encodeURI: true,
            encodeURIComponent: true,
            String: true,
            Boolean: true,
            Number: true,
            RegExp: true
          };
          PURE_PRIMORDIAL_SUBFUNCTIONS = {
            String: { fromCharCode: true },
            Number: { isFinite: true, isNaN: true },
            Math: {
              abs: true,
              acos: true,
              asin: true,
              atan: true,
              atan2: true,
              ceil: true,
              cos: true,
              exp: true,
              floor: true,
              log: true,
              max: true,
              min: true,
              pow: true,
              round: true,
              sin: true,
              sqrt: true,
              tan: true
            },
            JSON: { parse: true, stringify: true }
          };
          return function (o) {
            var _arr, _i, _len, _ref, _ref2, _ref3, allConst, arg, args, child, constArgs, cValue, func, parent, pValue, value;
            func = this.func.reduce(o).doWrap(o);
            args = map(this.args, function (node) {
              return node.reduce(o).doWrap(o);
            });
            if (!this.isNew && !this.isApply) {
              constArgs = [];
              allConst = true;
              for (_arr = __toArray(args), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                arg = _arr[_i];
                if (arg.isConst()) {
                  constArgs.push(arg.constValue());
                } else {
                  allConst = false;
                  break;
                }
              }
              if (allConst) {
                if (func instanceof IdentNode) {
                  if (__owns.call(PURE_PRIMORDIAL_FUNCTIONS, func.name)) {
                    try {
                      value = GLOBAL[func.name].apply(void 0, __toArray(constArgs));
                      return ConstNode(this.startIndex, this.endIndex, this.scopeId, value);
                    } catch (e) {}
                  }
                } else if (func instanceof AccessNode && func.child.isConst()) {
                  parent = func.parent;
                  child = func.child;
                  cValue = child.constValue();
                  if (parent.isConst()) {
                    pValue = parent.constValue();
                    if (typeof pValue[cValue] === "function") {
                      try {
                        value = pValue[cValue].apply(pValue, __toArray(constArgs));
                        return ConstNode(this.startIndex, this.endIndex, this.scopeId, value);
                      } catch (e) {}
                    }
                  } else if (parent instanceof IdentNode && (__owns.call(PURE_PRIMORDIAL_SUBFUNCTIONS, _ref = parent.name) && __owns.call(_ref2 = PURE_PRIMORDIAL_SUBFUNCTIONS[_ref], _ref3 = child.value) ? _ref2[_ref3] : void 0)) {
                    try {
                      value = (_ref = GLOBAL[parent.name])[cValue].apply(_ref, __toArray(constArgs));
                      return ConstNode(this.startIndex, this.endIndex, this.scopeId, value);
                    } catch (e) {}
                  }
                }
              }
            }
            if (func !== this.func || args !== this.args) {
              return CallNode(
                this.startIndex,
                this.endIndex,
                this.scopeId,
                func,
                args,
                this.isNew,
                this.isApply
              );
            } else {
              return this;
            }
          };
        }());
        _CallNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "CallNode",
            this.func,
            this.args,
            this.isNew,
            this.isApply
          );
        };
        _CallNode_prototype.walk = function (f) {
          var args, func;
          func = f(this.func);
          args = map(this.args, f);
          if (func !== this.func || args !== this.args) {
            return CallNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              func,
              args,
              this.isNew,
              this.isApply
            );
          } else {
            return this;
          }
        };
        _CallNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.func, function (_e, func) {
            if (_e != null) {
              return callback(_e);
            }
            return mapAsync(_this.args, f, function (_e2, args) {
              if (_e2 != null) {
                return callback(_e2);
              }
              return callback(null, func !== _this.func || args !== _this.args
                ? CallNode(
                  _this.startIndex,
                  _this.endIndex,
                  _this.scopeId,
                  func,
                  args,
                  _this.isNew,
                  _this.isApply
                )
                : _this);
            });
          });
        };
        return CallNode;
      }(Node));
      Node.Comment = CommentNode = (function (Node) {
        var _CommentNode_prototype, _Node_prototype;
        function CommentNode(startIndex, endIndex, scopeId, text) {
          var _this;
          _this = this instanceof CommentNode ? this : __create(_CommentNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (typeof text !== "string") {
            throw TypeError("Expected text to be a String, got " + __typeof(text));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.text = text;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _CommentNode_prototype = CommentNode.prototype = __create(_Node_prototype);
        _CommentNode_prototype.constructor = CommentNode;
        CommentNode.displayName = "CommentNode";
        CommentNode.cappedName = "Comment";
        CommentNode.argNames = ["text"];
        State.addNodeFactory("comment", CommentNode);
        _CommentNode_prototype.type = function () {
          return Type["undefined"];
        };
        _CommentNode_prototype.cacheable = false;
        _CommentNode_prototype.isCount = function () {
          return true;
        };
        _CommentNode_prototype.constValue = function () {
          return;
        };
        _CommentNode_prototype._isNoop = function () {
          return true;
        };
        _CommentNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "CommentNode", this.text);
        };
        _CommentNode_prototype.walk = function (f) {
          return this;
        };
        _CommentNode_prototype.walkAsync = function (f, callback) {
          return callback(null, this);
        };
        return CommentNode;
      }(Node));
      Node.Const = ConstNode = (function (Node) {
        var _ConstNode_prototype, _Node_prototype;
        function ConstNode(startIndex, endIndex, scopeId, value) {
          var _this;
          _this = this instanceof ConstNode ? this : __create(_ConstNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (value != void 0 && typeof value !== "number" && typeof value !== "string" && typeof value !== "boolean") {
            throw TypeError("Expected value to be a Number or String or Boolean or undefined or null, got " + __typeof(value));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.value = value;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _ConstNode_prototype = ConstNode.prototype = __create(_Node_prototype);
        _ConstNode_prototype.constructor = ConstNode;
        ConstNode.displayName = "ConstNode";
        ConstNode.cappedName = "Const";
        ConstNode.argNames = ["value"];
        State.addNodeFactory("const", ConstNode);
        _ConstNode_prototype.type = function () {
          var value;
          value = this.value;
          switch (typeof value) {
          case "number": return Type.number;
          case "string": return Type.string;
          case "boolean": return Type.boolean;
          case "undefined": return Type["undefined"];
          default:
            if (value === null) {
              return Type["null"];
            } else {
              throw Error("Unknown type for " + String(value));
            }
          }
        };
        _ConstNode_prototype.cacheable = false;
        _ConstNode_prototype.isConst = function () {
          return true;
        };
        _ConstNode_prototype.constValue = function () {
          return this.value;
        };
        _ConstNode_prototype._isNoop = function () {
          return true;
        };
        _ConstNode_prototype.inspect = function (depth) {
          return "ConstNode(" + __strnum(inspect(this.value, null, depth != null ? __num(depth) - 1 : null)) + ")";
        };
        _ConstNode_prototype.walk = function (f) {
          return this;
        };
        _ConstNode_prototype.walkAsync = function (f, callback) {
          return callback(null, this);
        };
        return ConstNode;
      }(Node));
      Node.Continue = ContinueNode = (function (Node) {
        var _ContinueNode_prototype, _Node_prototype;
        function ContinueNode(startIndex, endIndex, scopeId, label) {
          var _this;
          _this = this instanceof ContinueNode ? this : __create(_ContinueNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.label = label;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _ContinueNode_prototype = ContinueNode.prototype = __create(_Node_prototype);
        _ContinueNode_prototype.constructor = ContinueNode;
        ContinueNode.displayName = "ContinueNode";
        ContinueNode.cappedName = "Continue";
        ContinueNode.argNames = ["label"];
        State.addNodeFactory("continue", ContinueNode);
        _ContinueNode_prototype.type = function () {
          return Type["undefined"];
        };
        _ContinueNode_prototype.isStatement = function () {
          return true;
        };
        _ContinueNode_prototype.withLabel = function (label) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return ContinueNode(this.startIndex, this.endIndex, this.scopeId, label);
        };
        _ContinueNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "ContinueNode", this.label);
        };
        _ContinueNode_prototype.walk = function (f) {
          var label;
          if (this.label instanceof Node) {
            label = f(this.label);
          } else {
            label = this.label;
          }
          if (label !== this.label) {
            return ContinueNode(this.startIndex, this.endIndex, this.scopeId, label);
          } else {
            return this;
          }
        };
        _ContinueNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          function next(label) {
            return callback(null, label !== _this.label ? ContinueNode(_this.startIndex, _this.endIndex, _this.scopeId, label) : _this);
          }
          if (this.label instanceof Node) {
            return f(this.label, function (_e, label) {
              if (_e != null) {
                return callback(_e);
              }
              return next(label);
            });
          } else {
            return next(this.label);
          }
        };
        return ContinueNode;
      }(Node));
      Node.Debugger = DebuggerNode = (function (Node) {
        var _DebuggerNode_prototype, _Node_prototype;
        function DebuggerNode(startIndex, endIndex, scopeId) {
          var _this;
          _this = this instanceof DebuggerNode ? this : __create(_DebuggerNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _DebuggerNode_prototype = DebuggerNode.prototype = __create(_Node_prototype);
        _DebuggerNode_prototype.constructor = DebuggerNode;
        DebuggerNode.displayName = "DebuggerNode";
        DebuggerNode.cappedName = "Debugger";
        DebuggerNode.argNames = [];
        State.addNodeFactory("debugger", DebuggerNode);
        _DebuggerNode_prototype.type = function () {
          return Type["undefined"];
        };
        _DebuggerNode_prototype.isStatement = function () {
          return true;
        };
        _DebuggerNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "DebuggerNode");
        };
        return DebuggerNode;
      }(Node));
      Node.Def = DefNode = (function (Node) {
        var _DefNode_prototype, _Node_prototype;
        function DefNode(startIndex, endIndex, scopeId, left, right) {
          var _this;
          _this = this instanceof DefNode ? this : __create(_DefNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(left instanceof Node)) {
            throw TypeError("Expected left to be a Node, got " + __typeof(left));
          }
          if (right == null) {
            right = void 0;
          } else if (!(right instanceof Node)) {
            throw TypeError("Expected right to be a Node or undefined, got " + __typeof(right));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.left = left;
          _this.right = right;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _DefNode_prototype = DefNode.prototype = __create(_Node_prototype);
        _DefNode_prototype.constructor = DefNode;
        DefNode.displayName = "DefNode";
        DefNode.cappedName = "Def";
        DefNode.argNames = ["left", "right"];
        State.addNodeFactory("def", DefNode);
        _DefNode_prototype.type = function (o) {
          if (this.right != null) {
            return this.right.type(o);
          } else {
            return Type.any;
          }
        };
        _DefNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "DefNode", this.left, this.right);
        };
        _DefNode_prototype.walk = function (f) {
          var left, right;
          left = f(this.left);
          if (this.right instanceof Node) {
            right = f(this.right);
          } else {
            right = this.right;
          }
          if (left !== this.left || right !== this.right) {
            return DefNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              left,
              right
            );
          } else {
            return this;
          }
        };
        _DefNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.left, function (_e, left) {
            if (_e != null) {
              return callback(_e);
            }
            function next(right) {
              return callback(null, left !== _this.left || right !== _this.right
                ? DefNode(
                  _this.startIndex,
                  _this.endIndex,
                  _this.scopeId,
                  left,
                  right
                )
                : _this);
            }
            if (_this.right instanceof Node) {
              return f(_this.right, function (_e2, right) {
                if (_e2 != null) {
                  return callback(_e2);
                }
                return next(right);
              });
            } else {
              return next(_this.right);
            }
          });
        };
        return DefNode;
      }(Node));
      Node.Eval = EvalNode = (function (Node) {
        var _EvalNode_prototype, _Node_prototype;
        function EvalNode(startIndex, endIndex, scopeId, code) {
          var _this;
          _this = this instanceof EvalNode ? this : __create(_EvalNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(code instanceof Node)) {
            throw TypeError("Expected code to be a Node, got " + __typeof(code));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.code = code;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _EvalNode_prototype = EvalNode.prototype = __create(_Node_prototype);
        _EvalNode_prototype.constructor = EvalNode;
        EvalNode.displayName = "EvalNode";
        EvalNode.cappedName = "Eval";
        EvalNode.argNames = ["code"];
        State.addNodeFactory("eval", EvalNode);
        _EvalNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "EvalNode", this.code);
        };
        _EvalNode_prototype.walk = function (f) {
          var code;
          code = f(this.code);
          if (code !== this.code) {
            return EvalNode(this.startIndex, this.endIndex, this.scopeId, code);
          } else {
            return this;
          }
        };
        _EvalNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.code, function (_e, code) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, code !== _this.code ? EvalNode(_this.startIndex, _this.endIndex, _this.scopeId, code) : _this);
          });
        };
        return EvalNode;
      }(Node));
      Node.For = ForNode = (function (Node) {
        var _ForNode_prototype, _Node_prototype;
        function ForNode(startIndex, endIndex, scopeId, init, test, step, body, label) {
          var _this;
          _this = this instanceof ForNode ? this : __create(_ForNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (init == null) {
            init = NothingNode(0, 0, scopeId);
          } else if (!(init instanceof Node)) {
            throw TypeError("Expected init to be a Node, got " + __typeof(init));
          }
          if (test == null) {
            test = ConstNode(0, 0, scopeId, true);
          } else if (!(test instanceof Node)) {
            throw TypeError("Expected test to be a Node, got " + __typeof(test));
          }
          if (step == null) {
            step = NothingNode(0, 0, scopeId);
          } else if (!(step instanceof Node)) {
            throw TypeError("Expected step to be a Node, got " + __typeof(step));
          }
          if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.init = init;
          _this.test = test;
          _this.step = step;
          _this.body = body;
          _this.label = label;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _ForNode_prototype = ForNode.prototype = __create(_Node_prototype);
        _ForNode_prototype.constructor = ForNode;
        ForNode.displayName = "ForNode";
        ForNode.cappedName = "For";
        ForNode.argNames = [
          "init",
          "test",
          "step",
          "body",
          "label"
        ];
        State.addNodeFactory("for", ForNode);
        _ForNode_prototype.type = function () {
          return Type["undefined"];
        };
        _ForNode_prototype.isStatement = function () {
          return true;
        };
        _ForNode_prototype.withLabel = function (label) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return ForNode(
            this.startIndex,
            this.endIndex,
            this.scopeId,
            this.init,
            this.test,
            this.step,
            this.body,
            label
          );
        };
        _ForNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "ForNode",
            this.init,
            this.test,
            this.step,
            this.body,
            this.label
          );
        };
        _ForNode_prototype.walk = function (f) {
          var body, init, label, step, test;
          init = f(this.init);
          test = f(this.test);
          step = f(this.step);
          body = f(this.body);
          if (this.label instanceof Node) {
            label = f(this.label);
          } else {
            label = this.label;
          }
          if (init !== this.init || test !== this.test || step !== this.step || body !== this.body || label !== this.label) {
            return ForNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              init,
              test,
              step,
              body,
              label
            );
          } else {
            return this;
          }
        };
        _ForNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.init, function (_e, init) {
            if (_e != null) {
              return callback(_e);
            }
            return f(_this.test, function (_e2, test) {
              if (_e2 != null) {
                return callback(_e2);
              }
              return f(_this.step, function (_e3, step) {
                if (_e3 != null) {
                  return callback(_e3);
                }
                return f(_this.body, function (_e4, body) {
                  if (_e4 != null) {
                    return callback(_e4);
                  }
                  function next(label) {
                    return callback(null, init !== _this.init || test !== _this.test || step !== _this.step || body !== _this.body || label !== _this.label
                      ? ForNode(
                        _this.startIndex,
                        _this.endIndex,
                        _this.scopeId,
                        init,
                        test,
                        step,
                        body,
                        label
                      )
                      : _this);
                  }
                  if (_this.label instanceof Node) {
                    return f(_this.label, function (_e5, label) {
                      if (_e5 != null) {
                        return callback(_e5);
                      }
                      return next(label);
                    });
                  } else {
                    return next(_this.label);
                  }
                });
              });
            });
          });
        };
        return ForNode;
      }(Node));
      Node.ForIn = ForInNode = (function (Node) {
        var _ForInNode_prototype, _Node_prototype;
        function ForInNode(startIndex, endIndex, scopeId, key, object, body, label) {
          var _this;
          _this = this instanceof ForInNode ? this : __create(_ForInNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(key instanceof Node)) {
            throw TypeError("Expected key to be a Node, got " + __typeof(key));
          }
          if (!(object instanceof Node)) {
            throw TypeError("Expected object to be a Node, got " + __typeof(object));
          }
          if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.key = key;
          _this.object = object;
          _this.body = body;
          _this.label = label;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _ForInNode_prototype = ForInNode.prototype = __create(_Node_prototype);
        _ForInNode_prototype.constructor = ForInNode;
        ForInNode.displayName = "ForInNode";
        ForInNode.cappedName = "ForIn";
        ForInNode.argNames = ["key", "object", "body", "label"];
        State.addNodeFactory("forIn", ForInNode);
        _ForInNode_prototype.type = function () {
          return Type["undefined"];
        };
        _ForInNode_prototype.isStatement = function () {
          return true;
        };
        _ForInNode_prototype.withLabel = function (label) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return ForInNode(
            this.startIndex,
            this.endIndex,
            this.scopeId,
            this.key,
            this.object,
            this.body,
            label
          );
        };
        _ForInNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "ForInNode",
            this.key,
            this.object,
            this.body,
            this.label
          );
        };
        _ForInNode_prototype.walk = function (f) {
          var body, key, label, object;
          key = f(this.key);
          object = f(this.object);
          body = f(this.body);
          if (this.label instanceof Node) {
            label = f(this.label);
          } else {
            label = this.label;
          }
          if (key !== this.key || object !== this.object || body !== this.body || label !== this.label) {
            return ForInNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              key,
              object,
              body,
              label
            );
          } else {
            return this;
          }
        };
        _ForInNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.key, function (_e, key) {
            if (_e != null) {
              return callback(_e);
            }
            return f(_this.object, function (_e2, object) {
              if (_e2 != null) {
                return callback(_e2);
              }
              return f(_this.body, function (_e3, body) {
                if (_e3 != null) {
                  return callback(_e3);
                }
                function next(label) {
                  return callback(null, key !== _this.key || object !== _this.object || body !== _this.body || label !== _this.label
                    ? ForInNode(
                      _this.startIndex,
                      _this.endIndex,
                      _this.scopeId,
                      key,
                      object,
                      body,
                      label
                    )
                    : _this);
                }
                if (_this.label instanceof Node) {
                  return f(_this.label, function (_e4, label) {
                    if (_e4 != null) {
                      return callback(_e4);
                    }
                    return next(label);
                  });
                } else {
                  return next(_this.label);
                }
              });
            });
          });
        };
        return ForInNode;
      }(Node));
      Node.Function = FunctionNode = (function (Node) {
        var _FunctionNode_prototype, _Node_prototype;
        function FunctionNode(startIndex, endIndex, scopeId, params, body, autoReturn, bound, asType, generator) {
          var _i, _len, _this;
          _this = this instanceof FunctionNode ? this : __create(_FunctionNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!__isArray(params)) {
            throw TypeError("Expected params to be an Array, got " + __typeof(params));
          } else {
            for (_i = 0, _len = params.length; _i < _len; ++_i) {
              if (!(params[_i] instanceof Node)) {
                throw TypeError("Expected params[" + _i + "] to be a Node, got " + __typeof(params[_i]));
              }
            }
          }
          if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          if (autoReturn == null) {
            autoReturn = true;
          } else if (typeof autoReturn !== "boolean") {
            throw TypeError("Expected autoReturn to be a Boolean, got " + __typeof(autoReturn));
          }
          if (bound == null) {
            bound = false;
          } else if (!(bound instanceof Node) && typeof bound !== "boolean") {
            throw TypeError("Expected bound to be a Node or Boolean, got " + __typeof(bound));
          }
          if (asType == null) {
            asType = void 0;
          } else if (!(asType instanceof Node)) {
            throw TypeError("Expected asType to be a Node or undefined, got " + __typeof(asType));
          }
          if (generator == null) {
            generator = false;
          } else if (typeof generator !== "boolean") {
            throw TypeError("Expected generator to be a Boolean, got " + __typeof(generator));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.params = params;
          _this.body = body;
          _this.autoReturn = autoReturn;
          _this.bound = bound;
          _this.asType = asType;
          _this.generator = generator;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _FunctionNode_prototype = FunctionNode.prototype = __create(_Node_prototype);
        _FunctionNode_prototype.constructor = FunctionNode;
        FunctionNode.displayName = "FunctionNode";
        FunctionNode.cappedName = "Function";
        FunctionNode.argNames = [
          "params",
          "body",
          "autoReturn",
          "bound",
          "asType",
          "generator"
        ];
        State.addNodeFactory("function", FunctionNode);
        _FunctionNode_prototype.type = function (o) {
          var _ref, _this;
          _this = this;
          if ((_ref = this._type) == null) {
            return this._type = (function () {
              var returnType, walker;
              if (_this.asType != null) {
                return nodeToType(_this.asType)["function"]();
              } else {
                if (_this.autoReturn) {
                  returnType = _this.body.type(o);
                } else {
                  returnType = Type["undefined"];
                }
                walker = function (node) {
                  var _ref;
                  if (node instanceof ReturnNode) {
                    returnType = returnType.union(node.type(o));
                    return node;
                  } else if (node instanceof FunctionNode) {
                    return node;
                  } else if (node instanceof MacroAccessNode) {
                    if ((_ref = node.data.macroName) === "return" || _ref === "return?") {
                      if (node.data.macroData.node) {
                        returnType = returnType.union(node.data.macroData.node.type(o));
                      } else {
                        returnType = returnType.union(Type["undefined"]);
                      }
                    }
                    return node.walk(walker);
                  } else {
                    return node.walk(walker);
                  }
                };
                walker(_this.body);
                return returnType["function"]();
              }
            }());
          } else {
            return _ref;
          }
        };
        _FunctionNode_prototype._isNoop = function (o) {
          return true;
        };
        _FunctionNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "FunctionNode",
            this.params,
            this.body,
            this.autoReturn,
            this.bound,
            this.asType,
            this.generator
          );
        };
        _FunctionNode_prototype.walk = function (f) {
          var asType, body, bound, params;
          params = map(this.params, f);
          body = f(this.body);
          if (this.bound instanceof Node) {
            bound = f(this.bound);
          } else {
            bound = this.bound;
          }
          if (this.asType instanceof Node) {
            asType = f(this.asType);
          } else {
            asType = this.asType;
          }
          if (params !== this.params || body !== this.body || bound !== this.bound || asType !== this.asType) {
            return FunctionNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              params,
              body,
              this.autoReturn,
              bound,
              asType,
              this.generator
            );
          } else {
            return this;
          }
        };
        _FunctionNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return mapAsync(this.params, f, function (_e, params) {
            if (_e != null) {
              return callback(_e);
            }
            return f(_this.body, function (_e2, body) {
              if (_e2 != null) {
                return callback(_e2);
              }
              function next(bound) {
                function next(asType) {
                  return callback(null, params !== _this.params || body !== _this.body || bound !== _this.bound || asType !== _this.asType
                    ? FunctionNode(
                      _this.startIndex,
                      _this.endIndex,
                      _this.scopeId,
                      params,
                      body,
                      _this.autoReturn,
                      bound,
                      asType,
                      _this.generator
                    )
                    : _this);
                }
                if (_this.asType instanceof Node) {
                  return f(_this.asType, function (_e3, asType) {
                    if (_e3 != null) {
                      return callback(_e3);
                    }
                    return next(asType);
                  });
                } else {
                  return next(_this.asType);
                }
              }
              if (_this.bound instanceof Node) {
                return f(_this.bound, function (_e3, bound) {
                  if (_e3 != null) {
                    return callback(_e3);
                  }
                  return next(bound);
                });
              } else {
                return next(_this.bound);
              }
            });
          });
        };
        return FunctionNode;
      }(Node));
      Node.Ident = IdentNode = (function (Node) {
        var _IdentNode_prototype, _Node_prototype;
        function IdentNode(startIndex, endIndex, scopeId, name) {
          var _this;
          _this = this instanceof IdentNode ? this : __create(_IdentNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.name = name;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _IdentNode_prototype = IdentNode.prototype = __create(_Node_prototype);
        _IdentNode_prototype.constructor = IdentNode;
        IdentNode.displayName = "IdentNode";
        IdentNode.cappedName = "Ident";
        IdentNode.argNames = ["name"];
        State.addNodeFactory("ident", IdentNode);
        _IdentNode_prototype.cacheable = false;
        _IdentNode_prototype.type = function (o) {
          if (this.name === CURRENT_ARRAY_LENGTH_NAME) {
            return Type.number;
          } else if (o) {
            return o.scope.type(this);
          } else {
            return Type.any;
          }
        };
        _IdentNode_prototype._isNoop = function (o) {
          return true;
        };
        _IdentNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "IdentNode", this.name);
        };
        _IdentNode_prototype.walk = function (f) {
          return this;
        };
        _IdentNode_prototype.walkAsync = function (f, callback) {
          return callback(null, this);
        };
        return IdentNode;
      }(Node));
      Node.If = IfNode = (function (Node) {
        var _IfNode_prototype, _Node_prototype;
        function IfNode(startIndex, endIndex, scopeId, test, whenTrue, whenFalse, label) {
          var _this;
          _this = this instanceof IfNode ? this : __create(_IfNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(test instanceof Node)) {
            throw TypeError("Expected test to be a Node, got " + __typeof(test));
          }
          if (!(whenTrue instanceof Node)) {
            throw TypeError("Expected whenTrue to be a Node, got " + __typeof(whenTrue));
          }
          if (whenFalse == null) {
            whenFalse = NothingNode(0, 0, scopeId);
          } else if (!(whenFalse instanceof Node)) {
            throw TypeError("Expected whenFalse to be a Node, got " + __typeof(whenFalse));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.test = test;
          _this.whenTrue = whenTrue;
          _this.whenFalse = whenFalse;
          _this.label = label;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _IfNode_prototype = IfNode.prototype = __create(_Node_prototype);
        _IfNode_prototype.constructor = IfNode;
        IfNode.displayName = "IfNode";
        IfNode.cappedName = "If";
        IfNode.argNames = ["test", "whenTrue", "whenFalse", "label"];
        State.addNodeFactory("if", IfNode);
        _IfNode_prototype.type = function (o) {
          var _ref;
          if ((_ref = this._type) == null) {
            return this._type = this.whenTrue.type(o).union(this.whenFalse.type(o));
          } else {
            return _ref;
          }
        };
        _IfNode_prototype.withLabel = function (label) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return IfNode(
            this.startIndex,
            this.endIndex,
            this.scopeId,
            this.test,
            this.whenTrue,
            this.whenFalse,
            label
          );
        };
        _IfNode_prototype._reduce = function (o) {
          var label, test, testType, whenFalse, whenTrue;
          test = this.test.reduce(o);
          whenTrue = this.whenTrue.reduce(o);
          whenFalse = this.whenFalse.reduce(o);
          if (this.label != null) {
            label = this.label.reduce(o);
          } else {
            label = this.label;
          }
          if (test.isConst()) {
            return BlockNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              [test.constValue() ? whenTrue : whenFalse],
              label
            ).reduce(o);
          } else {
            testType = test.type(o);
            if (testType.isSubsetOf(Type.alwaysTruthy)) {
              return BlockNode(
                this.startIndex,
                this.endIndex,
                this.scopeId,
                [test, whenTrue],
                label
              ).reduce(o);
            } else if (testType.isSubsetOf(Type.alwaysFalsy)) {
              return BlockNode(
                this.startIndex,
                this.endIndex,
                this.scopeId,
                [test, whenFalse],
                label
              ).reduce(o);
            } else if (test !== this.test || whenTrue !== this.whenTrue || whenFalse !== this.whenFalse || label !== this.label) {
              return IfNode(
                this.startIndex,
                this.endIndex,
                this.scopeId,
                test,
                whenTrue,
                whenFalse,
                label
              );
            } else {
              return this;
            }
          }
        };
        _IfNode_prototype.isStatement = function () {
          var _ref;
          if ((_ref = this._isStatement) == null) {
            return this._isStatement = this.whenTrue.isStatement() || this.whenFalse.isStatement();
          } else {
            return _ref;
          }
        };
        _IfNode_prototype.doWrap = function (o) {
          var whenFalse, whenTrue;
          whenTrue = this.whenTrue.doWrap(o);
          whenFalse = this.whenFalse.doWrap(o);
          if (whenTrue !== this.whenTrue || whenFalse !== this.whenFalse) {
            return IfNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              this.test,
              whenTrue,
              whenFalse,
              this.label
            );
          } else {
            return this;
          }
        };
        _IfNode_prototype._isNoop = function (o) {
          var _ref;
          if ((_ref = this.__isNoop) == null) {
            return this.__isNoop = this.test.isNoop(o) && this.whenTrue.isNoop(o) && this.whenFalse.isNoop(o);
          } else {
            return _ref;
          }
        };
        _IfNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "IfNode",
            this.test,
            this.whenTrue,
            this.whenFalse,
            this.label
          );
        };
        _IfNode_prototype.walk = function (f) {
          var label, test, whenFalse, whenTrue;
          test = f(this.test);
          whenTrue = f(this.whenTrue);
          whenFalse = f(this.whenFalse);
          if (this.label instanceof Node) {
            label = f(this.label);
          } else {
            label = this.label;
          }
          if (test !== this.test || whenTrue !== this.whenTrue || whenFalse !== this.whenFalse || label !== this.label) {
            return IfNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              test,
              whenTrue,
              whenFalse,
              label
            );
          } else {
            return this;
          }
        };
        _IfNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.test, function (_e, test) {
            if (_e != null) {
              return callback(_e);
            }
            return f(_this.whenTrue, function (_e2, whenTrue) {
              if (_e2 != null) {
                return callback(_e2);
              }
              return f(_this.whenFalse, function (_e3, whenFalse) {
                if (_e3 != null) {
                  return callback(_e3);
                }
                function next(label) {
                  return callback(null, test !== _this.test || whenTrue !== _this.whenTrue || whenFalse !== _this.whenFalse || label !== _this.label
                    ? IfNode(
                      _this.startIndex,
                      _this.endIndex,
                      _this.scopeId,
                      test,
                      whenTrue,
                      whenFalse,
                      label
                    )
                    : _this);
                }
                if (_this.label instanceof Node) {
                  return f(_this.label, function (_e4, label) {
                    if (_e4 != null) {
                      return callback(_e4);
                    }
                    return next(label);
                  });
                } else {
                  return next(_this.label);
                }
              });
            });
          });
        };
        return IfNode;
      }(Node));
      Node.MacroAccess = MacroAccessNode = (function (Node) {
        var _MacroAccessNode_prototype, _Node_prototype;
        function MacroAccessNode(startIndex, endIndex, scopeId, id, line, data, position, inGenerator) {
          var _this;
          _this = this instanceof MacroAccessNode ? this : __create(_MacroAccessNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (typeof id !== "number") {
            throw TypeError("Expected id to be a Number, got " + __typeof(id));
          }
          if (typeof line !== "number") {
            throw TypeError("Expected line to be a Number, got " + __typeof(line));
          }
          if (!__isObject(data)) {
            throw TypeError("Expected data to be an Object, got " + __typeof(data));
          }
          if (typeof position !== "string") {
            throw TypeError("Expected position to be a String, got " + __typeof(position));
          }
          if (inGenerator == null) {
            inGenerator = false;
          } else if (typeof inGenerator !== "boolean") {
            throw TypeError("Expected inGenerator to be a Boolean, got " + __typeof(inGenerator));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.id = id;
          _this.line = line;
          _this.data = data;
          _this.position = position;
          _this.inGenerator = inGenerator;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _MacroAccessNode_prototype = MacroAccessNode.prototype = __create(_Node_prototype);
        _MacroAccessNode_prototype.constructor = MacroAccessNode;
        MacroAccessNode.displayName = "MacroAccessNode";
        MacroAccessNode.cappedName = "MacroAccess";
        MacroAccessNode.argNames = [
          "id",
          "line",
          "data",
          "position",
          "inGenerator"
        ];
        State.addNodeFactory("macroAccess", MacroAccessNode);
        _MacroAccessNode_prototype.type = function (o) {
          var _ref, _this;
          _this = this;
          if (!(o instanceof State)) {
            throw TypeError("Expected o to be a State, got " + __typeof(o));
          }
          if ((_ref = this._type) == null) {
            return this._type = (function () {
              var type;
              type = o.macros.getTypeById(_this.id);
              if (type != null) {
                return type;
              } else {
                return o.macroExpand1(_this).type(o);
              }
            }());
          } else {
            return _ref;
          }
        };
        _MacroAccessNode_prototype.withLabel = function (label, o) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return o.macroExpand1(this).withLabel(label, o);
        };
        _MacroAccessNode_prototype.walk = (function () {
          function walkObject(obj, func) {
            var changed, k, newV, result, v;
            result = {};
            changed = false;
            for (k in obj) {
              if (__owns.call(obj, k)) {
                v = obj[k];
                newV = walkItem(v, func);
                if (newV !== v) {
                  changed = true;
                }
                result[k] = newV;
              }
            }
            if (changed) {
              return result;
            } else {
              return obj;
            }
          }
          function walkItem(item, func) {
            if (item instanceof Node) {
              return func(item);
            } else if (__isArray(item)) {
              return map(item, function (x) {
                return walkItem(x, func);
              });
            } else if (item && typeof item === "object") {
              return walkObject(item, func);
            } else {
              return item;
            }
          }
          return function (func) {
            var data;
            data = walkItem(this.data, func);
            if (data !== this.data) {
              return MacroAccessNode(
                this.startIndex,
                this.endIndex,
                this.scopeId,
                this.id,
                this.line,
                data,
                this.position,
                this.inGenerator
              );
            } else {
              return this;
            }
          };
        }());
        _MacroAccessNode_prototype.walkAsync = (function () {
          function walkObject(obj, func, callback) {
            var _keys, changed, k, result;
            changed = false;
            result = {};
            _keys = [];
            for (k in obj) {
              if (__owns.call(obj, k)) {
                _keys.push(k);
              }
            }
            return __async(
              1,
              _keys.length,
              function (_i, next) {
                var k, v;
                k = _keys[_i];
                v = obj[k];
                return walkItem(item, func, function (_e, newItem) {
                  if (_e != null) {
                    return next(_e);
                  }
                  if (item !== newItem) {
                    changed = true;
                  }
                  result[k] = newItem;
                  return next(null);
                });
              },
              function (err) {
                if (typeof err !== "undefined" && err !== null) {
                  return callback(err);
                } else {
                  return callback(null, changed ? result : obj);
                }
              }
            );
          }
          function walkItem(item, func, callback) {
            if (item instanceof Node) {
              return func(item, callback);
            } else if (__isArray(item)) {
              return mapAsync(
                item,
                function (x, cb) {
                  return walkItem(x, func, cb);
                },
                callback
              );
            } else if (item && typeof item === "object") {
              return walkObject(item, func, callback);
            } else {
              return callback(null, item);
            }
          }
          return function (func, callback) {
            var _this;
            _this = this;
            return walkItem(this.data, func, function (_e, data) {
              if (_e != null) {
                return callback(_e);
              }
              return callback(null, data !== _this.data
                ? MacroAccessNode(
                  _this.startIndex,
                  _this.endIndex,
                  _this.scopeId,
                  _this.id,
                  _this.line,
                  data,
                  _this.position,
                  _this.inGenerator
                )
                : _this);
            });
          };
        }());
        _MacroAccessNode_prototype._isNoop = function (o) {
          return o.macroExpand1(this).isNoop(o);
        };
        _MacroAccessNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "MacroAccessNode",
            this.id,
            this.line,
            this.data,
            this.position,
            this.inGenerator
          );
        };
        return MacroAccessNode;
      }(Node));
      Node.Nothing = NothingNode = (function (Node) {
        var _Node_prototype, _NothingNode_prototype;
        function NothingNode(startIndex, endIndex, scopeId) {
          var _this;
          _this = this instanceof NothingNode ? this : __create(_NothingNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _NothingNode_prototype = NothingNode.prototype = __create(_Node_prototype);
        _NothingNode_prototype.constructor = NothingNode;
        NothingNode.displayName = "NothingNode";
        NothingNode.cappedName = "Nothing";
        NothingNode.argNames = [];
        State.addNodeFactory("nothing", NothingNode);
        _NothingNode_prototype.type = function () {
          return Type["undefined"];
        };
        _NothingNode_prototype.cacheable = false;
        _NothingNode_prototype.isConst = function () {
          return true;
        };
        _NothingNode_prototype.constValue = function () {
          return;
        };
        _NothingNode_prototype._isNoop = function () {
          return true;
        };
        _NothingNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "NothingNode");
        };
        return NothingNode;
      }(Node));
      Node.Object = ObjectNode = (function (Node) {
        var _Node_prototype, _ObjectNode_prototype;
        function ObjectNode(startIndex, endIndex, scopeId, pairs, prototype) {
          var _i, _len, _this;
          _this = this instanceof ObjectNode ? this : __create(_ObjectNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!__isArray(pairs)) {
            throw TypeError("Expected pairs to be an Array, got " + __typeof(pairs));
          } else {
            for (_i = 0, _len = pairs.length; _i < _len; ++_i) {
              if (!__isObject(pairs[_i])) {
                throw TypeError("Expected pairs[" + _i + "] to be an Object, got " + __typeof(pairs[_i]));
              } else {
                if (!(pairs[_i].key instanceof Node)) {
                  throw TypeError("Expected pairs[" + _i + "].key to be a Node, got " + __typeof(pairs[_i].key));
                }
                if (!(pairs[_i].value instanceof Node)) {
                  throw TypeError("Expected pairs[" + _i + "].value to be a Node, got " + __typeof(pairs[_i].value));
                }
                if (pairs[_i].property == null) {
                  pairs[_i].property = void 0;
                } else if (typeof pairs[_i].property !== "string") {
                  throw TypeError("Expected pairs[" + _i + "].property to be a String or undefined, got " + __typeof(pairs[_i].property));
                }
              }
            }
          }
          if (prototype == null) {
            prototype = void 0;
          } else if (!(prototype instanceof Node)) {
            throw TypeError("Expected prototype to be a Node or undefined, got " + __typeof(prototype));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.pairs = pairs;
          _this.prototype = prototype;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _ObjectNode_prototype = ObjectNode.prototype = __create(_Node_prototype);
        _ObjectNode_prototype.constructor = ObjectNode;
        ObjectNode.displayName = "ObjectNode";
        ObjectNode.cappedName = "Object";
        ObjectNode.argNames = ["pairs", "prototype"];
        State.addNodeFactory("object", ObjectNode);
        _ObjectNode_prototype.type = function (o) {
          var _ref, _this;
          _this = this;
          if ((_ref = this._type) == null) {
            return this._type = (function () {
              var _arr, _i, _len, _ref, data, key, value;
              data = {};
              for (_arr = __toArray(_this.pairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                key = (_ref = _arr[_i]).key;
                value = _ref.value;
                if (key.isConst()) {
                  data[key.constValue()] = value.type(o);
                }
              }
              return Type.makeObject(data);
            }());
          } else {
            return _ref;
          }
        };
        _ObjectNode_prototype.walk = (function () {
          function walkPair(pair, func) {
            var key, value;
            key = func(pair.key);
            value = func(pair.value);
            if (key !== pair.key || value !== pair.value) {
              return { key: key, value: value, property: pair.property };
            } else {
              return pair;
            }
          }
          return function (func) {
            var pairs, prototype;
            pairs = map(this.pairs, walkPair, func);
            if (this.prototype != null) {
              prototype = func(this.prototype);
            } else {
              prototype = this.prototype;
            }
            if (pairs !== this.pairs || prototype !== this.prototype) {
              return ObjectNode(
                this.startIndex,
                this.endIndex,
                this.scopeId,
                pairs,
                prototype
              );
            } else {
              return this;
            }
          };
        }());
        _ObjectNode_prototype.walkAsync = (function () {
          function walkPair(pair, func, callback) {
            return func(pair.key, function (_e, key) {
              if (_e != null) {
                return callback(_e);
              }
              return func(pair.value, function (_e2, value) {
                if (_e2 != null) {
                  return callback(_e2);
                }
                return callback(null, key !== pair.key || value !== pair.value ? { key: key, value: value, property: pair.property } : pair);
              });
            });
          }
          return function (func, callback) {
            var _this;
            _this = this;
            return mapAsync(this.pairs, walkPair, func, function (_e, pairs) {
              if (_e != null) {
                return callback(_e);
              }
              function next(prototype) {
                return callback(null, pairs !== _this.pairs || prototype !== _this.prototype
                  ? ObjectNode(
                    _this.startIndex,
                    _this.endIndex,
                    _this.scopeId,
                    pairs,
                    prototype
                  )
                  : _this);
              }
              if (_this.prototype != null) {
                return func(_this.prototype, function (_e2, p) {
                  if (_e2 != null) {
                    return callback(_e2);
                  }
                  return next(p);
                });
              } else {
                return next(_this.prototype);
              }
            });
          };
        }());
        _ObjectNode_prototype._reduce = (function () {
          function reducePair(pair, o) {
            var key, value;
            key = pair.key.reduce(o);
            value = pair.value.reduce(o).doWrap(o);
            if (key !== pair.key || value !== pair.value) {
              return { key: key, value: value, property: pair.property };
            } else {
              return pair;
            }
          }
          return function (o) {
            var pairs, prototype;
            pairs = map(this.pairs, reducePair, o);
            if (this.prototype != null) {
              prototype = this.prototype.reduce(o);
            } else {
              prototype = this.prototype;
            }
            if (pairs !== this.pairs || prototype !== this.prototype) {
              return ObjectNode(
                this.startIndex,
                this.endIndex,
                this.scopeId,
                pairs,
                prototype
              );
            } else {
              return this;
            }
          };
        }());
        _ObjectNode_prototype._isNoop = function (o) {
          var _ref, _this;
          _this = this;
          if ((_ref = this.__isNoop) == null) {
            return this.__isNoop = (function () {
              var _arr, _i, _len, _ref, key, value;
              for (_arr = __toArray(_this.pairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                key = (_ref = _arr[_i]).key;
                value = _ref.value;
                if (!key.isNoop(o) || !value.isNoop(o)) {
                  return false;
                }
              }
              return true;
            }());
          } else {
            return _ref;
          }
        };
        _ObjectNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "ObjectNode", this.pairs, this.prototype);
        };
        return ObjectNode;
      }(Node));
      State.prototype.object = function (i, pairs, prototype) {
        var _arr, _i, _len, _ref, key, keyValue, knownKeys, lastPropertyPair, property;
        knownKeys = [];
        lastPropertyPair = null;
        for (_arr = __toArray(pairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
          key = (_ref = _arr[_i]).key;
          property = _ref.property;
          if (key instanceof ConstNode) {
            keyValue = String(key.value);
            if ((property === "get" || property === "set") && lastPropertyPair && lastPropertyPair.property !== property && lastPropertyPair.key === keyValue) {
              lastPropertyPair = null;
              continue;
            } else if (__in(keyValue, knownKeys)) {
              this.error("Duplicate key in object: " + keyValue);
            }
            knownKeys.push(keyValue);
            if (property === "get" || property === "set") {
              lastPropertyPair = { key: keyValue, property: property };
            } else {
              lastPropertyPair = null;
            }
          } else {
            lastPropertyPair = null;
          }
        }
        return ObjectNode(
          i,
          this.index,
          this.scope.id,
          pairs,
          prototype
        );
      };
      State.prototype.objectParam = State.prototype.object;
      Node.Param = ParamNode = (function (Node) {
        var _Node_prototype, _ParamNode_prototype;
        function ParamNode(startIndex, endIndex, scopeId, ident, defaultValue, spread, isMutable, asType) {
          var _this;
          _this = this instanceof ParamNode ? this : __create(_ParamNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(ident instanceof Node)) {
            throw TypeError("Expected ident to be a Node, got " + __typeof(ident));
          }
          if (defaultValue == null) {
            defaultValue = void 0;
          } else if (!(defaultValue instanceof Node)) {
            throw TypeError("Expected defaultValue to be a Node or undefined, got " + __typeof(defaultValue));
          }
          if (spread == null) {
            spread = false;
          } else if (typeof spread !== "boolean") {
            throw TypeError("Expected spread to be a Boolean, got " + __typeof(spread));
          }
          if (isMutable == null) {
            isMutable = false;
          } else if (typeof isMutable !== "boolean") {
            throw TypeError("Expected isMutable to be a Boolean, got " + __typeof(isMutable));
          }
          if (asType == null) {
            asType = void 0;
          } else if (!(asType instanceof Node)) {
            throw TypeError("Expected asType to be a Node or undefined, got " + __typeof(asType));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.ident = ident;
          _this.defaultValue = defaultValue;
          _this.spread = spread;
          _this.isMutable = isMutable;
          _this.asType = asType;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _ParamNode_prototype = ParamNode.prototype = __create(_Node_prototype);
        _ParamNode_prototype.constructor = ParamNode;
        ParamNode.displayName = "ParamNode";
        ParamNode.cappedName = "Param";
        ParamNode.argNames = [
          "ident",
          "defaultValue",
          "spread",
          "isMutable",
          "asType"
        ];
        State.addNodeFactory("param", ParamNode);
        _ParamNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "ParamNode",
            this.ident,
            this.defaultValue,
            this.spread,
            this.isMutable,
            this.asType
          );
        };
        _ParamNode_prototype.walk = function (f) {
          var asType, defaultValue, ident;
          ident = f(this.ident);
          if (this.defaultValue instanceof Node) {
            defaultValue = f(this.defaultValue);
          } else {
            defaultValue = this.defaultValue;
          }
          if (this.asType instanceof Node) {
            asType = f(this.asType);
          } else {
            asType = this.asType;
          }
          if (ident !== this.ident || defaultValue !== this.defaultValue || asType !== this.asType) {
            return ParamNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              ident,
              defaultValue,
              this.spread,
              this.isMutable,
              asType
            );
          } else {
            return this;
          }
        };
        _ParamNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.ident, function (_e, ident) {
            if (_e != null) {
              return callback(_e);
            }
            function next(defaultValue) {
              function next(asType) {
                return callback(null, ident !== _this.ident || defaultValue !== _this.defaultValue || asType !== _this.asType
                  ? ParamNode(
                    _this.startIndex,
                    _this.endIndex,
                    _this.scopeId,
                    ident,
                    defaultValue,
                    _this.spread,
                    _this.isMutable,
                    asType
                  )
                  : _this);
              }
              if (_this.asType instanceof Node) {
                return f(_this.asType, function (_e2, asType) {
                  if (_e2 != null) {
                    return callback(_e2);
                  }
                  return next(asType);
                });
              } else {
                return next(_this.asType);
              }
            }
            if (_this.defaultValue instanceof Node) {
              return f(_this.defaultValue, function (_e2, defaultValue) {
                if (_e2 != null) {
                  return callback(_e2);
                }
                return next(defaultValue);
              });
            } else {
              return next(_this.defaultValue);
            }
          });
        };
        return ParamNode;
      }(Node));
      Node.Regexp = RegexpNode = (function (Node) {
        var _Node_prototype, _RegexpNode_prototype;
        function RegexpNode(startIndex, endIndex, scopeId, source, flags) {
          var _this;
          _this = this instanceof RegexpNode ? this : __create(_RegexpNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(source instanceof Node)) {
            throw TypeError("Expected source to be a Node, got " + __typeof(source));
          }
          if (typeof flags !== "string") {
            throw TypeError("Expected flags to be a String, got " + __typeof(flags));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.source = source;
          _this.flags = flags;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _RegexpNode_prototype = RegexpNode.prototype = __create(_Node_prototype);
        _RegexpNode_prototype.constructor = RegexpNode;
        RegexpNode.displayName = "RegexpNode";
        RegexpNode.cappedName = "Regexp";
        RegexpNode.argNames = ["source", "flags"];
        State.addNodeFactory("regexp", RegexpNode);
        _RegexpNode_prototype.type = function () {
          return Type.regexp;
        };
        _RegexpNode_prototype._isNoop = function (o) {
          return this.text.isNoop(o);
        };
        _RegexpNode_prototype._reduce = function (o) {
          var source;
          source = this.source.reduce(o).doWrap(o);
          if (!source.isConst()) {
            return CallNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              IdentNode(this.startIndex, this.endIndex, this.scopeId, "RegExp"),
              [
                source,
                ConstNode(this.startIndex, this.endIndex, this.scopeId, this.flags)
              ]
            );
          } else if (source !== this.source) {
            return RegexpNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              source,
              this.flags
            );
          } else {
            return this;
          }
        };
        _RegexpNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "RegexpNode", this.source, this.flags);
        };
        _RegexpNode_prototype.walk = function (f) {
          var source;
          source = f(this.source);
          if (source !== this.source) {
            return RegexpNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              source,
              this.flags
            );
          } else {
            return this;
          }
        };
        _RegexpNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.source, function (_e, source) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, source !== _this.source
              ? RegexpNode(
                _this.startIndex,
                _this.endIndex,
                _this.scopeId,
                source,
                _this.flags
              )
              : _this);
          });
        };
        return RegexpNode;
      }(Node));
      Node.Return = ReturnNode = (function (Node) {
        var _Node_prototype, _ReturnNode_prototype;
        function ReturnNode(startIndex, endIndex, scopeId, node) {
          var _this;
          _this = this instanceof ReturnNode ? this : __create(_ReturnNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (node == null) {
            node = ConstNode(endIndex, endIndex, scopeId, void 0);
          } else if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.node = node;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _ReturnNode_prototype = ReturnNode.prototype = __create(_Node_prototype);
        _ReturnNode_prototype.constructor = ReturnNode;
        ReturnNode.displayName = "ReturnNode";
        ReturnNode.cappedName = "Return";
        ReturnNode.argNames = ["node"];
        State.addNodeFactory("return", ReturnNode);
        _ReturnNode_prototype.type = function (o) {
          return this.node.type(o);
        };
        _ReturnNode_prototype.isStatement = function () {
          return true;
        };
        _ReturnNode_prototype._reduce = function (o) {
          var node;
          node = this.node.reduce(o).doWrap(o);
          if (node !== this.node) {
            return ReturnNode(this.startIndex, this.endIndex, this.scopeId, node);
          } else {
            return this;
          }
        };
        _ReturnNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "ReturnNode", this.node);
        };
        _ReturnNode_prototype.walk = function (f) {
          var node;
          node = f(this.node);
          if (node !== this.node) {
            return ReturnNode(this.startIndex, this.endIndex, this.scopeId, node);
          } else {
            return this;
          }
        };
        _ReturnNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.node, function (_e, node) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, node !== _this.node ? ReturnNode(_this.startIndex, _this.endIndex, _this.scopeId, node) : _this);
          });
        };
        return ReturnNode;
      }(Node));
      Node.Root = RootNode = (function (Node) {
        var _Node_prototype, _RootNode_prototype;
        function RootNode(startIndex, endIndex, scopeId, body) {
          var _this;
          _this = this instanceof RootNode ? this : __create(_RootNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(body instanceof Node)) {
            throw TypeError("Expected body to be a Node, got " + __typeof(body));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.body = body;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _RootNode_prototype = RootNode.prototype = __create(_Node_prototype);
        _RootNode_prototype.constructor = RootNode;
        RootNode.displayName = "RootNode";
        RootNode.cappedName = "Root";
        RootNode.argNames = ["body"];
        State.addNodeFactory("root", RootNode);
        _RootNode_prototype.isStatement = function () {
          return true;
        };
        _RootNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "RootNode", this.body);
        };
        _RootNode_prototype.walk = function (f) {
          var body;
          body = f(this.body);
          if (body !== this.body) {
            return RootNode(this.startIndex, this.endIndex, this.scopeId, body);
          } else {
            return this;
          }
        };
        _RootNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.body, function (_e, body) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, body !== _this.body ? RootNode(_this.startIndex, _this.endIndex, _this.scopeId, body) : _this);
          });
        };
        return RootNode;
      }(Node));
      Node.Spread = SpreadNode = (function (Node) {
        var _Node_prototype, _SpreadNode_prototype;
        function SpreadNode(startIndex, endIndex, scopeId, node) {
          var _this;
          _this = this instanceof SpreadNode ? this : __create(_SpreadNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.node = node;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _SpreadNode_prototype = SpreadNode.prototype = __create(_Node_prototype);
        _SpreadNode_prototype.constructor = SpreadNode;
        SpreadNode.displayName = "SpreadNode";
        SpreadNode.cappedName = "Spread";
        SpreadNode.argNames = ["node"];
        State.addNodeFactory("spread", SpreadNode);
        _SpreadNode_prototype._reduce = function (o) {
          var node;
          node = this.node.reduce(o).doWrap(o);
          if (node !== this.node) {
            return SpreadNode(this.startIndex, this.endIndex, this.scopeId, node);
          } else {
            return this;
          }
        };
        _SpreadNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "SpreadNode", this.node);
        };
        _SpreadNode_prototype.walk = function (f) {
          var node;
          node = f(this.node);
          if (node !== this.node) {
            return SpreadNode(this.startIndex, this.endIndex, this.scopeId, node);
          } else {
            return this;
          }
        };
        _SpreadNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.node, function (_e, node) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, node !== _this.node ? SpreadNode(_this.startIndex, _this.endIndex, _this.scopeId, node) : _this);
          });
        };
        return SpreadNode;
      }(Node));
      State.prototype.string = function (index, parts) {
        var _i, _len, concatOp, current, part;
        if (!__isArray(parts)) {
          throw TypeError("Expected parts to be an Array, got " + __typeof(parts));
        } else {
          for (_i = 0, _len = parts.length; _i < _len; ++_i) {
            if (!(parts[_i] instanceof Node)) {
              throw TypeError("Expected parts[" + _i + "] to be a Node, got " + __typeof(parts[_i]));
            }
          }
        }
        concatOp = this.macros.getByLabel("stringConcat");
        if (!concatOp) {
          throw Error("Cannot use string interpolation until the string-concat operator has been defined");
        }
        if (parts.length === 0) {
          return ConstNode(index, index, this.scope.id, "");
        } else if (parts.length === 1) {
          return concatOp.func(
            {
              left: ConstNode(index, index, this.scope.id, ""),
              op: "",
              right: parts[0]
            },
            this,
            index,
            this.line
          );
        } else {
          current = parts[0];
          for (_i = 1, _len = parts.length; _i < _len; ++_i) {
            part = parts[_i];
            current = concatOp.func(
              { left: current, op: "", right: part },
              this,
              index,
              this.line
            );
          }
          return current;
        }
      };
      Node.Super = SuperNode = (function (Node) {
        var _Node_prototype, _SuperNode_prototype;
        function SuperNode(startIndex, endIndex, scopeId, child, args) {
          var _i, _len, _this;
          _this = this instanceof SuperNode ? this : __create(_SuperNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (child == null) {
            child = void 0;
          } else if (!(child instanceof Node)) {
            throw TypeError("Expected child to be a Node or undefined, got " + __typeof(child));
          }
          if (!__isArray(args)) {
            throw TypeError("Expected args to be an Array, got " + __typeof(args));
          } else {
            for (_i = 0, _len = args.length; _i < _len; ++_i) {
              if (!(args[_i] instanceof Node)) {
                throw TypeError("Expected args[" + _i + "] to be a Node, got " + __typeof(args[_i]));
              }
            }
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.child = child;
          _this.args = args;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _SuperNode_prototype = SuperNode.prototype = __create(_Node_prototype);
        _SuperNode_prototype.constructor = SuperNode;
        SuperNode.displayName = "SuperNode";
        SuperNode.cappedName = "Super";
        SuperNode.argNames = ["child", "args"];
        State.addNodeFactory("super", SuperNode);
        _SuperNode_prototype._reduce = function (o) {
          var args, child;
          if (this.child != null) {
            child = this.child.reduce(o).doWrap(o);
          } else {
            child = this.child;
          }
          args = map(
            this.args,
            function (node, o) {
              return node.reduce(o).doWrap(o);
            },
            o
          );
          if (child !== this.child || args !== this.args) {
            return SuperNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              child,
              args
            );
          } else {
            return this;
          }
        };
        _SuperNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "SuperNode", this.child, this.args);
        };
        _SuperNode_prototype.walk = function (f) {
          var args, child;
          if (this.child instanceof Node) {
            child = f(this.child);
          } else {
            child = this.child;
          }
          args = map(this.args, f);
          if (child !== this.child || args !== this.args) {
            return SuperNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              child,
              args
            );
          } else {
            return this;
          }
        };
        _SuperNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          function next(child) {
            return mapAsync(_this.args, f, function (_e, args) {
              if (_e != null) {
                return callback(_e);
              }
              return callback(null, child !== _this.child || args !== _this.args
                ? SuperNode(
                  _this.startIndex,
                  _this.endIndex,
                  _this.scopeId,
                  child,
                  args
                )
                : _this);
            });
          }
          if (this.child instanceof Node) {
            return f(this.child, function (_e, child) {
              if (_e != null) {
                return callback(_e);
              }
              return next(child);
            });
          } else {
            return next(this.child);
          }
        };
        return SuperNode;
      }(Node));
      Node.Switch = SwitchNode = (function (Node) {
        var _Node_prototype, _SwitchNode_prototype;
        function SwitchNode(startIndex, endIndex, scopeId, node, cases, defaultCase, label) {
          var _this;
          _this = this instanceof SwitchNode ? this : __create(_SwitchNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          if (!__isArray(cases)) {
            throw TypeError("Expected cases to be an Array, got " + __typeof(cases));
          }
          if (defaultCase == null) {
            defaultCase = void 0;
          } else if (!(defaultCase instanceof Node)) {
            throw TypeError("Expected defaultCase to be a Node or undefined, got " + __typeof(defaultCase));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.node = node;
          _this.cases = cases;
          _this.defaultCase = defaultCase;
          _this.label = label;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _SwitchNode_prototype = SwitchNode.prototype = __create(_Node_prototype);
        _SwitchNode_prototype.constructor = SwitchNode;
        SwitchNode.displayName = "SwitchNode";
        SwitchNode.cappedName = "Switch";
        SwitchNode.argNames = ["node", "cases", "defaultCase", "label"];
        State.addNodeFactory("switch", SwitchNode);
        _SwitchNode_prototype.type = function (o) {
          var _ref, _this;
          _this = this;
          if ((_ref = this._type) == null) {
            return this._type = (function () {
              var _arr, _i, _len, case_, type;
              if (_this.defaultCase != null) {
                type = _this.defaultCase.type(o);
              } else {
                type = Type["undefined"];
              }
              for (_arr = __toArray(_this.cases), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                case_ = _arr[_i];
                if (case_.fallthrough) {
                  type = type;
                } else {
                  type = type.union(case_.body.type(o));
                }
              }
              return type;
            }());
          } else {
            return _ref;
          }
        };
        _SwitchNode_prototype.withLabel = function (label) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return SwitchNode(
            this.startIndex,
            this.endIndex,
            this.scopeId,
            this.node,
            this.cases,
            this.defaultCase,
            label
          );
        };
        _SwitchNode_prototype.walk = function (f) {
          var cases, defaultCase, label, node;
          node = f(this.node);
          cases = map(this.cases, function (case_) {
            var caseBody, caseNode;
            caseNode = f(case_.node);
            caseBody = f(case_.body);
            if (caseNode !== case_.node || caseBody !== case_.body) {
              return { node: caseNode, body: caseBody, fallthrough: case_.fallthrough };
            } else {
              return case_;
            }
          });
          if (this.defaultCase) {
            defaultCase = f(this.defaultCase);
          } else {
            defaultCase = this.defaultCase;
          }
          if (this.label != null) {
            label = f(this.label);
          } else {
            label = this.label;
          }
          if (node !== this.node || cases !== this.cases || defaultCase !== this.defaultCase || label !== this.label) {
            return SwitchNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              node,
              cases,
              defaultCase,
              label
            );
          } else {
            return this;
          }
        };
        _SwitchNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.node, function (_e, node) {
            if (_e != null) {
              return callback(_e);
            }
            return mapAsync(
              _this.cases,
              function (case_, cb) {
                return f(case_.node, function (_e2, caseNode) {
                  if (_e2 != null) {
                    return cb(_e2);
                  }
                  return f(case_.body, function (_e3, caseBody) {
                    if (_e3 != null) {
                      return cb(_e3);
                    }
                    return cb(null, caseNode !== case_.node || caseBody !== case_.body ? { node: caseNode, body: caseBody, fallthrough: case_.fallthrough } : case_);
                  });
                });
              },
              function (_e2, cases) {
                if (_e2 != null) {
                  return callback(_e2);
                }
                function next(defaultCase) {
                  function next(label) {
                    return callback(null, node !== _this.node || cases !== _this.cases || defaultCase !== _this.defaultCase || label !== _this.label
                      ? SwitchNode(
                        _this.startIndex,
                        _this.endIndex,
                        _this.scopeId,
                        node,
                        cases,
                        defaultCase,
                        label
                      )
                      : _this);
                  }
                  if (_this.label != null) {
                    return f(_this.label, function (_e3, x) {
                      if (_e3 != null) {
                        return callback(_e3);
                      }
                      return next(x);
                    });
                  } else {
                    return next(_this.label);
                  }
                }
                if (_this.defaultCase != null) {
                  return f(_this.defaultCase, function (_e3, x) {
                    if (_e3 != null) {
                      return callback(_e3);
                    }
                    return next(x);
                  });
                } else {
                  return next(_this.defaultCase);
                }
              }
            );
          });
        };
        _SwitchNode_prototype.isStatement = function () {
          return true;
        };
        _SwitchNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "SwitchNode",
            this.node,
            this.cases,
            this.defaultCase,
            this.label
          );
        };
        return SwitchNode;
      }(Node));
      Node.SyntaxChoice = SyntaxChoiceNode = (function (Node) {
        var _Node_prototype, _SyntaxChoiceNode_prototype;
        function SyntaxChoiceNode(startIndex, endIndex, scopeId, choices) {
          var _i, _len, _this;
          _this = this instanceof SyntaxChoiceNode ? this : __create(_SyntaxChoiceNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!__isArray(choices)) {
            throw TypeError("Expected choices to be an Array, got " + __typeof(choices));
          } else {
            for (_i = 0, _len = choices.length; _i < _len; ++_i) {
              if (!(choices[_i] instanceof Node)) {
                throw TypeError("Expected choices[" + _i + "] to be a Node, got " + __typeof(choices[_i]));
              }
            }
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.choices = choices;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _SyntaxChoiceNode_prototype = SyntaxChoiceNode.prototype = __create(_Node_prototype);
        _SyntaxChoiceNode_prototype.constructor = SyntaxChoiceNode;
        SyntaxChoiceNode.displayName = "SyntaxChoiceNode";
        SyntaxChoiceNode.cappedName = "SyntaxChoice";
        SyntaxChoiceNode.argNames = ["choices"];
        State.addNodeFactory("syntaxChoice", SyntaxChoiceNode);
        _SyntaxChoiceNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "SyntaxChoiceNode", this.choices);
        };
        _SyntaxChoiceNode_prototype.walk = function (f) {
          var choices;
          choices = map(this.choices, f);
          if (choices !== this.choices) {
            return SyntaxChoiceNode(this.startIndex, this.endIndex, this.scopeId, choices);
          } else {
            return this;
          }
        };
        _SyntaxChoiceNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return mapAsync(this.choices, f, function (_e, choices) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, choices !== _this.choices ? SyntaxChoiceNode(_this.startIndex, _this.endIndex, _this.scopeId, choices) : _this);
          });
        };
        return SyntaxChoiceNode;
      }(Node));
      Node.SyntaxMany = SyntaxManyNode = (function (Node) {
        var _Node_prototype, _SyntaxManyNode_prototype;
        function SyntaxManyNode(startIndex, endIndex, scopeId, inner, multiplier) {
          var _this;
          _this = this instanceof SyntaxManyNode ? this : __create(_SyntaxManyNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(inner instanceof Node)) {
            throw TypeError("Expected inner to be a Node, got " + __typeof(inner));
          }
          if (typeof multiplier !== "string") {
            throw TypeError("Expected multiplier to be a String, got " + __typeof(multiplier));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.inner = inner;
          _this.multiplier = multiplier;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _SyntaxManyNode_prototype = SyntaxManyNode.prototype = __create(_Node_prototype);
        _SyntaxManyNode_prototype.constructor = SyntaxManyNode;
        SyntaxManyNode.displayName = "SyntaxManyNode";
        SyntaxManyNode.cappedName = "SyntaxMany";
        SyntaxManyNode.argNames = ["inner", "multiplier"];
        State.addNodeFactory("syntaxMany", SyntaxManyNode);
        _SyntaxManyNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "SyntaxManyNode", this.inner, this.multiplier);
        };
        _SyntaxManyNode_prototype.walk = function (f) {
          var inner;
          inner = f(this.inner);
          if (inner !== this.inner) {
            return SyntaxManyNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              inner,
              this.multiplier
            );
          } else {
            return this;
          }
        };
        _SyntaxManyNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.inner, function (_e, inner) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, inner !== _this.inner
              ? SyntaxManyNode(
                _this.startIndex,
                _this.endIndex,
                _this.scopeId,
                inner,
                _this.multiplier
              )
              : _this);
          });
        };
        return SyntaxManyNode;
      }(Node));
      Node.SyntaxParam = SyntaxParamNode = (function (Node) {
        var _Node_prototype, _SyntaxParamNode_prototype;
        function SyntaxParamNode(startIndex, endIndex, scopeId, ident, asType) {
          var _this;
          _this = this instanceof SyntaxParamNode ? this : __create(_SyntaxParamNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(ident instanceof Node)) {
            throw TypeError("Expected ident to be a Node, got " + __typeof(ident));
          }
          if (asType == null) {
            asType = void 0;
          } else if (!(asType instanceof Node)) {
            throw TypeError("Expected asType to be a Node or undefined, got " + __typeof(asType));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.ident = ident;
          _this.asType = asType;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _SyntaxParamNode_prototype = SyntaxParamNode.prototype = __create(_Node_prototype);
        _SyntaxParamNode_prototype.constructor = SyntaxParamNode;
        SyntaxParamNode.displayName = "SyntaxParamNode";
        SyntaxParamNode.cappedName = "SyntaxParam";
        SyntaxParamNode.argNames = ["ident", "asType"];
        State.addNodeFactory("syntaxParam", SyntaxParamNode);
        _SyntaxParamNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "SyntaxParamNode", this.ident, this.asType);
        };
        _SyntaxParamNode_prototype.walk = function (f) {
          var asType, ident;
          ident = f(this.ident);
          if (this.asType instanceof Node) {
            asType = f(this.asType);
          } else {
            asType = this.asType;
          }
          if (ident !== this.ident || asType !== this.asType) {
            return SyntaxParamNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              ident,
              asType
            );
          } else {
            return this;
          }
        };
        _SyntaxParamNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.ident, function (_e, ident) {
            if (_e != null) {
              return callback(_e);
            }
            function next(asType) {
              return callback(null, ident !== _this.ident || asType !== _this.asType
                ? SyntaxParamNode(
                  _this.startIndex,
                  _this.endIndex,
                  _this.scopeId,
                  ident,
                  asType
                )
                : _this);
            }
            if (_this.asType instanceof Node) {
              return f(_this.asType, function (_e2, asType) {
                if (_e2 != null) {
                  return callback(_e2);
                }
                return next(asType);
              });
            } else {
              return next(_this.asType);
            }
          });
        };
        return SyntaxParamNode;
      }(Node));
      Node.SyntaxSequence = SyntaxSequenceNode = (function (Node) {
        var _Node_prototype, _SyntaxSequenceNode_prototype;
        function SyntaxSequenceNode(startIndex, endIndex, scopeId, params) {
          var _i, _len, _this;
          _this = this instanceof SyntaxSequenceNode ? this : __create(_SyntaxSequenceNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!__isArray(params)) {
            throw TypeError("Expected params to be an Array, got " + __typeof(params));
          } else {
            for (_i = 0, _len = params.length; _i < _len; ++_i) {
              if (!(params[_i] instanceof Node)) {
                throw TypeError("Expected params[" + _i + "] to be a Node, got " + __typeof(params[_i]));
              }
            }
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.params = params;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _SyntaxSequenceNode_prototype = SyntaxSequenceNode.prototype = __create(_Node_prototype);
        _SyntaxSequenceNode_prototype.constructor = SyntaxSequenceNode;
        SyntaxSequenceNode.displayName = "SyntaxSequenceNode";
        SyntaxSequenceNode.cappedName = "SyntaxSequence";
        SyntaxSequenceNode.argNames = ["params"];
        State.addNodeFactory("syntaxSequence", SyntaxSequenceNode);
        _SyntaxSequenceNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "SyntaxSequenceNode", this.params);
        };
        _SyntaxSequenceNode_prototype.walk = function (f) {
          var params;
          params = map(this.params, f);
          if (params !== this.params) {
            return SyntaxSequenceNode(this.startIndex, this.endIndex, this.scopeId, params);
          } else {
            return this;
          }
        };
        _SyntaxSequenceNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return mapAsync(this.params, f, function (_e, params) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, params !== _this.params ? SyntaxSequenceNode(_this.startIndex, _this.endIndex, _this.scopeId, params) : _this);
          });
        };
        return SyntaxSequenceNode;
      }(Node));
      Node.This = ThisNode = (function (Node) {
        var _Node_prototype, _ThisNode_prototype;
        function ThisNode(startIndex, endIndex, scopeId) {
          var _this;
          _this = this instanceof ThisNode ? this : __create(_ThisNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _ThisNode_prototype = ThisNode.prototype = __create(_Node_prototype);
        _ThisNode_prototype.constructor = ThisNode;
        ThisNode.displayName = "ThisNode";
        ThisNode.cappedName = "This";
        ThisNode.argNames = [];
        State.addNodeFactory("this", ThisNode);
        _ThisNode_prototype.cacheable = false;
        _ThisNode_prototype._isNoop = function () {
          return true;
        };
        _ThisNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "ThisNode");
        };
        return ThisNode;
      }(Node));
      Node.Throw = ThrowNode = (function (Node) {
        var _Node_prototype, _ThrowNode_prototype;
        function ThrowNode(startIndex, endIndex, scopeId, node) {
          var _this;
          _this = this instanceof ThrowNode ? this : __create(_ThrowNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.node = node;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _ThrowNode_prototype = ThrowNode.prototype = __create(_Node_prototype);
        _ThrowNode_prototype.constructor = ThrowNode;
        ThrowNode.displayName = "ThrowNode";
        ThrowNode.cappedName = "Throw";
        ThrowNode.argNames = ["node"];
        State.addNodeFactory("throw", ThrowNode);
        _ThrowNode_prototype.type = function () {
          return Type.none;
        };
        _ThrowNode_prototype.isStatement = function () {
          return true;
        };
        _ThrowNode_prototype._reduce = function (o) {
          var node;
          node = this.node.reduce(o).doWrap(o);
          if (node !== this.node) {
            return ThrowNode(this.startIndex, this.endIndex, this.scopeId, node);
          } else {
            return this;
          }
        };
        _ThrowNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "ThrowNode", this.node);
        };
        _ThrowNode_prototype.walk = function (f) {
          var node;
          node = f(this.node);
          if (node !== this.node) {
            return ThrowNode(this.startIndex, this.endIndex, this.scopeId, node);
          } else {
            return this;
          }
        };
        _ThrowNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.node, function (_e, node) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, node !== _this.node ? ThrowNode(_this.startIndex, _this.endIndex, _this.scopeId, node) : _this);
          });
        };
        return ThrowNode;
      }(Node));
      Node.Tmp = TmpNode = (function (Node) {
        var _Node_prototype, _TmpNode_prototype;
        function TmpNode(startIndex, endIndex, scopeId, id, name, _type) {
          var _this;
          _this = this instanceof TmpNode ? this : __create(_TmpNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (typeof id !== "number") {
            throw TypeError("Expected id to be a Number, got " + __typeof(id));
          }
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (_type == null) {
            _type = Type.any;
          } else if (!(_type instanceof Type)) {
            throw TypeError("Expected _type to be a Type, got " + __typeof(_type));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.id = id;
          _this.name = name;
          _this._type = _type;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _TmpNode_prototype = TmpNode.prototype = __create(_Node_prototype);
        _TmpNode_prototype.constructor = TmpNode;
        TmpNode.displayName = "TmpNode";
        TmpNode.cappedName = "Tmp";
        TmpNode.argNames = ["id", "name", "_type"];
        State.addNodeFactory("tmp", TmpNode);
        _TmpNode_prototype.cacheable = false;
        _TmpNode_prototype.type = function () {
          return this._type;
        };
        _TmpNode_prototype._isNoop = function () {
          return true;
        };
        _TmpNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "TmpNode",
            this.id,
            this.name,
            this._type
          );
        };
        _TmpNode_prototype.walk = function (f) {
          return this;
        };
        _TmpNode_prototype.walkAsync = function (f, callback) {
          return callback(null, this);
        };
        return TmpNode;
      }(Node));
      Node.TmpWrapper = TmpWrapperNode = (function (Node) {
        var _Node_prototype, _TmpWrapperNode_prototype;
        function TmpWrapperNode(startIndex, endIndex, scopeId, node, tmps) {
          var _this;
          _this = this instanceof TmpWrapperNode ? this : __create(_TmpWrapperNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          if (!__isArray(tmps)) {
            throw TypeError("Expected tmps to be an Array, got " + __typeof(tmps));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.node = node;
          _this.tmps = tmps;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _TmpWrapperNode_prototype = TmpWrapperNode.prototype = __create(_Node_prototype);
        _TmpWrapperNode_prototype.constructor = TmpWrapperNode;
        TmpWrapperNode.displayName = "TmpWrapperNode";
        TmpWrapperNode.cappedName = "TmpWrapper";
        TmpWrapperNode.argNames = ["node", "tmps"];
        State.addNodeFactory("tmpWrapper", TmpWrapperNode);
        _TmpWrapperNode_prototype.type = function (o) {
          return this.node.type(o);
        };
        _TmpWrapperNode_prototype.withLabel = function (label, o) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return TmpWrapperNode(
            this.startIndex,
            this.endIndex,
            this.scopeId,
            this.node.withLabel(label, o),
            this.tmps
          );
        };
        _TmpWrapperNode_prototype._reduce = function (o) {
          var node;
          node = this.node.reduce(o);
          if (this.tmps.length === 0) {
            return node;
          } else if (this.node !== node) {
            return TmpWrapperNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              node,
              this.tmps
            );
          } else {
            return this;
          }
        };
        _TmpWrapperNode_prototype.isStatement = function () {
          return this.node.isStatement();
        };
        _TmpWrapperNode_prototype._isNoop = function (o) {
          return this.node.isNoop(o);
        };
        _TmpWrapperNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "TmpWrapperNode", this.node, this.tmps);
        };
        _TmpWrapperNode_prototype.walk = function (f) {
          var node;
          node = f(this.node);
          if (node !== this.node) {
            return TmpWrapperNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              node,
              this.tmps
            );
          } else {
            return this;
          }
        };
        _TmpWrapperNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.node, function (_e, node) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, node !== _this.node
              ? TmpWrapperNode(
                _this.startIndex,
                _this.endIndex,
                _this.scopeId,
                node,
                _this.tmps
              )
              : _this);
          });
        };
        return TmpWrapperNode;
      }(Node));
      Node.TryCatch = TryCatchNode = (function (Node) {
        var _Node_prototype, _TryCatchNode_prototype;
        function TryCatchNode(startIndex, endIndex, scopeId, tryBody, catchIdent, catchBody, label) {
          var _this;
          _this = this instanceof TryCatchNode ? this : __create(_TryCatchNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(tryBody instanceof Node)) {
            throw TypeError("Expected tryBody to be a Node, got " + __typeof(tryBody));
          }
          if (!(catchIdent instanceof Node)) {
            throw TypeError("Expected catchIdent to be a Node, got " + __typeof(catchIdent));
          }
          if (!(catchBody instanceof Node)) {
            throw TypeError("Expected catchBody to be a Node, got " + __typeof(catchBody));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.tryBody = tryBody;
          _this.catchIdent = catchIdent;
          _this.catchBody = catchBody;
          _this.label = label;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _TryCatchNode_prototype = TryCatchNode.prototype = __create(_Node_prototype);
        _TryCatchNode_prototype.constructor = TryCatchNode;
        TryCatchNode.displayName = "TryCatchNode";
        TryCatchNode.cappedName = "TryCatch";
        TryCatchNode.argNames = ["tryBody", "catchIdent", "catchBody", "label"];
        State.addNodeFactory("tryCatch", TryCatchNode);
        _TryCatchNode_prototype.type = function (o) {
          var _ref;
          if ((_ref = this._type) == null) {
            return this._type = this.tryBody.type(o).union(this.catchBody.type(o));
          } else {
            return _ref;
          }
        };
        _TryCatchNode_prototype.isStatement = function () {
          return true;
        };
        _TryCatchNode_prototype._isNoop = function (o) {
          return this.tryBody.isNoop(o);
        };
        _TryCatchNode_prototype.withLabel = function (label) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return TryCatchNode(
            this.startIndex,
            this.endIndex,
            this.scopeId,
            this.tryBody,
            this.catchIdent,
            this.catchBody,
            label
          );
        };
        _TryCatchNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "TryCatchNode",
            this.tryBody,
            this.catchIdent,
            this.catchBody,
            this.label
          );
        };
        _TryCatchNode_prototype.walk = function (f) {
          var catchBody, catchIdent, label, tryBody;
          tryBody = f(this.tryBody);
          catchIdent = f(this.catchIdent);
          catchBody = f(this.catchBody);
          if (this.label instanceof Node) {
            label = f(this.label);
          } else {
            label = this.label;
          }
          if (tryBody !== this.tryBody || catchIdent !== this.catchIdent || catchBody !== this.catchBody || label !== this.label) {
            return TryCatchNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              tryBody,
              catchIdent,
              catchBody,
              label
            );
          } else {
            return this;
          }
        };
        _TryCatchNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.tryBody, function (_e, tryBody) {
            if (_e != null) {
              return callback(_e);
            }
            return f(_this.catchIdent, function (_e2, catchIdent) {
              if (_e2 != null) {
                return callback(_e2);
              }
              return f(_this.catchBody, function (_e3, catchBody) {
                if (_e3 != null) {
                  return callback(_e3);
                }
                function next(label) {
                  return callback(null, tryBody !== _this.tryBody || catchIdent !== _this.catchIdent || catchBody !== _this.catchBody || label !== _this.label
                    ? TryCatchNode(
                      _this.startIndex,
                      _this.endIndex,
                      _this.scopeId,
                      tryBody,
                      catchIdent,
                      catchBody,
                      label
                    )
                    : _this);
                }
                if (_this.label instanceof Node) {
                  return f(_this.label, function (_e4, label) {
                    if (_e4 != null) {
                      return callback(_e4);
                    }
                    return next(label);
                  });
                } else {
                  return next(_this.label);
                }
              });
            });
          });
        };
        return TryCatchNode;
      }(Node));
      Node.TryFinally = TryFinallyNode = (function (Node) {
        var _Node_prototype, _TryFinallyNode_prototype;
        function TryFinallyNode(startIndex, endIndex, scopeId, tryBody, finallyBody, label) {
          var _this;
          _this = this instanceof TryFinallyNode ? this : __create(_TryFinallyNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(tryBody instanceof Node)) {
            throw TypeError("Expected tryBody to be a Node, got " + __typeof(tryBody));
          }
          if (!(finallyBody instanceof Node)) {
            throw TypeError("Expected finallyBody to be a Node, got " + __typeof(finallyBody));
          }
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.tryBody = tryBody;
          _this.finallyBody = finallyBody;
          _this.label = label;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _TryFinallyNode_prototype = TryFinallyNode.prototype = __create(_Node_prototype);
        _TryFinallyNode_prototype.constructor = TryFinallyNode;
        TryFinallyNode.displayName = "TryFinallyNode";
        TryFinallyNode.cappedName = "TryFinally";
        TryFinallyNode.argNames = ["tryBody", "finallyBody", "label"];
        State.addNodeFactory("tryFinally", TryFinallyNode);
        _TryFinallyNode_prototype.type = function (o) {
          return this.tryBody.type(o);
        };
        _TryFinallyNode_prototype._reduce = function (o) {
          var finallyBody, label, tryBody;
          tryBody = this.tryBody.reduce(o);
          finallyBody = this.finallyBody.reduce(o);
          if (this.label != null) {
            label = this.label.reduce(o);
          } else {
            label = this.label;
          }
          if (finallyBody instanceof NothingNode) {
            return BlockNode(this.startIndex, this.endIndex, this.scopeIf([tryBody], label)).reduce(o);
          } else if (tryBody instanceof NothingNode) {
            return BlockNode(this.startIndex, this.endIndex, this.scopeIf([finallyBody], label)).reduce(o);
          } else if (tryBody !== this.tryBody || finallyBody !== this.finallyBody || label !== this.label) {
            return TryFinallyNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              tryBody,
              finallyBody,
              label
            );
          } else {
            return this;
          }
        };
        _TryFinallyNode_prototype.isStatement = function () {
          return true;
        };
        _TryFinallyNode_prototype._isNoop = function (o) {
          var _ref;
          if ((_ref = this.__isNoop) == null) {
            return this.__isNoop = this.tryBody.isNoop(o) && this.finallyBody.isNoop();
          } else {
            return _ref;
          }
        };
        _TryFinallyNode_prototype.withLabel = function (label) {
          if (label == null) {
            label = null;
          } else if (!(label instanceof IdentNode) && !(label instanceof TmpNode)) {
            throw TypeError("Expected label to be an IdentNode or TmpNode or null, got " + __typeof(label));
          }
          return TryFinallyNode(
            this.startIndex,
            this.endIndex,
            this.scopeId,
            this.tryBody,
            this.finallyBody,
            label
          );
        };
        _TryFinallyNode_prototype.inspect = function (depth) {
          return inspectHelper(
            depth,
            "TryFinallyNode",
            this.tryBody,
            this.finallyBody,
            this.label
          );
        };
        _TryFinallyNode_prototype.walk = function (f) {
          var finallyBody, label, tryBody;
          tryBody = f(this.tryBody);
          finallyBody = f(this.finallyBody);
          if (this.label instanceof Node) {
            label = f(this.label);
          } else {
            label = this.label;
          }
          if (tryBody !== this.tryBody || finallyBody !== this.finallyBody || label !== this.label) {
            return TryFinallyNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              tryBody,
              finallyBody,
              label
            );
          } else {
            return this;
          }
        };
        _TryFinallyNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.tryBody, function (_e, tryBody) {
            if (_e != null) {
              return callback(_e);
            }
            return f(_this.finallyBody, function (_e2, finallyBody) {
              if (_e2 != null) {
                return callback(_e2);
              }
              function next(label) {
                return callback(null, tryBody !== _this.tryBody || finallyBody !== _this.finallyBody || label !== _this.label
                  ? TryFinallyNode(
                    _this.startIndex,
                    _this.endIndex,
                    _this.scopeId,
                    tryBody,
                    finallyBody,
                    label
                  )
                  : _this);
              }
              if (_this.label instanceof Node) {
                return f(_this.label, function (_e3, label) {
                  if (_e3 != null) {
                    return callback(_e3);
                  }
                  return next(label);
                });
              } else {
                return next(_this.label);
              }
            });
          });
        };
        return TryFinallyNode;
      }(Node));
      Node.TypeArray = TypeArrayNode = (function (Node) {
        var _Node_prototype, _TypeArrayNode_prototype;
        function TypeArrayNode(startIndex, endIndex, scopeId, subtype) {
          var _this;
          _this = this instanceof TypeArrayNode ? this : __create(_TypeArrayNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(subtype instanceof Node)) {
            throw TypeError("Expected subtype to be a Node, got " + __typeof(subtype));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.subtype = subtype;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _TypeArrayNode_prototype = TypeArrayNode.prototype = __create(_Node_prototype);
        _TypeArrayNode_prototype.constructor = TypeArrayNode;
        TypeArrayNode.displayName = "TypeArrayNode";
        TypeArrayNode.cappedName = "TypeArray";
        TypeArrayNode.argNames = ["subtype"];
        State.addNodeFactory("typeArray", TypeArrayNode);
        _TypeArrayNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "TypeArrayNode", this.subtype);
        };
        _TypeArrayNode_prototype.walk = function (f) {
          var subtype;
          subtype = f(this.subtype);
          if (subtype !== this.subtype) {
            return TypeArrayNode(this.startIndex, this.endIndex, this.scopeId, subtype);
          } else {
            return this;
          }
        };
        _TypeArrayNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.subtype, function (_e, subtype) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, subtype !== _this.subtype ? TypeArrayNode(_this.startIndex, _this.endIndex, _this.scopeId, subtype) : _this);
          });
        };
        return TypeArrayNode;
      }(Node));
      Node.TypeFunction = TypeFunctionNode = (function (Node) {
        var _Node_prototype, _TypeFunctionNode_prototype;
        function TypeFunctionNode(startIndex, endIndex, scopeId, returnType) {
          var _this;
          _this = this instanceof TypeFunctionNode ? this : __create(_TypeFunctionNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(returnType instanceof Node)) {
            throw TypeError("Expected returnType to be a Node, got " + __typeof(returnType));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.returnType = returnType;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _TypeFunctionNode_prototype = TypeFunctionNode.prototype = __create(_Node_prototype);
        _TypeFunctionNode_prototype.constructor = TypeFunctionNode;
        TypeFunctionNode.displayName = "TypeFunctionNode";
        TypeFunctionNode.cappedName = "TypeFunction";
        TypeFunctionNode.argNames = ["returnType"];
        State.addNodeFactory("typeFunction", TypeFunctionNode);
        _TypeFunctionNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "TypeFunctionNode", this.returnType);
        };
        _TypeFunctionNode_prototype.walk = function (f) {
          var returnType;
          returnType = f(this.returnType);
          if (returnType !== this.returnType) {
            return TypeFunctionNode(this.startIndex, this.endIndex, this.scopeId, returnType);
          } else {
            return this;
          }
        };
        _TypeFunctionNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.returnType, function (_e, returnType) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, returnType !== _this.returnType ? TypeFunctionNode(_this.startIndex, _this.endIndex, _this.scopeId, returnType) : _this);
          });
        };
        return TypeFunctionNode;
      }(Node));
      Node.TypeObject = TypeObjectNode = (function (Node) {
        var _Node_prototype, _TypeObjectNode_prototype;
        function TypeObjectNode(startIndex, endIndex, scopeId, pairs) {
          var _this;
          _this = this instanceof TypeObjectNode ? this : __create(_TypeObjectNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!__isArray(pairs)) {
            throw TypeError("Expected pairs to be an Array, got " + __typeof(pairs));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.pairs = pairs;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _TypeObjectNode_prototype = TypeObjectNode.prototype = __create(_Node_prototype);
        _TypeObjectNode_prototype.constructor = TypeObjectNode;
        TypeObjectNode.displayName = "TypeObjectNode";
        TypeObjectNode.cappedName = "TypeObject";
        TypeObjectNode.argNames = ["pairs"];
        State.addNodeFactory("typeObject", TypeObjectNode);
        function reducePair(pair, o) {
          var key, value;
          key = pair.key.reduce(o);
          value = pair.value.reduce(o);
          if (key !== pair.key || value !== pair.value) {
            return { key: key, value: value };
          } else {
            return pair;
          }
        }
        _TypeObjectNode_prototype._reduce = function (o) {
          var pairs;
          pairs = map(this.pairs, reducePair, o);
          if (pairs !== this.pairs) {
            return TypeObjectNode(this.startIndex, this.endIndex, this.scopeId, pairs);
          } else {
            return this;
          }
        };
        _TypeObjectNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "TypeObjectNode", this.pairs);
        };
        _TypeObjectNode_prototype.walk = function (f) {
          return this;
        };
        _TypeObjectNode_prototype.walkAsync = function (f, callback) {
          return callback(null, this);
        };
        return TypeObjectNode;
      }(Node));
      Node.TypeUnion = TypeUnionNode = (function (Node) {
        var _Node_prototype, _TypeUnionNode_prototype;
        function TypeUnionNode(startIndex, endIndex, scopeId, types) {
          var _i, _len, _this;
          _this = this instanceof TypeUnionNode ? this : __create(_TypeUnionNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!__isArray(types)) {
            throw TypeError("Expected types to be an Array, got " + __typeof(types));
          } else {
            for (_i = 0, _len = types.length; _i < _len; ++_i) {
              if (!(types[_i] instanceof Node)) {
                throw TypeError("Expected types[" + _i + "] to be a Node, got " + __typeof(types[_i]));
              }
            }
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.types = types;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _TypeUnionNode_prototype = TypeUnionNode.prototype = __create(_Node_prototype);
        _TypeUnionNode_prototype.constructor = TypeUnionNode;
        TypeUnionNode.displayName = "TypeUnionNode";
        TypeUnionNode.cappedName = "TypeUnion";
        TypeUnionNode.argNames = ["types"];
        State.addNodeFactory("typeUnion", TypeUnionNode);
        _TypeUnionNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "TypeUnionNode", this.types);
        };
        _TypeUnionNode_prototype.walk = function (f) {
          var types;
          types = map(this.types, f);
          if (types !== this.types) {
            return TypeUnionNode(this.startIndex, this.endIndex, this.scopeId, types);
          } else {
            return this;
          }
        };
        _TypeUnionNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return mapAsync(this.types, f, function (_e, types) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, types !== _this.types ? TypeUnionNode(_this.startIndex, _this.endIndex, _this.scopeId, types) : _this);
          });
        };
        return TypeUnionNode;
      }(Node));
      Node.Unary = UnaryNode = (function (Node) {
        var _Node_prototype, _UnaryNode_prototype;
        function UnaryNode(startIndex, endIndex, scopeId, op, node) {
          var _this;
          _this = this instanceof UnaryNode ? this : __create(_UnaryNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (typeof op !== "string") {
            throw TypeError("Expected op to be a String, got " + __typeof(op));
          }
          if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.op = op;
          _this.node = node;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _UnaryNode_prototype = UnaryNode.prototype = __create(_Node_prototype);
        _UnaryNode_prototype.constructor = UnaryNode;
        UnaryNode.displayName = "UnaryNode";
        UnaryNode.cappedName = "Unary";
        UnaryNode.argNames = ["op", "node"];
        State.addNodeFactory("unary", UnaryNode);
        _UnaryNode_prototype.type = (function () {
          var ops;
          ops = {
            "-": Type.number,
            "+": Type.number,
            "--": Type.number,
            "++": Type.number,
            "--post": Type.number,
            "++post": Type.number,
            "!": Type.boolean,
            "~": Type.number,
            "typeof": Type.string,
            "delete": Type.boolean
          };
          return function () {
            var _ref;
            return (__owns.call(ops, _ref = this.op) ? ops[_ref] : void 0) || Type.any;
          };
        }());
        _UnaryNode_prototype._reduce = (function () {
          var constOps, nonconstOps;
          constOps = {
            "-": function (x) {
              return -x;
            },
            "+": function (x) {
              return +x;
            },
            "!": function (x) {
              return !x;
            },
            "~": function (x) {
              return ~x;
            },
            "typeof": function (x) {
              return typeof x;
            }
          };
          nonconstOps = {
            "+": function (node, o) {
              if (node.type(o).isSubsetOf(Type.number)) {
                return node;
              }
            },
            "-": function (node) {
              var _ref;
              if (node instanceof UnaryNode) {
                if ((_ref = node.op) === "-" || _ref === "+") {
                  return UnaryNode(
                    this.startIndex,
                    this.endIndex,
                    this.scopeId,
                    node.op === "-" ? "+" : "-",
                    node.node
                  );
                }
              } else if (node instanceof BinaryNode) {
                if ((_ref = node.op) === "-" || _ref === "+") {
                  return BinaryNode(
                    this.startIndex,
                    this.endIndex,
                    this.scopeId,
                    node.left,
                    node.op === "-" ? "+" : "-",
                    node.right
                  );
                } else if ((_ref = node.op) === "*" || _ref === "/") {
                  return BinaryNode(
                    this.startIndex,
                    this.endIndex,
                    this.scopeId,
                    UnaryNode(
                      this.startIndex,
                      node.left.endIndex,
                      node.left.scopeId,
                      "-",
                      node.left
                    ),
                    node.op,
                    node.right
                  );
                }
              }
            },
            "!": (function () {
              var invertibleBinaryOps;
              invertibleBinaryOps = {
                "<": ">=",
                "<=": ">",
                ">": "<=",
                ">=": "<",
                "==": "!=",
                "!=": "==",
                "===": "!==",
                "!==": "===",
                "&&": function (x, y) {
                  return BinaryNode(
                    this.startIndex,
                    this.endIndex,
                    this.scopeId,
                    UnaryNode(
                      x.startIndex,
                      x.endIndex,
                      x.scopeId,
                      "!",
                      x
                    ),
                    "||",
                    UnaryNode(
                      y.startIndex,
                      y.endIndex,
                      y.scopeId,
                      "!",
                      y
                    )
                  );
                },
                "||": function (x, y) {
                  return BinaryNode(
                    this.startIndex,
                    this.endIndex,
                    this.scopeId,
                    UnaryNode(
                      x.startIndex,
                      x.endIndex,
                      x.scopeId,
                      "!",
                      x
                    ),
                    "&&",
                    UnaryNode(
                      y.startIndex,
                      y.endIndex,
                      y.scopeId,
                      "!",
                      y
                    )
                  );
                }
              };
              return function (node, o) {
                var invert;
                if (node instanceof UnaryNode) {
                  if (node.op === "!" && node.node.type(o).isSubsetOf(Type.boolean)) {
                    return node.node;
                  }
                } else if (node instanceof BinaryNode && __owns.call(invertibleBinaryOps, node.op)) {
                  invert = invertibleBinaryOps[node.op];
                  if (typeof invert === "function") {
                    return invert.call(this, node.left, node.right);
                  } else {
                    return BinaryNode(
                      this.startIndex,
                      this.endIndex,
                      this.scopeId,
                      node.left,
                      invert,
                      node.right
                    );
                  }
                }
              };
            }()),
            "typeof": (function () {
              var objectType;
              objectType = Type["null"].union(Type.object).union(Type.arrayLike).union(Type.regexp).union(Type.date).union(Type.error);
              return function (node, o) {
                var type;
                if (node.isNoop(o)) {
                  type = node.type(o);
                  if (type.isSubsetOf(Type.number)) {
                    return ConstNode(this.startIndex, this.endIndex, this.scopeId, "number");
                  } else if (type.isSubsetOf(Type.string)) {
                    return ConstNode(this.startIndex, this.endIndex, this.scopeId, "string");
                  } else if (type.isSubsetOf(Type.boolean)) {
                    return ConstNode(this.startIndex, this.endIndex, this.scopeId, "boolean");
                  } else if (type.isSubsetOf(Type["undefined"])) {
                    return ConstNode(this.startIndex, this.endIndex, this.scopeId, "undefined");
                  } else if (type.isSubsetOf(Type["function"])) {
                    return ConstNode(this.startIndex, this.endIndex, this.scopeId, "function");
                  } else if (type.isSubsetOf(objectType)) {
                    return ConstNode(this.startIndex, this.endIndex, this.scopeId, "object");
                  }
                }
              };
            }())
          };
          return function (o) {
            var node, op, result;
            node = this.node.reduce(o).doWrap(o);
            op = this.op;
            if (node.isConst() && __owns.call(constOps, op)) {
              return ConstNode(this.startIndex, this.endIndex, this.scopeId, constOps[op](node.constValue()));
            }
            if (__owns.call(nonconstOps, op)) {
              result = nonconstOps[op].call(this, node, o);
            }
            if (result != null) {
              return result.reduce(o);
            }
            if (node !== this.node) {
              return UnaryNode(
                this.startIndex,
                this.endIndex,
                this.scopeId,
                op,
                node
              );
            } else {
              return this;
            }
          };
        }());
        _UnaryNode_prototype._isNoop = function (o) {
          var _ref, _ref2;
          if ((_ref = this.__isNoop) == null) {
            return this.__isNoop = (_ref2 = this.op) !== "++" && _ref2 !== "--" && _ref2 !== "++post" && _ref2 !== "--post" && _ref2 !== "delete" && this.node.isNoop(o);
          } else {
            return _ref;
          }
        };
        _UnaryNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "UnaryNode", this.op, this.node);
        };
        _UnaryNode_prototype.walk = function (f) {
          var node;
          node = f(this.node);
          if (node !== this.node) {
            return UnaryNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              this.op,
              node
            );
          } else {
            return this;
          }
        };
        _UnaryNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.node, function (_e, node) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, node !== _this.node
              ? UnaryNode(
                _this.startIndex,
                _this.endIndex,
                _this.scopeId,
                _this.op,
                node
              )
              : _this);
          });
        };
        return UnaryNode;
      }(Node));
      Node.Var = VarNode = (function (Node) {
        var _Node_prototype, _VarNode_prototype;
        function VarNode(startIndex, endIndex, scopeId, ident, isMutable) {
          var _this;
          _this = this instanceof VarNode ? this : __create(_VarNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(ident instanceof IdentNode) && !(ident instanceof TmpNode)) {
            throw TypeError("Expected ident to be an IdentNode or TmpNode, got " + __typeof(ident));
          }
          if (isMutable == null) {
            isMutable = false;
          } else if (typeof isMutable !== "boolean") {
            throw TypeError("Expected isMutable to be a Boolean, got " + __typeof(isMutable));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.ident = ident;
          _this.isMutable = isMutable;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _VarNode_prototype = VarNode.prototype = __create(_Node_prototype);
        _VarNode_prototype.constructor = VarNode;
        VarNode.displayName = "VarNode";
        VarNode.cappedName = "Var";
        VarNode.argNames = ["ident", "isMutable"];
        State.addNodeFactory("var", VarNode);
        _VarNode_prototype.type = function () {
          return Type["undefined"];
        };
        _VarNode_prototype._reduce = function (o) {
          var ident;
          ident = this.ident.reduce(o);
          if (ident !== this.ident) {
            return VarNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              ident,
              this.isMutable
            );
          } else {
            return this;
          }
        };
        _VarNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "VarNode", this.ident, this.isMutable);
        };
        _VarNode_prototype.walk = function (f) {
          var ident;
          ident = f(this.ident);
          if (ident !== this.ident) {
            return VarNode(
              this.startIndex,
              this.endIndex,
              this.scopeId,
              ident,
              this.isMutable
            );
          } else {
            return this;
          }
        };
        _VarNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.ident, function (_e, ident) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, ident !== _this.ident
              ? VarNode(
                _this.startIndex,
                _this.endIndex,
                _this.scopeId,
                ident,
                _this.isMutable
              )
              : _this);
          });
        };
        return VarNode;
      }(Node));
      Node.Yield = YieldNode = (function (Node) {
        var _Node_prototype, _YieldNode_prototype;
        function YieldNode(startIndex, endIndex, scopeId, node) {
          var _this;
          _this = this instanceof YieldNode ? this : __create(_YieldNode_prototype);
          if (typeof startIndex !== "number") {
            throw TypeError("Expected startIndex to be a Number, got " + __typeof(startIndex));
          }
          if (typeof endIndex !== "number") {
            throw TypeError("Expected endIndex to be a Number, got " + __typeof(endIndex));
          }
          if (typeof scopeId !== "number") {
            throw TypeError("Expected scopeId to be a Number, got " + __typeof(scopeId));
          }
          if (!(node instanceof Node)) {
            throw TypeError("Expected node to be a Node, got " + __typeof(node));
          }
          _this.startIndex = startIndex;
          _this.endIndex = endIndex;
          _this.scopeId = scopeId;
          _this._reduced = void 0;
          _this._macroExpanded = void 0;
          _this._macroExpandAlled = void 0;
          _this.node = node;
          return _this;
        }
        _Node_prototype = Node.prototype;
        _YieldNode_prototype = YieldNode.prototype = __create(_Node_prototype);
        _YieldNode_prototype.constructor = YieldNode;
        YieldNode.displayName = "YieldNode";
        YieldNode.cappedName = "Yield";
        YieldNode.argNames = ["node"];
        State.addNodeFactory("yield", YieldNode);
        _YieldNode_prototype.type = function () {
          return Type["undefined"];
        };
        _YieldNode_prototype.isStatement = function () {
          return true;
        };
        _YieldNode_prototype._reduce = function (o) {
          var node;
          node = this.node.reduce(o).doWrap(o);
          if (node !== this.node) {
            return YieldNode(this.startIndex, this.endIndex, this.scopeId, node);
          } else {
            return this;
          }
        };
        _YieldNode_prototype.inspect = function (depth) {
          return inspectHelper(depth, "YieldNode", this.node);
        };
        _YieldNode_prototype.walk = function (f) {
          var node;
          node = f(this.node);
          if (node !== this.node) {
            return YieldNode(this.startIndex, this.endIndex, this.scopeId, node);
          } else {
            return this;
          }
        };
        _YieldNode_prototype.walkAsync = function (f, callback) {
          var _this;
          _this = this;
          return f(this.node, function (_e, node) {
            if (_e != null) {
              return callback(_e);
            }
            return callback(null, node !== _this.node ? YieldNode(_this.startIndex, _this.endIndex, _this.scopeId, node) : _this);
          });
        };
        return YieldNode;
      }(Node));
      function withoutRepeats(array) {
        var _arr, _i, _len, item, lastItem, result;
        result = [];
        for (_arr = __toArray(array), _i = 0, _len = _arr.length; _i < _len; ++_i) {
          item = _arr[_i];
          if (item !== lastItem) {
            result.push(item);
          }
          lastItem = item;
        }
        return result;
      }
      function buildExpected(errors) {
        var errs;
        errs = withoutRepeats(errors.slice().sort(function (a, b) {
          return __cmp(a.toLowerCase(), b.toLowerCase());
        }));
        switch (errs.length) {
        case 0: return "End of input";
        case 1: return errs[0];
        case 2: return __strnum(errs[0]) + " or " + __strnum(errs[1]);
        default:
          return __strnum(__slice.call(errs, 0, -1).join(", ")) + ", or " + __strnum(errs[errs.length - 1]);
        }
      }
      function buildErrorMessage(errors, lastToken) {
        return "Expected " + __strnum(buildExpected(errors)) + ", but " + __strnum(lastToken) + " found";
      }
      function parse(text, macros, options, callback) {
        var o, startTime;
        if (typeof text !== "string") {
          throw TypeError("Expected text to be a String, got " + __typeof(text));
        }
        if (macros == null) {
          macros = null;
        } else if (!(macros instanceof MacroHolder)) {
          throw TypeError("Expected macros to be a MacroHolder or null, got " + __typeof(macros));
        }
        if (options == null) {
          options = {};
        } else if (!__isObject(options)) {
          throw TypeError("Expected options to be an Object, got " + __typeof(options));
        }
        if (callback == null) {
          callback = null;
        } else if (typeof callback !== "function") {
          throw TypeError("Expected callback to be a Function or null, got " + __typeof(callback));
        }
        o = State(
          text,
          macros != null ? macros.clone() : void 0,
          options
        );
        startTime = new Date().getTime();
        function next(result) {
          var _ref, endParseTime, err, index, lastToken, line, messages, next;
          endParseTime = new Date().getTime();
          if (typeof options.progress === "function") {
            options.progress("parse", __num(endParseTime) - __num(startTime));
          }
          if (!result || __lt(o.index, o.data.length)) {
            index = (_ref = o.failures).index;
            line = _ref.line;
            messages = _ref.messages;
            if (__lt(index, o.data.length)) {
              lastToken = JSON.stringify(o.data.substring(index, __num(index) + 20));
            } else {
              lastToken = "end-of-input";
            }
            err = ParserError(
              buildErrorMessage(messages, lastToken),
              o.data,
              index,
              line
            );
            if (callback != null) {
              return callback(err);
            } else {
              throw err;
            }
          } else {
            next = function (expanded) {
              var endExpandTime, endReduceTime, reduced, ret;
              endExpandTime = new Date().getTime();
              if (typeof options.progress === "function") {
                options.progress("macroExpand", __num(endExpandTime) - __num(endParseTime));
              }
              reduced = expanded.reduce(o);
              endReduceTime = new Date().getTime();
              if (typeof options.progress === "function") {
                options.progress("reduce", __num(endReduceTime) - __num(endExpandTime));
              }
              ret = {
                result: reduced,
                macros: o.macros,
                parseTime: __num(endParseTime) - __num(startTime),
                macroExpandTime: __num(endExpandTime) - __num(endParseTime),
                reduceTime: __num(endReduceTime) - __num(endExpandTime),
                time: __num(endReduceTime) - __num(startTime)
              };
              if (callback != null) {
                return callback(null, ret);
              } else {
                return ret;
              }
            };
            if (callback != null) {
              return o.macroExpandAllAsync(result, function (_e, expanded) {
                if (_e != null) {
                  return callback(_e);
                }
                return next(expanded);
              });
            } else {
              return next(o.macroExpandAll(result));
            }
          }
        }
        if (callback != null) {
          return Root(o, function (err, root) {
            if (err != null && err !== SHORT_CIRCUIT) {
              return callback(err);
            }
            return next(root);
          });
        } else {
          try {
            return next(Root(o));
          } catch (e) {
            if (e !== SHORT_CIRCUIT) {
              throw e;
            } else {
              return next();
            }
          }
        }
      }
      module.exports = parse;
      module.exports.ParserError = ParserError;
      module.exports.MacroError = MacroError;
      module.exports.Node = Node;
      module.exports.deserializePrelude = function (data) {
        var macros, parsed;
        if (typeof data === "string") {
          parsed = JSON.parse(data);
        } else {
          parsed = data;
        }
        macros = MacroHolder();
        macros.deserialize(parsed);
        return {
          result: NothingNode(0, 0, -1),
          macros: macros
        };
      };
      function unique(array) {
        var _arr, _i, _len, item, result;
        result = [];
        for (_arr = __toArray(array), _i = 0, _len = _arr.length; _i < _len; ++_i) {
          item = _arr[_i];
          if (!__in(item, result)) {
            result.push(item);
          }
        }
        return result;
      }
      module.exports.getReservedWords = function (macros) {
        return unique(__toArray(RESERVED_IDENTS).concat(__toArray(macros != null && typeof macros.getMacroAndOperatorNames === "function" && macros.getMacroAndOperatorNames() || [])));
      };
    }.call(this, typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : this));
    
    return module.exports;
  }.call({}));
  require['./translator'] = (function () {
    var module = { exports: this };
    var exports = this;
    (function () {
      "use strict";
      var __cmp, __create, __isArray, __isObject, __num, __owns, __slice, __str, __strnum, __toArray, __typeof, __xor, ast, AstNode, GeneratorBuilder, generatorTranslate, Helpers, HELPERS, ParserNode, Scope, translators, Type;
      __cmp = function (left, right) {
        var type;
        if (left === right) {
          return 0;
        } else {
          type = typeof left;
          if (type !== "number" && type !== "string") {
            throw TypeError("Cannot compare a non-number/string: " + type);
          } else if (type !== typeof right) {
            throw TypeError("Cannot compare elements of different types: " + type + " vs " + typeof right);
          } else if (left < right) {
            return -1;
          } else {
            return 1;
          }
        }
      };
      __create = typeof Object.create === "function" ? Object.create
        : function (x) {
          function F() {}
          F.prototype = x;
          return new F();
        };
      __isArray = typeof Array.isArray === "function" ? Array.isArray
        : (function () {
          var _toString;
          _toString = Object.prototype.toString;
          return function (x) {
            return _toString.call(x) === "[object Array]";
          };
        }());
      __isObject = function (x) {
        return typeof x === "object" && x !== null;
      };
      __num = function (num) {
        if (typeof num !== "number") {
          throw TypeError("Expected a number, got " + __typeof(num));
        } else {
          return num;
        }
      };
      __owns = Object.prototype.hasOwnProperty;
      __slice = Array.prototype.slice;
      __str = function (str) {
        if (typeof str !== "string") {
          throw TypeError("Expected a string, got " + __typeof(str));
        } else {
          return str;
        }
      };
      __strnum = function (strnum) {
        var type;
        type = typeof strnum;
        if (type === "string") {
          return strnum;
        } else if (type === "number") {
          return String(strnum);
        } else {
          throw TypeError("Expected a string or number, got " + __typeof(strnum));
        }
      };
      __toArray = function (x) {
        if (x == null) {
          throw TypeError("Expected an object, got " + __typeof(x));
        } else if (__isArray(x)) {
          return x;
        } else if (typeof x === "string") {
          return x.split("");
        } else {
          return __slice.call(x);
        }
      };
      __typeof = (function () {
        var _toString;
        _toString = Object.prototype.toString;
        return function (o) {
          if (o === void 0) {
            return "Undefined";
          } else if (o === null) {
            return "Null";
          } else {
            return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);
          }
        };
      }());
      __xor = function (x, y) {
        if (x) {
          if (y) {
            return false;
          } else {
            return x;
          }
        } else {
          return y || x;
        }
      };
      ast = require("./ast");
      AstNode = ast.Node;
      Type = require("./types");
      ParserNode = require("./parser").Node;
      function needsCaching(item) {
        return !(item instanceof ast.Ident) && !(item instanceof ast.Const) && !(item instanceof ast.This) && !(item instanceof ast.Arguments);
      }
      Scope = (function () {
        var _Scope_prototype, getId;
        function Scope(options, bound, usedTmps, helpers, variables, tmps) {
          var _this;
          _this = this instanceof Scope ? this : __create(_Scope_prototype);
          if (options == null) {
            options = {};
          }
          _this.options = options;
          if (bound == null) {
            bound = false;
          }
          _this.bound = bound;
          if (usedTmps == null) {
            usedTmps = {};
          }
          _this.usedTmps = usedTmps;
          if (helpers == null) {
            helpers = {};
          }
          _this.helpers = helpers;
          if (tmps == null) {
            tmps = {};
          }
          _this.tmps = tmps;
          _this.variables = variables ? __create(variables) : {};
          _this.hasBound = false;
          _this.usedThis = false;
          _this.hasStopIteration = false;
          _this.id = getId();
          return _this;
        }
        _Scope_prototype = Scope.prototype;
        Scope.displayName = "Scope";
        getId = (function () {
          var id;
          id = -1;
          return function () {
            return ++id;
          };
        }());
        _Scope_prototype.maybeCache = function (item, type, func) {
          var ident, result;
          if (!(item instanceof ast.Expression)) {
            throw TypeError("Expected item to be an Expression, got " + __typeof(item));
          }
          if (type == null) {
            type = Type.any;
          } else if (!(type instanceof Type)) {
            throw TypeError("Expected type to be a Type, got " + __typeof(type));
          }
          if (typeof func !== "function") {
            throw TypeError("Expected func to be a Function, got " + __typeof(func));
          }
          if (!needsCaching(item)) {
            return func(item, item, false);
          } else {
            ident = this.reserveIdent("ref", type);
            result = func(
              ast.Assign(ident, item),
              ident,
              true
            );
            this.releaseIdent(ident);
            return result;
          }
        };
        _Scope_prototype.reserveIdent = function (namePart, type) {
          var _this;
          _this = this;
          if (namePart == null) {
            namePart = "ref";
          }
          if (type == null) {
            type = Type.any;
          } else if (!(type instanceof Type)) {
            throw TypeError("Expected type to be a Type, got " + __typeof(type));
          }
          return (function () {
            var i, ident, name;
            for (i = 1; ; ++i) {
              if (i === 1) {
                name = "_" + __strnum(namePart);
              } else {
                name = "_" + __strnum(namePart) + i;
              }
              if (!(name in _this.usedTmps)) {
                _this.usedTmps[name] = true;
                ident = ast.Ident(name);
                _this.addVariable(ident, type);
                return ident;
              }
            }
          }());
        };
        _Scope_prototype.reserveParam = function () {
          var _this;
          _this = this;
          return (function () {
            var i, name;
            for (i = 1; ; ++i) {
              if (i === 1) {
                name = "_p";
              } else {
                name = "_p" + i;
              }
              if (!(name in _this.usedTmps)) {
                _this.usedTmps[name] = true;
                return ast.Ident(name);
              }
            }
          }());
        };
        _Scope_prototype.getTmp = function (id, name, type) {
          var tmp, tmps;
          if (type == null) {
            type = Type.any;
          } else if (!(type instanceof Type)) {
            throw TypeError("Expected type to be a Type, got " + __typeof(type));
          }
          tmps = this.tmps;
          if (id in tmps) {
            tmp = tmps[id];
            if (tmp instanceof ast.Ident) {
              return tmp;
            }
          }
          return tmps[id] = this.reserveIdent(name || "tmp", type);
        };
        _Scope_prototype.releaseTmp = function (id) {
          var _ref, _ref2;
          if (__owns.call(this.tmps, id)) {
            this.releaseIdent((_ref = (_ref2 = this.tmps)[id], delete _ref2[id], _ref));
          }
        };
        _Scope_prototype.releaseTmps = function () {
          var _obj, id;
          _obj = this.tmps;
          for (id in _obj) {
            if (__owns.call(_obj, id)) {
              this.releaseTmp(id);
            }
          }
          this.tmps = {};
        };
        _Scope_prototype.releaseIdent = function (ident) {
          if (!(ident instanceof ast.Ident)) {
            throw TypeError("Expected ident to be an Ident, got " + __typeof(ident));
          }
          if (!__owns.call(this.usedTmps, ident.name)) {
            throw Error("Trying to release a non-reserved ident: " + __strnum(ident.name));
          }
          delete this.usedTmps[ident.name];
        };
        _Scope_prototype.markAsParam = function (ident) {
          if (!(ident instanceof ast.Ident)) {
            throw TypeError("Expected ident to be an Ident, got " + __typeof(ident));
          }
          this.removeVariable(ident);
        };
        _Scope_prototype.addHelper = function (name) {
          this.helpers[name] = true;
        };
        _Scope_prototype.fillHelperDependencies = function () {
          var _arr, _else, _i, dep, helper, helpers, toAdd;
          helpers = this.helpers;
          toAdd = {};
          while (true) {
            for (helper in helpers) {
              if (__owns.call(helpers, helper) && HELPERS.has(helper)) {
                for (_arr = __toArray(HELPERS.dependencies(helper)), _i = _arr.length; _i--; ) {
                  dep = _arr[_i];
                  if (!__owns.call(helpers, dep)) {
                    toAdd[dep] = true;
                  }
                }
              }
            }
            _else = true;
            for (helper in toAdd) {
              if (__owns.call(toAdd, helper)) {
                _else = false;
                this.addHelper(helper);
              }
            }
            if (_else) {
              break;
            }
            helpers = toAdd;
            toAdd = {};
          }
        };
        function lowerSorter(a, b) {
          return __cmp(a.toLowerCase(), b.toLowerCase());
        }
        _Scope_prototype.getHelpers = function () {
          var _arr, _obj, helpers, k;
          _arr = [];
          _obj = this.helpers;
          for (k in _obj) {
            if (__owns.call(_obj, k)) {
              _arr.push(k);
            }
          }
          helpers = _arr;
          return helpers.sort(lowerSorter);
        };
        _Scope_prototype.addVariable = function (ident, type, isMutable) {
          if (!(ident instanceof ast.Ident)) {
            throw TypeError("Expected ident to be an Ident, got " + __typeof(ident));
          }
          if (type == null) {
            type = Type.any;
          } else if (!(type instanceof Type)) {
            throw TypeError("Expected type to be a Type, got " + __typeof(type));
          }
          if (isMutable == null) {
            isMutable = false;
          } else if (typeof isMutable !== "boolean") {
            throw TypeError("Expected isMutable to be a Boolean, got " + __typeof(isMutable));
          }
          this.variables[ident.name] = { type: type, isMutable: isMutable };
        };
        _Scope_prototype.hasVariable = function (ident) {
          if (!(ident instanceof ast.Ident)) {
            throw TypeError("Expected ident to be an Ident, got " + __typeof(ident));
          }
          if (typeof this.variables[ident.name] === "object") {
            return ident.name in this.variables;
          } else {
            return false;
          }
        };
        _Scope_prototype.hasOwnVariable = function (ident) {
          if (!(ident instanceof ast.Ident)) {
            throw TypeError("Expected ident to be an Ident, got " + __typeof(ident));
          }
          return __owns.call(this.variables, ident.name);
        };
        _Scope_prototype.isVariableMutable = function (ident) {
          var _ref;
          if (!(ident instanceof ast.Ident)) {
            throw TypeError("Expected ident to be an Ident, got " + __typeof(ident));
          }
          if ((_ref = this.variables[ident.name]) != null) {
            return _ref.isMutable;
          }
        };
        _Scope_prototype.removeVariable = function (ident) {
          if (!(ident instanceof ast.Ident)) {
            throw TypeError("Expected ident to be an Ident, got " + __typeof(ident));
          }
          delete this.variables[ident.name];
        };
        _Scope_prototype.getVariables = function () {
          var _arr, _obj, k, variables;
          _arr = [];
          _obj = this.variables;
          for (k in _obj) {
            if (__owns.call(_obj, k)) {
              _arr.push(k);
            }
          }
          variables = _arr;
          return variables.sort(lowerSorter);
        };
        _Scope_prototype.clone = function (bound) {
          if (bound) {
            this.hasBound = true;
          }
          return Scope(
            this.options,
            bound,
            __create(this.usedTmps),
            this.helpers,
            this.variables,
            __create(this.tmps)
          );
        };
        return Scope;
      }());
      function wrapReturn(x) {
        return x.mutateLast(ast.Return);
      }
      function identity(x) {
        return x;
      }
      function makeAutoReturn(x) {
        if (x) {
          return wrapReturn;
        } else {
          return identity;
        }
      }
      HELPERS = new (Helpers = (function () {
        var _Helpers_prototype;
        function Helpers() {
          var _this;
          _this = this instanceof Helpers ? this : __create(_Helpers_prototype);
          _this.data = {};
          _this.types = {};
          _this.deps = {};
          return _this;
        }
        _Helpers_prototype = Helpers.prototype;
        Helpers.displayName = "Helpers";
        _Helpers_prototype.add = function (name, value, type, dependencies) {
          var _i, _len;
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (!(value instanceof ast.Expression)) {
            throw TypeError("Expected value to be an Expression, got " + __typeof(value));
          }
          if (!(type instanceof Type)) {
            throw TypeError("Expected type to be a Type, got " + __typeof(type));
          }
          if (!__isArray(dependencies)) {
            throw TypeError("Expected dependencies to be an Array, got " + __typeof(dependencies));
          } else {
            for (_i = 0, _len = dependencies.length; _i < _len; ++_i) {
              if (typeof dependencies[_i] !== "string") {
                throw TypeError("Expected dependencies[" + _i + "] to be a String, got " + __typeof(dependencies[_i]));
              }
            }
          }
          this.data[name] = value;
          this.types[name] = type;
          return this.deps[name] = dependencies;
        };
        _Helpers_prototype.has = function (name) {
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          return __owns.call(this.data, name);
        };
        _Helpers_prototype.get = function (name) {
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (__owns.call(this.data, name)) {
            return this.data[name];
          } else {
            throw Error("No such helper: " + name);
          }
        };
        _Helpers_prototype.type = function (name) {
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (__owns.call(this.types, name)) {
            return this.types[name];
          } else {
            throw Error("No such helper: " + name);
          }
        };
        _Helpers_prototype.dependencies = function (name) {
          if (typeof name !== "string") {
            throw TypeError("Expected name to be a String, got " + __typeof(name));
          }
          if (__owns.call(this.deps, name)) {
            return this.deps[name];
          } else {
            throw Error("No such helper: " + name);
          }
        };
        return Helpers;
      }()))();
      GeneratorBuilder = (function () {
        var _GeneratorBuilder_prototype;
        function GeneratorBuilder(scope, states, currentState, stateIdent, pendingFinalliesIdent, finallies, catches, currentCatch) {
          var _this;
          _this = this instanceof GeneratorBuilder ? this : __create(_GeneratorBuilder_prototype);
          if (!(scope instanceof Scope)) {
            throw TypeError("Expected scope to be a Scope, got " + __typeof(scope));
          }
          _this.scope = scope;
          if (currentState == null) {
            currentState = 1;
          }
          _this.currentState = currentState;
          if (finallies == null) {
            finallies = [];
          }
          _this.finallies = finallies;
          if (catches == null) {
            catches = [];
          }
          _this.catches = catches;
          if (currentCatch == null) {
            currentCatch = [];
          }
          _this.currentCatch = currentCatch;
          _this.states = states != null ? states
            : [
              [
                function () {
                  return ast.Throw(ast.Ident("StopIteration"));
                }
              ],
              []
            ];
          _this.stateIdent = stateIdent != null ? stateIdent : scope.reserveIdent("state", Type.number);
          _this.pendingFinalliesIdent = pendingFinalliesIdent != null ? pendingFinalliesIdent : scope.reserveIdent("finallies", Type["undefined"]["function"]().array());
          return _this;
        }
        _GeneratorBuilder_prototype = GeneratorBuilder.prototype;
        GeneratorBuilder.displayName = "GeneratorBuilder";
        _GeneratorBuilder_prototype.add = function (tNode) {
          if (!(tNode instanceof GeneratorBuilder)) {
            if (typeof tNode !== "function") {
              throw TypeError("Expected node to be a GeneratorBuilder or Function, got " + __typeof(tNode));
            }
            this.states[this.currentState].push(tNode);
            return this;
          } else {
            return tNode;
          }
        };
        _GeneratorBuilder_prototype["yield"] = function (tNode) {
          var _this, branch;
          _this = this;
          branch = this.branch();
          this.states[this.currentState].push(
            function () {
              return ast.Assign(_this.stateIdent, branch.state);
            },
            function () {
              return ast.Return(tNode());
            }
          );
          return branch.builder;
        };
        _GeneratorBuilder_prototype.goto = function (tState) {
          var _this;
          _this = this;
          this.states[this.currentState].push(
            function () {
              return ast.Assign(_this.stateIdent, tState());
            },
            function () {
              return ast.Break();
            }
          );
        };
        _GeneratorBuilder_prototype.pendingFinally = function (tFinallyBody) {
          var _this, ident;
          _this = this;
          ident = this.scope.reserveIdent("finally", Type["undefined"]["function"]());
          this.scope.removeVariable(ident);
          this.finallies.push(function () {
            return ast.Func(ident, [], [], tFinallyBody());
          });
          this.states[this.currentState].push(function () {
            return ast.Call(
              ast.Access(_this.pendingFinalliesIdent, "push"),
              [ident]
            );
          });
          return this;
        };
        _GeneratorBuilder_prototype.runPendingFinally = function () {
          var _this;
          _this = this;
          this.states[this.currentState].push(function () {
            return ast.Call(
              ast.Access(
                ast.Call(ast.Access(_this.pendingFinalliesIdent, "pop")),
                "call"
              ),
              [ast.This()]
            );
          });
          return this;
        };
        _GeneratorBuilder_prototype.noop = function () {
          var _this, branch;
          _this = this;
          if (this.states[this.currentState].length) {
            branch = this.branch();
            this.states[this.currentState].push(function () {
              return ast.Assign(_this.stateIdent, branch.state);
            });
            return branch.builder;
          } else {
            return this;
          }
        };
        _GeneratorBuilder_prototype.enterTryCatch = function () {
          var fresh;
          fresh = this.noop();
          fresh.currentCatch = __toArray(fresh.currentCatch).concat([[fresh.currentState]]);
          return fresh;
        };
        _GeneratorBuilder_prototype.exitTryCatch = function (tIdent, tPostState) {
          var catchStates, fresh;
          if (this.currentCatch.length === 0) {
            throw Error("Unable to exit-try-catch without first using enter-try-catch");
          }
          this.goto(tPostState);
          fresh = this.noop();
          catchStates = fresh.currentCatch.pop();
          catchStates.splice(catchStates.indexOf(fresh.currentState), 1);
          fresh.catches.push({ tryStates: catchStates, tIdent: tIdent, catchState: fresh.currentState });
          return fresh;
        };
        _GeneratorBuilder_prototype.branch = function () {
          var _ref, state;
          state = this.states.length;
          if (this.currentCatch.length) {
            (_ref = this.currentCatch)[__num(_ref.length) - 1].push(state);
          }
          this.states.push([]);
          return {
            state: state,
            builder: GeneratorBuilder(
              this.scope,
              this.states,
              state,
              this.stateIdent,
              this.pendingFinalliesIdent,
              this.finallies,
              this.catches,
              this.currentCatch
            )
          };
        };
        _GeneratorBuilder_prototype.create = function () {
          var _this, body, catches, close, err, f, innerScope, scope, stateIdent;
          _this = this;
          if (this.currentCatch.length) {
            throw Error("Cannot create a generator if there are stray catches");
          }
          this.states[this.currentState].push(function () {
            return ast.Assign(_this.stateIdent, 0);
          });
          body = [ast.Assign(this.stateIdent, 1)];
          close = this.scope.reserveIdent("close", Type["undefined"]["function"]());
          this.scope.removeVariable(close);
          if (this.finallies.length === 0) {
            this.scope.removeVariable(this.pendingFinalliesIdent);
            body.push(ast.Func(close, [], [], ast.Block([ast.Assign(this.stateIdent, 0)])));
          } else {
            body.push(ast.Assign(this.pendingFinalliesIdent, ast.Arr()));
            body.push.apply(body, (function () {
              var _arr, _arr2, _i, _len, f;
              for (_arr = [], _arr2 = __toArray(_this.finallies), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                f = _arr2[_i];
                _arr.push(f());
              }
              return _arr;
            }()));
            innerScope = this.scope.clone(false);
            f = innerScope.reserveIdent("f", Type["undefined"]["function"]().union(Type["undefined"]));
            body.push(ast.Func(close, [], innerScope.getVariables(), ast.Block([
              ast.Assign(this.stateIdent, 0),
              ast.Assign(f, ast.Call(ast.Access(this.pendingFinalliesIdent, "pop"))),
              ast.If(f, ast.TryFinally(ast.Call(f), ast.Call(close)))
            ])));
          }
          scope = this.scope;
          err = scope.reserveIdent("e", Type.any);
          catches = this.catches;
          stateIdent = this.stateIdent;
          body.push(ast.Return(ast.Obj([
            ast.Obj.Pair("close", close),
            ast.Obj.Pair("iterator", ast.Func(null, [], [], ast.Return(ast.This()))),
            ast.Obj.Pair("next", ast.Func(null, [], [], ast.While(true, ast.TryCatch(
              ast.Switch(
                stateIdent,
                (function () {
                  var _arr, _arr2, _f, _len, i;
                  for (_arr = [], _arr2 = __toArray(_this.states), i = 0, _len = _arr2.length, _f = function (state, i) {
                    return ast.Switch.Case(i, ast.Block((function () {
                      var _arr, _arr2, _i, _len, item;
                      for (_arr = [], _arr2 = __toArray(state), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                        item = _arr2[_i];
                        _arr.push(item());
                      }
                      return _arr;
                    }()).concat([ast.Break()])));
                  }; i < _len; ++i) {
                    _arr.push(_f.call(_this, _arr2[i], i));
                  }
                  return _arr;
                }()),
                ast.Throw(ast.Call(ast.Ident("Error"), [ast.Binary("Unknown state: ", "+", stateIdent)]))
              ),
              err,
              (function () {
                var _arr, _f, _i, current;
                current = ast.Block([ast.Call(close), ast.Throw(err)]);
                for (_arr = __toArray(catches), _i = _arr.length, _f = function (catchInfo) {
                  var errIdent;
                  errIdent = catchInfo.tIdent();
                  scope.addVariable(errIdent);
                  return current = ast.If(
                    ast.Or.apply(ast, (function () {
                      var _arr, _arr2, _i, _len, state;
                      for (_arr = [], _arr2 = __toArray(catchInfo.tryStates), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                        state = _arr2[_i];
                        _arr.push(ast.Binary(stateIdent, "===", state));
                      }
                      return _arr;
                    }())),
                    ast.Block([
                      ast.Assign(errIdent, err),
                      ast.Assign(stateIdent, catchInfo.catchState)
                    ]),
                    current
                  );
                }; _i--; ) {
                  _f.call(_this, _arr[_i]);
                }
                return current;
              }())
            ))))
          ])));
          return ast.Block(body);
        };
        return GeneratorBuilder;
      }());
      function flattenSpreadArray(elements) {
        var _arr, _i, _len, changed, element, result;
        result = [];
        changed = false;
        for (_arr = __toArray(elements), _i = 0, _len = _arr.length; _i < _len; ++_i) {
          element = _arr[_i];
          if (element instanceof ParserNode.Spread && element.node instanceof ParserNode.Array) {
            result.push.apply(result, __toArray(element.node.elements));
            changed = true;
          } else {
            result.push(element);
          }
        }
        if (changed) {
          return flattenSpreadArray(result);
        } else {
          return elements;
        }
      }
      generatorTranslate = (function () {
        var generatorTranslators;
        generatorTranslators = {
          Block: function (node, scope, builder, breakState, continueState) {
            var _arr, _i, _len, b, subnode;
            if (node.label != null) {
              throw Error("Not implemented: block with label in generator");
            }
            b = builder;
            for (_arr = __toArray(node.nodes), _i = 0, _len = _arr.length; _i < _len; ++_i) {
              subnode = _arr[_i];
              b = generatorTranslate(
                subnode,
                scope,
                b,
                breakState,
                continueState
              );
            }
            return b;
          },
          Break: function (node, scope, builder, breakState) {
            if (node.label != null) {
              throw Error("Not implemented: break with label in a generator");
            }
            if (breakState == null) {
              throw Error("break found outside of a loop");
            }
            builder.goto(breakState);
            return builder;
          },
          Continue: function (node, scope, builder, breakState, continueState) {
            if (node.label != null) {
              throw Error("Not implemented: continue with label in a generator");
            }
            if (breakState == null) {
              throw Error("break found outside of a loop");
            }
            builder.goto(continueState);
            return builder;
          },
          For: function (node, scope, builder) {
            var bodyBranch, postBranch, stepBranch, testBranch, tTest;
            if (node.label != null) {
              throw Error("Not implemented: for with label in generator");
            }
            if (node.init != null) {
              builder = generatorTranslate(node.init, scope, builder);
            }
            stepBranch = builder.branch();
            stepBranch.builder = generatorTranslate(node.step, scope, stepBranch.builder);
            testBranch = builder.branch();
            tTest = translate(node.test, scope, "expression", false);
            bodyBranch = builder.branch();
            bodyBranch.builder = generatorTranslate(
              node.body,
              scope,
              bodyBranch.builder,
              function () {
                return postBranch.state;
              },
              function () {
                return stepBranch.state;
              }
            );
            postBranch = builder.branch();
            builder.goto(function () {
              return testBranch.state;
            });
            stepBranch.builder.goto(function () {
              return testBranch.state;
            });
            testBranch.builder.goto(function () {
              return ast.IfExpression(tTest(), bodyBranch.state, postBranch.state);
            });
            bodyBranch.builder.goto(function () {
              return stepBranch.state;
            });
            return postBranch.builder;
          },
          ForIn: function (node, scope, builder) {
            var bodyBranch, index, key, keys, length, postBranch, stepBranch, testBranch, tKey, tObject;
            if (node.label != null) {
              throw Error("Not implemented: for-in with label in generator");
            }
            tKey = translate(node.key, scope, "leftExpression");
            tObject = translate(node.object, scope, "expression");
            keys = scope.reserveIdent("keys", Type.string.array());
            function getKey() {
              if (key != null) {
                return key;
              } else {
                key = tKey();
                if (!(key instanceof ast.Ident)) {
                  throw Error("Expected an Ident for a for-in key");
                }
                scope.addVariable(key, Type.string);
                return key;
              }
            }
            index = scope.reserveIdent("i", Type.number);
            length = scope.reserveIdent("len", Type.number);
            builder.add(function () {
              return ast.Block([
                ast.Assign(keys, ast.Arr()),
                ast.ForIn(getKey(), tObject(), ast.Call(
                  ast.Access(keys, "push"),
                  [getKey()]
                )),
                ast.Assign(index, 0),
                ast.Assign(length, ast.Access(keys, "length"))
              ]);
            });
            stepBranch = builder.branch();
            stepBranch.builder.add(function () {
              return ast.Unary("++", index);
            });
            testBranch = builder.branch();
            bodyBranch = builder.branch();
            bodyBranch.builder.add(function () {
              return ast.Assign(getKey(), ast.Access(keys, index));
            });
            bodyBranch.builder = generatorTranslate(
              node.body,
              scope,
              bodyBranch.builder,
              function () {
                return postBranch.state;
              },
              function () {
                return stepBranch.state;
              }
            );
            postBranch = builder.branch();
            builder.goto(function () {
              return testBranch.state;
            });
            stepBranch.builder.goto(function () {
              return testBranch.state;
            });
            testBranch.builder.goto(function () {
              return ast.IfExpression(
                ast.Binary(index, "<", length),
                bodyBranch.state,
                postBranch.state
              );
            });
            bodyBranch.builder.goto(function () {
              return stepBranch.state;
            });
            return postBranch.builder;
          },
          If: function (node, scope, builder, breakState, continueState) {
            var gWhenFalse, gWhenTrue, postBranch, tTest, whenFalse, whenFalseBranch, whenTrueBranch;
            if (node.label != null) {
              throw Error("Not implemented: if with label in generator");
            }
            tTest = translate(node.test, scope, "expression");
            whenTrueBranch = builder.branch();
            gWhenTrue = generatorTranslate(
              node.whenTrue,
              scope,
              whenTrueBranch.builder,
              breakState,
              continueState
            );
            whenFalse = node.whenFalse;
            if (whenFalse instanceof ParserNode.Nothing) {
              whenFalse = null;
            }
            if (whenFalse != null) {
              whenFalseBranch = builder.branch();
            }
            if (whenFalse != null) {
              gWhenFalse = generatorTranslate(
                node.whenFalse,
                scope,
                whenFalseBranch.builder,
                breakState,
                continueState
              );
            }
            postBranch = builder.branch();
            builder.goto(function () {
              return ast.IfExpression(tTest(), whenTrueBranch.state, whenFalseBranch != null ? whenFalseBranch.state : postBranch.state);
            });
            gWhenTrue.goto(function () {
              return postBranch.state;
            });
            if (whenFalse != null) {
              gWhenFalse.goto(function () {
                return postBranch.state;
              });
            }
            return postBranch.builder;
          },
          TmpWrapper: function (node, scope, builder, breakState, continueState) {
            var _arr, _i, tmp;
            builder = generatorTranslate(
              node.node,
              scope,
              builder,
              breakState,
              continueState
            );
            for (_arr = __toArray(node.tmps), _i = _arr.length; _i--; ) {
              tmp = _arr[_i];
              scope.releaseTmp(tmp);
            }
            return builder;
          },
          TryCatch: function (node, scope, builder, breakState, continueState) {
            var postBranch;
            if (node.label != null) {
              throw Error("Not implemented: try-catch with label in generator");
            }
            builder = builder.enterTryCatch();
            builder = generatorTranslate(
              node.tryBody,
              scope,
              builder,
              breakState,
              continueState
            );
            builder = builder.exitTryCatch(
              translate(node.catchIdent, scope, "leftExpression", false),
              function () {
                return postBranch.state;
              }
            );
            builder = generatorTranslate(
              node.catchBody,
              scope,
              builder,
              breakState,
              continueState
            );
            postBranch = builder.branch();
            builder.goto(function () {
              return postBranch.state;
            });
            return postBranch.builder;
          },
          TryFinally: function (node, scope, builder, breakState, continueState) {
            if (node.label != null) {
              throw Error("Not implemented: try-finally with label in generator");
            }
            builder = builder.pendingFinally(translate(node.finallyBody, scope, "topStatement"));
            builder = generatorTranslate(
              node.tryBody,
              scope,
              builder,
              breakState,
              continueState
            );
            return builder.runPendingFinally();
          },
          Yield: function (node, scope, builder) {
            return builder["yield"](translate(node.node, scope, "expression"));
          }
        };
        return function (node, scope, builder, breakState, continueState) {
          var ret;
          if (__owns.call(generatorTranslators, node.constructor.cappedName)) {
            ret = generatorTranslators[node.constructor.cappedName](
              node,
              scope,
              builder,
              breakState,
              continueState
            );
            if (!(ret instanceof GeneratorBuilder)) {
              throw Error("Translated non-GeneratorBuilder: " + __typeof(ret));
            }
            return ret;
          } else {
            return builder.add(translate(node, scope, "statement", false));
          }
        };
      }());
      function arrayTranslate(elements, scope, replaceWithSlice, allowArrayLike, unassigned) {
        var _arr, _f, _i, _len, current, element, i, translatedItems;
        translatedItems = [];
        current = [];
        translatedItems.push(current);
        for (_arr = __toArray(flattenSpreadArray(elements)), _i = 0, _len = _arr.length; _i < _len; ++_i) {
          element = _arr[_i];
          if (element instanceof ParserNode.Spread) {
            translatedItems.push({
              tNode: translate(
                element.node,
                scope,
                "expression",
                null,
                unassigned
              ),
              type: element.node.type()
            });
            current = [];
            translatedItems.push(current);
          } else {
            current.push(translate(
              element,
              scope,
              "expression",
              null,
              unassigned
            ));
          }
        }
        if (translatedItems.length === 1) {
          return function () {
            return ast.Arr((function () {
              var _arr, _arr2, _i, _len, item;
              for (_arr = [], _arr2 = __toArray(translatedItems[0]), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                item = _arr2[_i];
                _arr.push(item());
              }
              return _arr;
            }()));
          };
        } else {
          for (i = translatedItems.length, _f = function (translatedItem, i) {
            if (i % 2 === 0) {
              if (__num(translatedItem.length) > 0) {
                return translatedItems[i] = function () {
                  return ast.Arr((function () {
                    var _arr, _arr2, _i, _len, item;
                    for (_arr = [], _arr2 = __toArray(translatedItem), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                      item = _arr2[_i];
                      _arr.push(item());
                    }
                    return _arr;
                  }()));
                };
              } else {
                return translatedItems.splice(i, 1);
              }
            } else {
              return translatedItems[i] = function () {
                var node;
                node = translatedItem.tNode();
                if (translatedItem.type.isSubsetOf(Type.array)) {
                  return node;
                } else {
                  scope.addHelper("__toArray");
                  return ast.Call(ast.Ident("__toArray"), [node]);
                }
              };
            }
          }; i--; ) {
            _f.call(this, translatedItems[i], i);
          }
          if (translatedItems.length === 1) {
            return function () {
              var array;
              array = translatedItems[0]();
              if (replaceWithSlice && array instanceof ast.Call && array.func instanceof ast.Ident && array.func.name === "__toArray") {
                return ast.Call(
                  ast.Access(ast.Ident("__slice"), "call"),
                  array.args
                );
              } else if (allowArrayLike && array instanceof ast.Call && array.func instanceof ast.Ident && array.func.name === "__toArray" && array.args[0] instanceof ast.Arguments) {
                return array.args[0];
              } else {
                return array;
              }
            };
          } else {
            return function () {
              var _arr, _i, _len, head, item, rest;
              head = translatedItems[0]();
              for (_arr = [], _i = 1, _len = translatedItems.length; _i < _len; ++_i) {
                item = translatedItems[_i];
                _arr.push(item());
              }
              rest = _arr;
              return ast.Call(
                ast.Access(head, "concat"),
                rest
              );
            };
          }
        }
      }
      translators = {
        Access: function (node, scope, location, autoReturn, unassigned) {
          var tChild, tParent;
          tParent = translate(
            node.parent,
            scope,
            "expression",
            null,
            unassigned
          );
          tChild = translate(
            node.child,
            scope,
            "expression",
            null,
            unassigned
          );
          return function () {
            return autoReturn(ast.Access(tParent(), tChild()));
          };
        },
        Args: function (node, scope, location, autoReturn) {
          return function () {
            return autoReturn(ast.Arguments());
          };
        },
        Array: function (node, scope, location, autoReturn, unassigned) {
          var tArr;
          tArr = arrayTranslate(
            node.elements,
            scope,
            true,
            false,
            unassigned
          );
          return function () {
            return autoReturn(tArr());
          };
        },
        Assign: (function () {
          var ops;
          ops = {
            "=": "=",
            "*=": "*=",
            "/=": "/=",
            "%=": "%=",
            "+=": "+=",
            "-=": "-=",
            "<<=": "<<=",
            ">>=": ">>=",
            ">>>=": ">>>=",
            "&=": "&=",
            "|=": "|=",
            "^=": "^="
          };
          return function (node, scope, location, autoReturn, unassigned) {
            var op, tLeft, tRight;
            op = node.op;
            tLeft = translate(node.left, scope, "leftExpression");
            tRight = translate(
              node.right,
              scope,
              "expression",
              null,
              unassigned
            );
            if (unassigned && node.left instanceof ParserNode.Ident) {
              if (op === "=" && unassigned[node.left.name] && node.right.isConst() && node.right.constValue() === void 0) {
                return function () {
                  return ast.Noop();
                };
              }
              unassigned[node.left.name] = false;
            }
            return function () {
              var func, left, right;
              left = tLeft();
              right = tRight();
              if (op === "=" && location === "topStatement" && left instanceof ast.Ident && right instanceof ast.Func && right.name == null && scope.hasOwnVariable(left) && !scope.isVariableMutable(left)) {
                scope.removeVariable(left);
                func = ast.Func(
                  left,
                  right.params,
                  right.variables,
                  right.body,
                  right.declarations
                );
                if (autoReturn !== identity) {
                  return ast.Block([func, autoReturn(left)]);
                } else {
                  return func;
                }
              } else {
                return autoReturn(ast.Binary(left, op, right));
              }
            };
          };
        }()),
        Binary: function (node, scope, location, autoReturn, unassigned) {
          var tLeft, tRight;
          tLeft = translate(
            node.left,
            scope,
            "expression",
            null,
            unassigned
          );
          tRight = translate(
            node.right,
            scope,
            "expression",
            null,
            unassigned
          );
          return function () {
            return autoReturn(ast.Binary(tLeft(), node.op, tRight()));
          };
        },
        Block: function (node, scope, location, autoReturn, unassigned) {
          var tLabel, tNodes;
          tLabel = node.label && translate(node.label, scope, "label");
          tNodes = translateArray(
            node.nodes,
            scope,
            location,
            autoReturn,
            unassigned
          );
          return function () {
            return ast.Block(
              (function () {
                var _arr, _arr2, _i, _len, tNode;
                for (_arr = [], _arr2 = __toArray(tNodes), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
                  tNode = _arr2[_i];
                  _arr.push(tNode());
                }
                return _arr;
              }()),
              typeof tLabel === "function" ? tLabel() : void 0
            );
          };
        },
        Break: function (node, scope) {
          var tLabel;
          tLabel = node.label && translate(node.label, scope, "label");
          return function () {
            return ast.Break(typeof tLabel === "function" ? tLabel() : void 0);
          };
        },
        Call: function (node, scope, location, autoReturn, unassigned) {
          var args, isApply, isNew, tArgArray, tFunc, tStart;
          tFunc = translate(
            node.func,
            scope,
            "expression",
            null,
            unassigned
          );
          isApply = node.isApply;
          isNew = node.isNew;
          args = node.args;
          if (isApply && (args.length === 0 || !(args[0] instanceof ParserNode.Spread))) {
            if (args.length === 0) {
              tStart = function () {
                return ast.Const(void 0);
              };
            } else {
              tStart = translate(
                args[0],
                scope,
                "expression",
                null,
                unassigned
              );
            }
            tArgArray = arrayTranslate(
              __slice.call(args, 1),
              scope,
              false,
              true,
              unassigned
            );
            return function () {
              var argArray, func, start;
              func = tFunc();
              start = tStart();
              argArray = tArgArray();
              if (argArray instanceof ast.Arr) {
                return autoReturn(ast.Call(
                  ast.Access(func, "call"),
                  [start].concat(__toArray(argArray.elements))
                ));
              } else {
                return autoReturn(ast.Call(
                  ast.Access(func, "apply"),
                  [start, argArray]
                ));
              }
            };
          } else {
            tArgArray = arrayTranslate(
              args,
              scope,
              false,
              true,
              unassigned
            );
            return function () {
              var argArray, func;
              func = tFunc();
              argArray = tArgArray();
              if (isApply) {
                return scope.maybeCache(argArray, Type.array, function (setArray, array) {
                  scope.addHelper("__slice");
                  return autoReturn(ast.Call(
                    ast.Access(func, "apply"),
                    [
                      ast.Access(setArray, 0),
                      ast.Call(
                        ast.Access(ast.Ident("__slice"), "call"),
                        [array, ast.Const(1)]
                      )
                    ]
                  ));
                });
              } else if (argArray instanceof ast.Arr) {
                return autoReturn(ast.Call(func, argArray.elements, isNew));
              } else if (isNew) {
                scope.addHelper("__new");
                return autoReturn(ast.Call(ast.Ident("__new"), [func, argArray]));
              } else if (func instanceof ast.Binary && func.op === ".") {
                return scope.maybeCache(func.left, Type["function"], function (setParent, parent) {
                  return autoReturn(ast.Call(
                    ast.Access(
                      ast.Access(setParent, func.right),
                      "apply"
                    ),
                    [parent, argArray]
                  ));
                });
              } else {
                return autoReturn(ast.Call(
                  ast.Access(func, "apply"),
                  [ast.Const(void 0), argArray]
                ));
              }
            };
          }
        },
        Comment: function (node, scope, location, autoReturn) {
          return function () {
            return ast.Comment(node.text);
          };
        },
        Const: function (node, scope, location, autoReturn) {
          return function () {
            return autoReturn(ast.Const(node.value));
          };
        },
        Continue: function (node, scope) {
          var tLabel;
          tLabel = node.label && translate(node.label, scope, "label");
          return function () {
            return ast.Continue(typeof tLabel === "function" ? tLabel() : void 0);
          };
        },
        Debugger: function (node, scope, location, autoReturn) {
          if (location === "expression") {
            return function () {
              return ast.Call(
                ast.Func(null, [], [], ast.Debugger()),
                []
              );
            };
          } else {
            return function () {
              return ast.Debugger();
            };
          }
        },
        Def: function (node, scope, location, autoReturn) {
          throw Error("Cannot have a stray def");
        },
        Eval: function (node, scope, location, autoReturn, unassigned) {
          var tCode;
          tCode = translate(
            node.code,
            scope,
            "expression",
            null,
            unassigned
          );
          return function () {
            return autoReturn(ast.Eval(tCode()));
          };
        },
        For: function (node, scope, location, autoReturn, unassigned) {
          var tBody, tInit, tLabel, tStep, tTest;
          tLabel = node.label && translate(node.label, scope, "label");
          if (node.init != null) {
            tInit = translate(
              node.init,
              scope,
              "expression",
              null,
              unassigned
            );
          }
          if (node.test != null) {
            tTest = translate(node.test, scope, "expression");
          }
          if (node.step != null) {
            tStep = translate(node.step, scope, "expression");
          }
          tBody = translate(node.body, scope, "statement");
          return function () {
            return ast.For(
              typeof tInit === "function" ? tInit() : void 0,
              typeof tTest === "function" ? tTest() : void 0,
              typeof tStep === "function" ? tStep() : void 0,
              tBody(),
              typeof tLabel === "function" ? tLabel() : void 0
            );
          };
        },
        ForIn: function (node, scope, location, autoReturn, unassigned) {
          var tBody, tKey, tLabel, tObject;
          tLabel = node.label && translate(node.label, scope, "label");
          tKey = translate(node.key, scope, "leftExpression");
          tObject = translate(
            node.object,
            scope,
            "expression",
            null,
            unassigned
          );
          tBody = translate(node.body, scope, "statement");
          return function () {
            var key;
            key = tKey();
            if (!(key instanceof ast.Ident)) {
              throw Error("Expected an Ident for a for-in key");
            }
            scope.addVariable(key, Type.string);
            return ast.ForIn(key, tObject(), tBody(), typeof tLabel === "function" ? tLabel() : void 0);
          };
        },
        Function: (function () {
          var primitiveTypes, translateParamTypes, translateType, translateTypeChecks;
          primitiveTypes = { Boolean: "boolean", String: "string", Number: "number", Function: "function" };
          function makeTypeCheckTest(ident, type, scope) {
            if (__owns.call(primitiveTypes, type)) {
              return ast.Binary(
                ast.Unary("typeof", ident),
                "!==",
                primitiveTypes[type]
              );
            } else if (type === "Array") {
              scope.addHelper("__isArray");
              return ast.Unary("!", ast.Call(ast.Ident("__isArray"), [ident]));
            } else if (type === "Object") {
              scope.addHelper("__isObject");
              return ast.Unary("!", ast.Call(ast.Ident("__isObject"), [ident]));
            } else {
              return ast.Unary("!", ast.Binary(ident, "instanceof", ast.Ident(type)));
            }
          }
          function article(word) {
            if (/^[aeiou]/i.test(word)) {
              return "an";
            } else {
              return "a";
            }
          }
          function withArticle(word) {
            return article(word) + " " + __strnum(word);
          }
          function buildAccessStringNode(accesses) {
            if (accesses.length === 0) {
              return [];
            } else if (accesses[0] instanceof ast.Const) {
              return [typeof accesses[0].value === "string" && ast.isAcceptableIdent(accesses[0].value) ? ast.Const("." + __strnum(accesses[0].value)) : ast.Const("[" + __str(JSON.stringify(accesses[0].value)) + "]")].concat(__toArray(buildAccessStringNode(__slice.call(accesses, 1))));
            } else {
              return ["[", accesses[0], "]"].concat(__toArray(buildAccessStringNode(__slice.call(accesses, 1))));
            }
          }
          translateTypeChecks = {
            Ident: function (ident, node, scope, hasDefaultValue, accesses) {
              var access, result;
              access = ast.Access.apply(ast, [ident].concat(__toArray(accesses)));
              scope.addHelper("__typeof");
              result = ast.If(
                makeTypeCheckTest(access, node.name, scope),
                ast.Throw(ast.Call(ast.Ident("TypeError"), [
                  ast.BinaryChain.apply(ast, ["+", "Expected " + __strnum(ident.name)].concat(__toArray(buildAccessStringNode(accesses)), [
                    " to be " + withArticle(node.name) + ", got ",
                    ast.Call(ast.Ident("__typeof"), [access])
                  ]))
                ]))
              );
              if (!hasDefaultValue && node.name === "Boolean") {
                return {
                  check: ast.If(
                    ast.Binary(ident, "==", ast.Const(null)),
                    ast.Assign(ident, ast.Const(false)),
                    result
                  ),
                  type: Type.boolean
                };
              } else {
                return {
                  check: result,
                  type: __owns.call(primitiveTypes, node.name) ? Type[primitiveTypes[node.name]] : Type.any
                };
              }
            },
            Access: function (ident, node, scope, hasDefaultValue, accesses) {
              var access, type;
              access = ast.Access.apply(ast, [ident].concat(__toArray(accesses)));
              scope.addHelper("__typeof");
              type = translate(node, scope, "expression")();
              return {
                check: ast.If(
                  ast.Unary("!", ast.Binary(access, "instanceof", type)),
                  ast.Throw(ast.Call(ast.Ident("TypeError"), [
                    ast.BinaryChain.apply(ast, ["+", "Expected " + __strnum(ident.name)].concat(__toArray(buildAccessStringNode(accesses)), [
                      " to be " + withArticle(type.right.value) + ", got ",
                      ast.Call(ast.Ident("__typeof"), [access])
                    ]))
                  ]))
                ),
                type: Type.any
              };
            },
            TypeUnion: function (ident, node, scope, hasDefaultValue, accesses) {
              var _arr, _i, _len, access, check, hasBoolean, hasNull, hasVoid, names, result, tests, type, types;
              access = ast.Access.apply(ast, [ident].concat(__toArray(accesses)));
              scope.addHelper("__typeof");
              hasBoolean = false;
              hasVoid = false;
              hasNull = false;
              names = [];
              tests = [];
              types = [];
              for (_arr = __toArray(node.types), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                type = _arr[_i];
                if (type instanceof ParserNode.Const) {
                  if (type.value === null) {
                    hasNull = true;
                    names.push("null");
                    types.push(Type["null"]);
                  } else if (type.value === void 0) {
                    hasVoid = true;
                    names.push("undefined");
                    types.push(Type["undefined"]);
                  } else {
                    throw Error("Unknown const value for typechecking: " + String(type.value));
                  }
                } else if (type instanceof ParserNode.Ident) {
                  if (type.name === "Boolean") {
                    hasBoolean = true;
                  }
                  names.push(type.name);
                  tests.push(makeTypeCheckTest(access, type.name, scope));
                  types.push(__owns.call(primitiveTypes, type.name) ? Type[primitiveTypes[type.name]] : Type.any);
                } else {
                  throw Error("Not implemented: typechecking for non-idents/consts within a type-union");
                }
              }
              if (hasNull && hasVoid && !hasDefaultValue) {
                tests.unshift(ast.Binary(access, "!=", null));
              }
              result = ast.If(
                ast.And.apply(ast, __toArray(tests)),
                ast.Throw(ast.Call(ast.Ident("TypeError"), [
                  ast.BinaryChain.apply(ast, ["+", "Expected " + __strnum(ident.name)].concat(__toArray(buildAccessStringNode(accesses)), [
                    " to be " + withArticle(names.join(" or ")) + ", got ",
                    ast.Call(ast.Ident("__typeof"), [access])
                  ]))
                ]))
              );
              if (!hasDefaultValue) {
                if (hasNull || hasVoid) {
                  if (__xor(hasNull, hasVoid)) {
                    result = ast.If(
                      ast.Binary(access, "==", ast.Const(null)),
                      ast.Assign(access, ast.Const(hasNull ? null : void 0)),
                      result
                    );
                  }
                } else if (hasBoolean) {
                  result = ast.If(
                    ast.Binary(access, "==", ast.Const(null)),
                    ast.Assign(access, ast.Const(false)),
                    result
                  );
                }
              }
              return {
                check: result,
                type: (function () {
                  var _i, current, type;
                  current = Type.none;
                  for (_i = types.length; _i--; ) {
                    type = types[_i];
                    current = current.union(type);
                  }
                  return current;
                }())
              };
            },
            TypeFunction: function (ident, node, scope, hasDefaultValue, accesses) {
              return translateTypeChecks.Ident(
                ident,
                { name: "Function" },
                scope,
                hasDefaultValue,
                accesses
              );
            },
            TypeArray: function (ident, node, scope, hasDefaultValue, accesses) {
              var access, index, length, result, subCheck;
              access = ast.Access.apply(ast, [ident].concat(__toArray(accesses)));
              scope.addHelper("__isArray");
              index = scope.reserveIdent("i", Type.number);
              length = scope.reserveIdent("len", Type.number);
              subCheck = translateTypeCheck(
                ident,
                node.subtype,
                scope,
                false,
                __toArray(accesses).concat([index])
              );
              result = ast.If(
                ast.Unary("!", ast.Call(ast.Ident("__isArray"), [access])),
                ast.Throw(ast.Call(ast.Ident("TypeError"), [
                  ast.BinaryChain.apply(ast, ["+", "Expected " + __strnum(ident.name)].concat(__toArray(buildAccessStringNode(accesses)), [
                    " to be an Array, got ",
                    ast.Call(ast.Ident("__typeof"), [access])
                  ]))
                ])),
                ast.For(
                  ast.Block([
                    ast.Assign(index, ast.Const(0)),
                    ast.Assign(length, ast.Access(access, "length"))
                  ]),
                  ast.Binary(index, "<", length),
                  ast.Unary("++", index),
                  subCheck.check
                )
              );
              scope.releaseIdent(index);
              scope.releaseIdent(length);
              return { check: result, type: subCheck.type.array() };
            },
            TypeObject: function (ident, node, scope, hasDefaultValue, accesses) {
              var access, result, typeData;
              access = ast.Access.apply(ast, [ident].concat(__toArray(accesses)));
              scope.addHelper("__isObject");
              typeData = {};
              result = ast.If(
                ast.Unary("!", ast.Call(ast.Ident("__isObject"), [access])),
                ast.Throw(ast.Call(ast.Ident("TypeError"), [
                  ast.BinaryChain.apply(ast, ["+", "Expected " + __strnum(ident.name)].concat(__toArray(buildAccessStringNode(accesses)), [
                    " to be an Object, got ",
                    ast.Call(ast.Ident("__typeof"), [access])
                  ]))
                ])),
                (function () {
                  var _arr, _i, _len, _ref, check, current, key, type, value;
                  current = ast.Noop();
                  for (_arr = __toArray(node.pairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                    key = (_ref = _arr[_i]).key;
                    value = _ref.value;
                    if (key instanceof ParserNode.Const) {
                      check = (_ref = translateTypeCheck(
                        ident,
                        value,
                        scope,
                        false,
                        __toArray(accesses).concat([ast.Const(key.value)])
                      )).check;
                      type = _ref.type;
                      typeData[key.value] = type;
                      current = ast.Block([current, check]);
                    }
                  }
                  return current;
                }())
              );
              return { check: result, type: Type.makeObject(typeData) };
            }
          };
          function translateTypeCheck(ident, node, scope, hasDefaultValue, accesses) {
            if (!__owns.call(translateTypeChecks, node.constructor.cappedName)) {
              throw Error("Unknown type: " + String(node.constructor.cappedName));
            }
            return translateTypeChecks[node.constructor.cappedName](
              ident,
              node,
              scope,
              hasDefaultValue,
              accesses
            );
          }
          translateParamTypes = {
            Param: function (param, scope, inner) {
              var ident, init, laterInit, tmp, typeCheck;
              ident = translate(param.ident, scope, "param")();
              if (param.ident instanceof ParserNode.Tmp) {
                scope.markAsParam(ident);
              }
              laterInit = [];
              if (ident instanceof ast.Binary && ident.op === "." && ident.right instanceof ast.Const && typeof ident.right.value === "string") {
                tmp = ast.Ident(ident.right.value);
                laterInit.push(ast.Binary(ident, "=", tmp));
                ident = tmp;
              }
              if (!(ident instanceof ast.Ident)) {
                throw Error("Expecting param to be an Ident, got " + __typeof(ident));
              }
              if (param.asType) {
                typeCheck = translateTypeCheck(
                  ident,
                  param.asType,
                  scope,
                  param.defaultValue != null,
                  []
                );
              }
              if (inner) {
                scope.addVariable(
                  ident,
                  typeCheck != null ? typeCheck.type : void 0,
                  param.isMutable
                );
              }
              init = [];
              if (param.defaultValue != null) {
                init.push(ast.If(
                  ast.Binary(ident, "==", ast.Const(null)),
                  ast.Assign(ident, translate(param.defaultValue, scope, "expression")()),
                  typeCheck != null ? typeCheck.check : void 0
                ));
              } else if (typeCheck) {
                init.push(typeCheck.check);
              }
              return { init: __toArray(init).concat(__toArray(laterInit)), ident: ident, spread: !!param.spread };
            },
            Array: function (array, scope, inner) {
              var _arr, arrayIdent, diff, foundSpread, i, init, len, p, param, spreadCounter;
              if (inner) {
                arrayIdent = scope.reserveIdent("p", Type.array);
              } else {
                arrayIdent = scope.reserveParam();
              }
              init = [];
              foundSpread = -1;
              for (_arr = __toArray(array.elements), i = 0, len = _arr.length; i < len; ++i) {
                p = _arr[i];
                param = translateParam(p, scope, true);
                if (!param.spread) {
                  if (param.ident != null) {
                    if (foundSpread === -1) {
                      init.push(ast.Assign(param.ident, ast.Access(arrayIdent, i)));
                    } else {
                      diff = i - foundSpread - 1;
                      init.push(ast.Assign(param.ident, ast.Access(arrayIdent, diff === 0 ? spreadCounter : ast.Binary(spreadCounter, "+", diff))));
                    }
                  }
                } else {
                  if (foundSpread !== -1) {
                    throw Error("Encountered multiple spread parameters");
                  }
                  foundSpread = i;
                  scope.addHelper("__slice");
                  if (i === len - 1) {
                    init.push(ast.Assign(param.ident, ast.Call(
                      ast.Access(ast.Ident("__slice"), "call"),
                      [arrayIdent].concat(i === 0 ? [] : [ast.Const(i)])
                    )));
                  } else {
                    spreadCounter = scope.reserveIdent("i", Type.number);
                    init.push(ast.Assign(param.ident, ast.IfExpression(
                      ast.Binary(i, "<", ast.Assign(spreadCounter, ast.Binary(
                        ast.Access(arrayIdent, "length"),
                        "-",
                        len - i - 1
                      ))),
                      ast.Call(
                        ast.Access(ast.Ident("__slice"), "call"),
                        [arrayIdent, ast.Const(i), spreadCounter]
                      ),
                      ast.BlockExpression([
                        ast.Assign(spreadCounter, ast.Const(i)),
                        ast.Arr()
                      ])
                    )));
                  }
                }
                init.push.apply(init, __toArray(param.init));
              }
              if (spreadCounter != null) {
                scope.releaseIdent(spreadCounter);
              }
              if (inner) {
                scope.releaseIdent(arrayIdent);
              }
              return { init: init, ident: arrayIdent, spread: false };
            },
            Object: function (object, scope, inner) {
              var _arr, _i, _len, init, key, objectIdent, pair, value;
              if (inner) {
                objectIdent = scope.reserveIdent("p", Type.object);
              } else {
                objectIdent = scope.reserveParam();
              }
              init = [];
              for (_arr = __toArray(object.pairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                pair = _arr[_i];
                key = translate(pair.key, scope, "expression")();
                if (!(key instanceof ast.Const)) {
                  throw Error("Unexpected non-const object key: " + __typeof(key));
                }
                value = translateParam(pair.value, scope, true);
                if (value.ident != null) {
                  scope.addVariable(value.ident);
                  init.push.apply(init, [
                    ast.Assign(value.ident, ast.Access(objectIdent, key))
                  ].concat(__toArray(value.init)));
                }
              }
              if (inner) {
                scope.releaseIdent(objectIdent);
              }
              return { init: init, ident: objectIdent, spread: false };
            },
            Nothing: function (object, scope, inner) {
              return {
                init: [],
                ident: inner ? null : scope.reserveParam(),
                spread: false
              };
            }
          };
          function translateParam(param, scope, inner) {
            var type;
            type = param.constructor.cappedName;
            if (!__owns.call(translateParamTypes, type)) {
              throw Error("Unknown parameter type: " + __strnum(type));
            }
            return translateParamTypes[type](param, scope, inner);
          }
          translateType = (function () {
            var translateTypes;
            translateTypes = {
              Ident: (function () {
                var primordialTypes;
                primordialTypes = {
                  String: Type.string,
                  Number: Type.number,
                  Boolean: Type.boolean,
                  Function: Type["function"],
                  Array: Type.array
                };
                return function (node, scope) {
                  if (!__owns.call(primordialTypes, node.name)) {
                    throw Error("Not implemented: custom type " + __strnum(node.name));
                  }
                  return primordialTypes[node.name];
                };
              }()),
              Const: function (node, scope) {
                switch (node.value) {
                case null: return Type["null"];
                case void 0: return Type["undefined"];
                default: throw Error("Unexpected const type: " + String(node.value));
                }
              },
              TypeArray: function (node, scope) {
                return translateType(node.subtype, scope).array();
              },
              TypeFunction: function (node, scope) {
                return translateType(node.returnType, scope)["function"]();
              },
              TypeUnion: function (node, scope) {
                var _arr, _i, _len, current, type;
                current = Type.none;
                for (_arr = __toArray(node.types), _i = 0, _len = _arr.length; _i < _len; ++_i) {
                  type = _arr[_i];
                  current = current.union(translateType(type));
                }
                return current;
              }
            };
            return function (node, scope) {
              if (!__owns.call(translateTypes, node.constructor.cappedName)) {
                throw Error("Unknown type to translate: " + String(node.constructor.cappedName));
              }
              return translateTypes[node.constructor.cappedName](node, scope);
            };
          }());
          return function (node, scope, location, autoReturn) {
            return function () {
              var _arr, body, diff, fakeThis, foundSpread, func, i, initializers, innerScope, len, p, param, paramIdents, spreadCounter, unassigned;
              innerScope = scope.clone(!!node.bound);
              paramIdents = [];
              initializers = [];
              foundSpread = -1;
              for (_arr = __toArray(node.params), i = 0, len = _arr.length; i < len; ++i) {
                p = _arr[i];
                param = translateParam(p, innerScope, false);
                if (!param.spread) {
                  if (foundSpread === -1) {
                    paramIdents.push(param.ident);
                  } else {
                    innerScope.addVariable(param.ident, Type.any, param.isMutable);
                    diff = i - foundSpread - 1;
                    initializers.push(ast.Assign(param.ident, ast.Access(ast.Arguments(), diff === 0 ? spreadCounter : ast.Binary(spreadCounter, "+", diff))));
                  }
                } else {
                  if (foundSpread !== -1) {
                    throw Error("Encountered multiple spread parameters");
                  }
                  foundSpread = i;
                  innerScope.addHelper("__slice");
                  innerScope.addVariable(param.ident, Type.array, param.isMutable);
                  if (i === len - 1) {
                    initializers.push(ast.Assign(param.ident, ast.Call(
                      ast.Access(ast.Ident("__slice"), "call"),
                      [ast.Arguments()].concat(i === 0 ? [] : [ast.Const(i)])
                    )));
                  } else {
                    spreadCounter = innerScope.reserveIdent("ref", Type.number);
                    initializers.push(ast.Assign(param.ident, ast.IfExpression(
                      ast.Binary(i, "<", ast.Assign(spreadCounter, ast.Binary(
                        ast.Access(ast.Arguments(), "length"),
                        "-",
                        len - i - 1
                      ))),
                      ast.Call(
                        ast.Access(ast.Ident("__slice"), "call"),
                        [ast.Arguments(), ast.Const(i), spreadCounter]
                      ),
                      ast.BlockExpression([
                        ast.Assign(spreadCounter, ast.Const(i)),
                        ast.Arr()
                      ])
                    )));
                  }
                }
                initializers.push.apply(initializers, __toArray(param.init));
              }
              if (spreadCounter) {
                innerScope.releaseIdent(spreadCounter);
              }
              unassigned = {};
              if (node.generator) {
                body = generatorTranslate(node.body, innerScope, GeneratorBuilder(innerScope)).create();
              } else {
                body = translate(
                  node.body,
                  innerScope,
                  "topStatement",
                  node.autoReturn,
                  unassigned
                )();
              }
              innerScope.releaseTmps();
              body = ast.Block(__toArray(initializers).concat([body]));
              if (innerScope.usedThis || node.bound instanceof ParserNode) {
                if (node.bound instanceof ParserNode) {
                  fakeThis = ast.Ident("_this");
                  innerScope.addVariable(fakeThis);
                  body = ast.Block([
                    ast.Assign(fakeThis, translate(
                      node.bound,
                      scope,
                      "expression",
                      null,
                      unassigned
                    )()),
                    body,
                    ast.Return(fakeThis)
                  ]);
                } else {
                  if (innerScope.bound) {
                    scope.usedThis = true;
                  }
                  if (innerScope.hasBound && !innerScope.bound) {
                    fakeThis = ast.Ident("_this");
                    innerScope.addVariable(fakeThis);
                    body = ast.Block([
                      ast.Assign(fakeThis, ast.This()),
                      body
                    ]);
                  }
                }
              }
              if (innerScope.hasStopIteration) {
                scope.hasStopIteration = true;
              }
              if (innerScope.hasGlobal) {
                scope.hasGlobal = true;
              }
              func = ast.Func(
                null,
                paramIdents,
                innerScope.getVariables(),
                body,
                []
              );
              return autoReturn(func);
            };
          };
        }()),
        Ident: function (node, scope, location, autoReturn) {
          var name;
          name = node.name;
          if (__num(name.length) > 2 && name.charCodeAt(0) === 95 && name.charCodeAt(1) === 95) {
            scope.addHelper(name);
          }
          if (name === "StopIteration") {
            scope.hasStopIteration = true;
          }
          if (name === "GLOBAL") {
            scope.hasGlobal = true;
          }
          return function () {
            return autoReturn(ast.Ident(name));
          };
        },
        If: function (node, scope, location, autoReturn, unassigned) {
          var innerLocation, tLabel, tTest, tWhenFalse, tWhenTrue;
          if (location === "statement" || location === "topStatement") {
            innerLocation = "statement";
          } else {
            innerLocation = location;
          }
          tLabel = node.label && translate(node.label, scope, "label");
          tTest = translate(
            node.test,
            scope,
            "expression",
            null,
            unassigned
          );
          tWhenTrue = translate(
            node.whenTrue,
            scope,
            innerLocation,
            autoReturn,
            unassigned
          );
          if (node.whenFalse != null) {
            tWhenFalse = translate(
              node.whenFalse,
              scope,
              innerLocation,
              autoReturn,
              unassigned
            );
          }
          return function () {
            return ast.If(
              tTest(),
              tWhenTrue(),
              typeof tWhenFalse === "function" ? tWhenFalse() : void 0,
              typeof tLabel === "function" ? tLabel() : void 0
            );
          };
        },
        Nothing: function () {
          return function () {
            return ast.Noop();
          };
        },
        Object: function (node, scope, location, autoReturn, unassigned) {
          var _arr, _i, _len, pair, properties, tKeys, tPrototype, tValues;
          tKeys = [];
          tValues = [];
          properties = [];
          for (_arr = __toArray(node.pairs), _i = 0, _len = _arr.length; _i < _len; ++_i) {
            pair = _arr[_i];
            tKeys.push(translate(
              pair.key,
              scope,
              "expression",
              null,
              unassigned
            ));
            tValues.push(translate(
              pair.value,
              scope,
              "expression",
              null,
              unassigned
            ));
            properties.push(pair.property);
          }
          if (node.prototype != null) {
            tPrototype = translate(
              node.prototype,
              scope,
              "expression",
              null,
              unassigned
            );
          }
          return function () {
            var _len, _this, constPairs, currentPair, currentPairs, i, ident, key, lastProperty, obj, postConstPairs, property, prototype, result, tKey, tValue, value;
            _this = this;
            constPairs = [];
            postConstPairs = [];
            if (typeof tPrototype === "function") {
              prototype = tPrototype();
            }
            if (prototype != null) {
              currentPairs = postConstPairs;
            } else {
              currentPairs = constPairs;
            }
            lastProperty = null;
            for (i = 0, _len = tKeys.length; i < _len; ++i) {
              tKey = tKeys[i];
              tValue = tValues[i];
              key = tKey();
              value = tValue();
              property = properties[i];
              if (!(key instanceof ast.Const) || property) {
                currentPairs = postConstPairs;
              }
              currentPair = currentPairs[currentPairs.length - 1];
              if ((property === "get" || property === "set") && lastProperty && property !== lastProperty && key instanceof ast.Const && currentPair.key instanceof ast.Const && key.value === currentPair.key.value) {
                currentPair[lastProperty] = currentPair.value;
                currentPair.property = __strnum(lastProperty) + __strnum(property);
                delete currentPair.value;
                currentPair[property] = value;
                lastProperty = null;
              } else {
                currentPairs.push({ key: key, value: value, property: property });
                if (property === "get" || property === "set") {
                  lastProperty = property;
                }
              }
            }
            if (prototype != null) {
              scope.addHelper("__create");
              obj = ast.Call(ast.Ident("__create"), [prototype]);
            } else {
              obj = ast.Obj((function () {
                var _arr, _i, _len, _ref, key, value;
                for (_arr = [], _i = 0, _len = constPairs.length; _i < _len; ++_i) {
                  key = (_ref = constPairs[_i]).key;
                  value = _ref.value;
                  _arr.push(ast.Obj.Pair(String(key.value), value));
                }
                return _arr;
              }()));
            }
            if (postConstPairs.length === 0) {
              return autoReturn(obj);
            } else {
              ident = scope.reserveIdent("o", Type.object);
              result = ast.BlockExpression([ast.Assign(ident, obj)].concat(
                (function () {
                  var _arr, _f, _i, _len;
                  for (_arr = [], _i = 0, _len = postConstPairs.length, _f = function (pair) {
                    var key, property;
                    key = pair.key;
                    property = pair.property;
                    if (property) {
                      scope.addHelper("__defProp");
                      return ast.Call(ast.Ident("__defProp"), [
                        ident,
                        key,
                        property === "property" ? pair.value
                          : property === "getset"
                          ? ast.Obj([
                            ast.Obj.Pair("get", pair.get),
                            ast.Obj.Pair("set", pair.set),
                            ast.Obj.Pair("configurable", ast.Const(true)),
                            ast.Obj.Pair("enumerable", ast.Const(true))
                          ])
                          : property === "setget"
                          ? ast.Obj([
                            ast.Obj.Pair("set", pair.set),
                            ast.Obj.Pair("get", pair.get),
                            ast.Obj.Pair("configurable", ast.Const(true)),
                            ast.Obj.Pair("enumerable", ast.Const(true))
                          ])
                          : property === "get"
                          ? ast.Obj([
                            ast.Obj.Pair("get", pair.value),
                            ast.Obj.Pair("configurable", ast.Const(true)),
                            ast.Obj.Pair("enumerable", ast.Const(true))
                          ])
                          : property === "set"
                          ? ast.Obj([
                            ast.Obj.Pair("set", pair.value),
                            ast.Obj.Pair("configurable", ast.Const(true)),
                            ast.Obj.Pair("enumerable", ast.Const(true))
                          ])
                          : (function () {
                            throw Error("Unknown property type: " + String(property));
                          }())
                      ]);
                    } else {
                      return ast.Assign(
                        ast.Access(ident, key),
                        pair.value
                      );
                    }
                  }; _i < _len; ++_i) {
                    _arr.push(_f.call(_this, postConstPairs[_i]));
                  }
                  return _arr;
                }()),
                [ident]
              ));
              scope.releaseIdent(ident);
              return autoReturn(result);
            }
          };
        },
        Regexp: function (node, scope, location, autoReturn, unassigned) {
          var tSource;
          tSource = translate(
            node.source,
            scope,
            "expression",
            null,
            unassigned
          );
          return function () {
            var flags, source;
            source = tSource();
            flags = node.flags;
            if (source.isConst()) {
              return autoReturn(ast.Regex(String(source.constValue()), flags));
            } else {
              return autoReturn(ast.Call(ast.Ident("RegExp"), [source, ast.Const(flags)]));
            }
          };
        },
        Return: function (node, scope, location, autoReturn, unassigned) {
          var tValue;
          if (location !== "statement" && location !== "topStatement") {
            throw Error("Expected Return in statement position");
          }
          tValue = translate(
            node.node,
            scope,
            "expression",
            null,
            unassigned
          );
          return function () {
            return ast.Return(tValue());
          };
        },
        Root: function (node, scope, location, autoReturn, unassigned) {
          var tBody;
          tBody = translate(
            node.body,
            scope,
            "topStatement",
            scope.options["return"] || scope.options["eval"],
            unassigned
          );
          return function () {
            var _arr, _i, _len, bareInit, body, callFunc, comments, fakeThis, globalNode, helper, ident, init, walker;
            body = tBody();
            comments = [];
            while (true) {
              if (body instanceof ast.Comment) {
                comments.push(body);
                body = ast.Noop();
              } else if (body instanceof ast.Block && body.body[0] instanceof ast.Comment) {
                comments.push(body.body[0]);
                body = ast.Block(__slice.call(body.body, 1));
              } else {
                break;
              }
            }
            init = [];
            if (scope.hasBound && scope.usedThis) {
              fakeThis = ast.Ident("_this");
              scope.addVariable(fakeThis);
              init.push(ast.Assign(fakeThis, ast.This()));
            }
            scope.fillHelperDependencies();
            for (_arr = __toArray(scope.getHelpers()), _i = 0, _len = _arr.length; _i < _len; ++_i) {
              helper = _arr[_i];
              if (HELPERS.has(helper)) {
                ident = ast.Ident(helper);
                scope.addVariable(ident);
                init.push(ast.Assign(ident, HELPERS.get(helper)));
              }
            }
            bareInit = [];
            if (scope.hasStopIteration) {
              bareInit.push(ast.If(
                ast.Binary(
                  ast.Unary("typeof", ast.Ident("StopIteration")),
                  "===",
                  "undefined"
                ),
                ast.Assign(ast.Ident("StopIteration"), ast.If(
                  ast.Binary(
                    ast.Unary("typeof", ast.Access(ast.Ident("Object"), "freeze")),
                    "===",
                    "function"
                  ),
                  ast.Call(
                    ast.Access(ast.Ident("Object"), "freeze"),
                    [ast.Obj()]
                  ),
                  ast.Obj()
                ))
              ));
            }
            globalNode = ast.If(
              ast.Binary(
                ast.Unary("typeof", ast.Ident("window")),
                "!==",
                "undefined"
              ),
              ast.Ident("window"),
              ast.If(
                ast.Binary(
                  ast.Unary("typeof", ast.Ident("global")),
                  "!==",
                  "undefined"
                ),
                ast.Ident("global"),
                ast.This()
              )
            );
            if (scope.options.bare) {
              if (scope.hasGlobal) {
                scope.addVariable(ast.Ident("GLOBAL"));
                bareInit.unshift(ast.Assign(ast.Ident("GLOBAL"), globalNode));
              }
              if (scope.options.undefinedName != null) {
                scope.addVariable(scope.options.undefinedName);
              }
              return ast.Root(
                ast.Block(__toArray(comments).concat(__toArray(bareInit), __toArray(init), [body])),
                scope.getVariables(),
                ["use strict"]
              );
            } else {
              if (scope.options["eval"]) {
                scope.hasGlobal = true;
                walker = function (node) {
                  if (node instanceof ast.Func) {
                    if (node.name != null) {
                      return ast.Block([
                        node,
                        ast.Assign(
                          ast.Access(ast.Ident("GLOBAL"), node.name.name),
                          node.name
                        )
                      ]);
                    } else {
                      return node;
                    }
                  } else if (node instanceof ast.Binary && node.op === "=" && node.left instanceof ast.Ident) {
                    return ast.Assign(
                      ast.Access(ast.Ident("GLOBAL"), node.left.name),
                      node.walk(walker)
                    );
                  }
                };
                body = body.walk(walker);
              }
              callFunc = ast.Call(
                ast.Access(
                  ast.Func(
                    null,
                    (scope.hasGlobal ? [ast.Ident("GLOBAL")] : []).concat(scope.options.undefinedName != null
                      ? [ast.Ident(scope.options.undefinedName, true)]
                      : []),
                    scope.getVariables(),
                    ast.Block(__toArray(init).concat([body])),
                    ["use strict"]
                  ),
                  "call"
                ),
                [ast.This()].concat(scope.hasGlobal ? [globalNode] : [])
              );
              if (scope.options["return"]) {
                callFunc = ast.Return(callFunc);
              }
              return ast.Root(
                ast.Block(__toArray(comments).concat(__toArray(bareInit), [callFunc])),
                [],
                []
              );
            }
          };
        },
        Switch: function (node, scope, location, autoReturn, unassigned) {
          var _arr, _arr2, _i, _len, case_, tCases, tDefaultCase, tLabel, tNode;
          tLabel = node.label && translate(node.label, scope, "label");
          tNode = translate(
            node.node,
            scope,
            "expression",
            null,
            unassigned
          );
          for (_arr = [], _arr2 = __toArray(node.cases), _i = 0, _len = _arr2.length; _i < _len; ++_i) {
            case_ = _arr2[_i];
            _arr.push({
              tNode: translate(
                case_.node,
                scope,
                "expression",
                null,
                unassigned
              ),
              tBody: translate(
                case_.body,
                scope,
                "statement",
                null,
                unassigned
              ),
              fallthrough: case_.fallthrough
            });
          }
          tCases = _arr;
          if (node.defaultCase != null) {
            tDefaultCase = translate(
              node.defaultCase,
              scope,
              "statement",
              null,
              unassigned
            );
          }
          return function () {
            var defaultCase, node;
            node = tNode();
            if (tDefaultCase != null) {
              defaultCase = autoReturn(tDefaultCase());
            } else {
              defaultCase = ast.Noop();
            }
            return ast.Switch(
              node,
              (function () {
                var _arr, case_, caseBody, caseNode, i, len;
                for (_arr = [], i = 0, len = tCases.length; i < len; ++i) {
                  case_ = tCases[i];
                  caseNode = case_.tNode();
                  caseBody = case_.tBody();
                  if (!case_.fallthrough || i === len - 1 && defaultCase.isNoop()) {
                    caseBody = ast.Block([autoReturn(caseBody), ast.Break()]);
                  }
                  _arr.push(ast.Switch.Case(caseNode, caseBody));
                }
                return _arr;
              }()),
              defaultCase,
              typeof tLabel === "function" ? tLabel() : void 0
            );
          };
        },
        Super: function (node, scope, location, autoReturn) {
          throw Error("Cannot have a stray super call");
        },
        Tmp: function (node, scope, location, autoReturn) {
          var ident;
          ident = scope.getTmp(node.id, node.name, node.type());
          return function () {
            return autoReturn(ident);
          };
        },
        TmpWrapper: function (node, scope, location, autoReturn, unassigned) {
          var _arr, _i, tmp, tResult;
          tResult = translate(
            node.node,
            scope,
            location,
            autoReturn,
            unassigned
          );
          for (_arr = __toArray(node.tmps), _i = _arr.length; _i--; ) {
            tmp = _arr[_i];
            scope.releaseTmp(tmp);
          }
          return tResult;
        },
        This: function (node, scope, location, autoReturn) {
          return function () {
            scope.usedThis = true;
            return autoReturn(scope.bound ? ast.Ident("_this") : ast.This());
          };
        },
        Throw: function (node, scope, location, autoReturn, unassigned) {
          var tNode;
          tNode = translate(
            node.node,
            scope,
            "expression",
            null,
            unassigned
          );
          return function () {
            return ast.Throw(tNode());
          };
        },
        TryCatch: function (node, scope, location, autoReturn, unassigned) {
          var tCatchBody, tCatchIdent, tLabel, tTryBody;
          tLabel = node.label && translate(node.label, scope, "label");
          tTryBody = translate(
            node.tryBody,
            scope,
            "statement",
            autoReturn,
            unassigned
          );
          tCatchIdent = translate(node.catchIdent, scope, "leftExpression");
          tCatchBody = translate(
            node.catchBody,
            scope,
            "statement",
            autoReturn,
            unassigned
          );
          return function () {
            return ast.TryCatch(tTryBody(), tCatchIdent(), tCatchBody(), typeof tLabel === "function" ? tLabel() : void 0);
          };
        },
        TryFinally: function (node, scope, location, autoReturn, unassigned) {
          var tFinallyBody, tLabel, tTryBody;
          tLabel = node.label && translate(node.label, scope, "label");
          tTryBody = translate(
            node.tryBody,
            scope,
            "statement",
            autoReturn,
            unassigned
          );
          tFinallyBody = translate(
            node.finallyBody,
            scope,
            "statement",
            null,
            unassigned
          );
          return function () {
            return ast.TryFinally(tTryBody(), tFinallyBody(), typeof tLabel === "function" ? tLabel() : void 0);
          };
        },
        Unary: function (node, scope, location, autoReturn, unassigned) {
          var _ref, tSubnode;
          if (unassigned && ((_ref = node.op) === "++" || _ref === "--" || _ref === "++post" || _ref === "--post") && node.node instanceof ParserNode.Ident) {
            unassigned[node.node.name] = false;
          }
          tSubnode = translate(
            node.node,
            scope,
            "expression",
            null,
            unassigned
          );
          return function () {
            return autoReturn(ast.Unary(node.op, tSubnode()));
          };
        },
        Var: function (node, scope, location, autoReturn, unassigned) {
          var tIdent;
          if (unassigned && node.ident instanceof ParserNode.Ident && !__owns.call(unassigned, node.ident.name)) {
            unassigned[node.ident.name] = true;
          }
          tIdent = translate(node.ident, scope, "leftExpression", autoReturn);
          return function () {
            var ident;
            ident = tIdent();
            scope.addVariable(ident, Type.any, node.isMutable);
            return ast.Noop();
          };
        }
      };
      function translate(node, scope, location, autoReturn, unassigned) {
        var ret;
        if (!__isObject(node)) {
          throw TypeError("Expected node to be an Object, got " + __typeof(node));
        }
        if (!(scope instanceof Scope)) {
          throw TypeError("Expected scope to be a Scope, got " + __typeof(scope));
        }
        if (typeof location !== "string") {
          throw TypeError("Expected location to be a String, got " + __typeof(location));
        }
        if (typeof autoReturn !== "function") {
          autoReturn = makeAutoReturn(autoReturn);
        }
        if (!__owns.call(translators, node.constructor.cappedName)) {
          throw Error("Unable to translate unknown node type: " + String(node.constructor.cappedName));
        }
        ret = translators[node.constructor.cappedName](
          node,
          scope,
          location,
          autoReturn,
          unassigned
        );
        if (typeof ret !== "function") {
          throw Error("Translated non-function: " + __typeof(ret));
        }
        return ret;
      }
      function translateArray(nodes, scope, location, autoReturn, unassigned) {
        var _arr, i, len, node;
        if (!__isArray(nodes)) {
          throw TypeError("Expected nodes to be an Array, got " + __typeof(nodes));
        }
        if (!(scope instanceof Scope)) {
          throw TypeError("Expected scope to be a Scope, got " + __typeof(scope));
        }
        if (typeof location !== "string") {
          throw TypeError("Expected location to be a String, got " + __typeof(location));
        }
        for (_arr = [], i = 0, len = nodes.length; i < len; ++i) {
          node = nodes[i];
          _arr.push(translate(
            nodes[i],
            scope,
            location,
            i === len - 1 && autoReturn,
            unassigned
          ));
        }
        return _arr;
      }
      module.exports = function (node, options, callback) {
        var endTime, result, ret, scope, startTime;
        if (options == null) {
          options = {};
        }
        if (typeof options === "function") {
          return module.exports(node, null, options);
        }
        startTime = new Date().getTime();
        try {
          scope = Scope(options, false);
          result = translate(
            node,
            scope,
            "statement",
            false,
            {}
          )();
          scope.releaseTmps();
        } catch (e) {
          if (callback != null) {
            return callback(e);
          } else {
            throw e;
          }
        }
        endTime = new Date().getTime();
        if (typeof options.progress === "function") {
          options.progress("translate", __num(endTime) - __num(startTime));
        }
        ret = { node: result, time: __num(endTime) - __num(startTime) };
        if (callback != null) {
          return callback(null, ret);
        } else {
          return ret;
        }
      };
      module.exports.helpers = HELPERS;
      module.exports.defineHelper = function (name, value, type, dependencies) {
        var helper, ident, scope;
        if (!(type instanceof Type)) {
          throw TypeError("Expected type to be a Type, got " + __typeof(type));
        }
        scope = Scope({}, false);
        if (typeof name === "string") {
          ident = ast.Ident(name);
        } else if (name instanceof ParserNode.Ident) {
          ident = translate(name, scope, "leftExpression")();
        } else {
          throw TypeError("Expecting name to be a String or Ident, got " + __typeof(name));
        }
        if (!(ident instanceof ast.Ident)) {
          throw Error("Expected name to be an Ident, got " + __typeof(ident));
        }
        if (value instanceof AstNode) {
          helper = value;
        } else if (value instanceof ParserNode) {
          helper = translate(value, scope, "expression")();
        } else {
          throw TypeError("Expected value to be a parser or ast Node, got " + __typeof(value));
        }
        if (dependencies == null) {
          dependencies = scope.getHelpers();
        }
        HELPERS.add(ident.name, helper, type, dependencies);
        return { helper: helper, dependencies: dependencies };
      };
    }.call(this));
    
    return module.exports;
  }.call({}));
  require['./gorilla'] = (function () {
    var module = { exports: this };
    var exports = this;
    (function (GLOBAL) {
      "use strict";
      var __lte, __num, __owns, __strnum, __typeof, compile, fetchAndParsePrelude, fs, os, parse, parser, path, translate, translator;
      __lte = function (x, y) {
        var type;
        type = typeof x;
        if (type !== "number" && type !== "string") {
          throw TypeError("Cannot compare a non-number/string: " + type);
        } else if (type !== typeof y) {
          throw TypeError("Cannot compare elements of different types: " + type + " vs " + typeof y);
        } else {
          return x <= y;
        }
      };
      __num = function (num) {
        if (typeof num !== "number") {
          throw TypeError("Expected a number, got " + __typeof(num));
        } else {
          return num;
        }
      };
      __owns = Object.prototype.hasOwnProperty;
      __strnum = function (strnum) {
        var type;
        type = typeof strnum;
        if (type === "string") {
          return strnum;
        } else if (type === "number") {
          return String(strnum);
        } else {
          throw TypeError("Expected a string or number, got " + __typeof(strnum));
        }
      };
      __typeof = (function () {
        var _toString;
        _toString = Object.prototype.toString;
        return function (o) {
          if (o === void 0) {
            return "Undefined";
          } else if (o === null) {
            return "Null";
          } else {
            return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);
          }
        };
      }());
      parser = require("./parser");
      translator = require("./translator");
      os = require("os");
      fs = require("fs");
      path = require("path");
      exports.version = "1.0";
      if (require.extensions) {
        require.extensions[".gs"] = function (module, filename) {
          var compiled;
          compiled = compile(
            fs.readFileSync(filename, "utf8"),
            { filename: filename }
          );
          return module._compile(compiled.code, filename);
        };
      } else if (require.registerExtension) {
        require.registerExtension(".gs", function (content) {
          return compiler(content);
        });
      }
      fetchAndParsePrelude = (function () {
        var fetchers, parsedPrelude, preludeCachePath, preludeSrcPath;
        fetchers = [];
        function flush(err, value) {
          while (fetchers.length > 0) {
            fetchers.shift()(err, value);
          }
        }
        if (typeof __filename !== "undefined" && __filename !== null) {
          preludeSrcPath = path.join(path.dirname(fs.realpathSync(__filename)), "../src/prelude.gs");
        }
        if (os != null) {
          preludeCachePath = path.join(os.tmpDir(), "gs-prelude.cache");
        }
        function f(cb) {
          if (parsedPrelude != null) {
            return cb(null, parsedPrelude);
          }
          fetchers.push(cb);
          if (fetchers.length > 1) {
            return;
          }
          return fs.stat(preludeSrcPath, function (_e, preludeSrcStat) {
            if (_e != null) {
              return flush(_e);
            }
            return fs.stat(preludeCachePath, function (err, preludeCacheStat) {
              if (err != null && err.code !== "ENOENT") {
                return flush(err, null);
              }
              function next() {
                return fs.readFile(preludeSrcPath, "utf8", function (_e2, prelude) {
                  if (_e2 != null) {
                    return flush(_e2);
                  }
                  if (parsedPrelude == null) {
                    parsedPrelude = parser(prelude, null, { serializeMacros: true });
                    fs.writeFile(preludeCachePath, parsedPrelude.macros.serialize(), "utf8", function (err) {
                      if (err != null) {
                        throw err;
                      }
                    });
                  }
                  return flush(null, parsedPrelude);
                });
              }
              if (preludeCacheStat && __lte(preludeSrcStat.mtime.getTime(), preludeCacheStat.mtime.getTime())) {
                return fs.readFile(preludeCachePath, "utf8", function (_e2, cachePrelude) {
                  var _else;
                  if (_e2 != null) {
                    return flush(_e2);
                  }
                  _else = true;
                  try {
                    return parsedPrelude = parser.deserializePrelude(cachePrelude);
                  } catch (e) {
                    _else = false;
                    if (e instanceof ReferenceError) {
                      throw e;
                    } else {
                      console.error("Error deserializing prelude, reloading. " + String(e));
                      return fs.unlink(preludeCachePath, function (_e3) {
                        if (_e3 != null) {
                          return flush(_e3);
                        }
                        return next();
                      });
                    }
                  } finally {
                    if (_else) {
                      flush(null, parsedPrelude);
                    }
                  }
                });
              } else {
                return next();
              }
            });
          });
        }
        f.serialized = function (cb) {
          return f(function (_e) {
            if (_e != null) {
              return cb(_e);
            }
            return fs.readFile(preludeCachePath, "utf8", cb);
          });
        };
        f.sync = function () {
          var cachePrelude, prelude, preludeCacheStat, preludeSrcStat;
          if (parsedPrelude != null) {
            return parsedPrelude;
          } else {
            preludeSrcStat = fs.statSync(preludeSrcPath);
            preludeCacheStat = (function () {
              try {
                return fs.statSync(preludeCachePath);
              } catch (e) {
                if (e.code !== "ENOENT") {
                  throw e;
                }
              }
            }());
            if (preludeCacheStat && __lte(preludeSrcStat.mtime.getTime(), preludeCacheStat.mtime.getTime())) {
              cachePrelude = fs.readFileSync(preludeCachePath, "utf8");
              try {
                parsedPrelude = parser.deserializePrelude(cachePrelude);
              } catch (e) {
                if (e instanceof ReferenceError) {
                  throw e;
                } else {
                  console.error("Error deserializing prelude, reloading. " + String(e));
                  fs.unlinkSync(preludeCachePath);
                }
              }
            }
            if (parsedPrelude == null) {
              prelude = fs.readFileSync(preludeSrcPath, "utf8");
              parsedPrelude = parser(prelude, null, { serializeMacros: true });
              fs.writeFile(preludeCachePath, parsedPrelude.macros.serialize(), "utf8", function (err) {
                if (err != null) {
                  throw err;
                }
              });
            }
            return parsedPrelude;
          }
        };
        exports.withPrelude = function (serializedPrelude) {
          parsedPrelude = parser.deserializePrelude(serializedPrelude);
          return this;
        };
        return f;
      }());
      exports.getSerializedPrelude = fetchAndParsePrelude.serialized;
      parse = exports.parse = function (source, options, callback) {
        var prelude;
        if (options == null) {
          options = {};
        }
        if (typeof options === "function") {
          return parse(source, null, options);
        }
        if (options.noPrelude) {
          return parser(source, null, options, callback);
        } else if (callback != null) {
          return fetchAndParsePrelude(function (_e, prelude) {
            if (_e != null) {
              return callback(_e);
            }
            return parser(source, prelude.macros, options, callback);
          });
        } else {
          prelude = fetchAndParsePrelude.sync();
          return parser(source, prelude.macros, options, callback);
        }
      };
      exports.getReservedWords = function (options) {
        if (options == null) {
          options = {};
        }
        if (options.noPrelude) {
          return parser.getReservedWords();
        } else {
          return parser.getReservedWords(fetchAndParsePrelude.sync().macros);
        }
      };
      translate = exports.ast = function (source, options, callback) {
        var parsed, startTime;
        if (options == null) {
          options = {};
        }
        if (typeof options === "function") {
          return translate(source, null, options);
        }
        startTime = new Date().getTime();
        function next(parsed, translated) {
          var result;
          result = {
            node: translated.node,
            parseTime: parsed.parseTime,
            macroExpandTime: parsed.macroExpandTime,
            reduceTime: parsed.reduceTime,
            translateTime: translated.time,
            time: __num(new Date().getTime()) - __num(startTime)
          };
          if (callback != null) {
            return callback(null, result);
          } else {
            return result;
          }
        }
        if (callback != null) {
          return parse(source, options, function (_e, parsed) {
            if (_e != null) {
              return callback(_e);
            }
            return translator(parsed.result, options, function (_e2, translated) {
              if (_e2 != null) {
                return callback(_e2);
              }
              return next(parsed, translated);
            });
          });
        } else {
          parsed = parse(source, options);
          return next(parsed, translator(parsed.result, options));
        }
      };
      compile = exports.compile = function (source, options, callback) {
        var startTime;
        if (options == null) {
          options = {};
        }
        if (typeof options === "function") {
          return compile(source, null, options);
        }
        startTime = new Date().getTime();
        function next(translated) {
          var compiled, result;
          compiled = translated.node.compile(options);
          result = {
            parseTime: translated.parseTime,
            macroExpandTime: translated.macroExpandTime,
            reduceTime: translated.reduceTime,
            translateTime: translated.translateTime,
            compileTime: compiled.compileTime,
            uglifyTime: compiled.uglifyTime,
            time: __num(new Date().getTime()) - __num(startTime),
            code: compiled.code
          };
          if (callback != null) {
            return callback(null, result);
          } else {
            return result;
          }
        }
        if (callback != null) {
          return translate(source, options, function (_e, translated) {
            if (_e != null) {
              return callback(_e);
            }
            return next(translated);
          });
        } else {
          return next(translate(source, options));
        }
      };
      function evaluate(code, options) {
        var _arr, _i, _module, _obj, _ref, _require, fun, k, Module, r, sandbox, Script, v;
        if (typeof require === "function" && (_ref = require("vm")) != null) {
          Script = _ref.Script;
        }
        if (Script) {
          sandbox = Script.createContext();
          sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;
          if (options.sandbox != null) {
            if (options.sandbox instanceof sandbox.constructor) {
              sandbox = options.sandbox;
            } else {
              _obj = options.sandbox;
              for (k in _obj) {
                if (__owns.call(_obj, k)) {
                  v = _obj[k];
                  sandbox[k] = v;
                }
              }
            }
          }
          sandbox.__filename = options.filename || "eval";
          sandbox.__dirname = path.dirname(sandbox.__filename);
          if (!sandbox.module && !sandbox.require) {
            Module = require("module");
            _module = sandbox.module = new Module(options.modulename || "eval");
            _require = sandbox.require = function (path) {
              return Module._load(path, _module);
            };
            _module.filename = sandbox.__filename;
            for (_arr = Object.getOwnPropertyNames(require), _i = _arr.length; _i--; ) {
              r = _arr[_i];
              try {
                _require[r] = require[r];
              } catch (e) {}
            }
          }
          if (options.includeGlobals) {
            for (k in GLOBAL) {
              if (__owns.call(GLOBAL, k) && !(k in sandbox)) {
                sandbox[k] = GLOBAL[k];
              }
            }
          }
          return Script.runInContext(code, sandbox);
        } else {
          fun = Function("return " + __strnum(code));
          return fun();
        }
      }
      exports["eval"] = function (source, options, callback) {
        if (options == null) {
          options = {};
        }
        if (typeof options === "function") {
          return exports["eval"](source, null, options);
        }
        options["eval"] = true;
        options["return"] = false;
        function next(compiled) {
          var result, startTime;
          startTime = new Date().getTime();
          result = null;
          try {
            result = evaluate(compiled.code, options);
          } catch (e) {
            if (callback != null) {
              return callback(e);
            } else {
              throw e;
            }
          }
          if (typeof options.progress === "function") {
            options.progress("eval", __num(new Date().getTime()) - __num(startTime));
          }
          if (callback != null) {
            return callback(null, result);
          } else {
            return result;
          }
        }
        if (callback != null) {
          return compile(source, options, function (_e, compiled) {
            if (_e != null) {
              return callback(_e);
            }
            return next(compiled);
          });
        } else {
          return next(compile(source, options));
        }
      };
      exports.run = function (source, options, callback) {
        var mainModule, Module, next;
        if (options == null) {
          options = {};
        }
        if (typeof options === "function") {
          return exports.run(source, null, options);
        }
        if (typeof process === "undefined") {
          exports["eval"](source, options, callback != null
            ? function (err) {
              return callback(err);
            }
            : void 0);
          return;
        }
        mainModule = require.main;
        mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : ".";
        if (mainModule.moduleCache) {
          mainModule.moduleCache = {};
        }
        if (process.binding("natives").module) {
          Module = require("module").Module;
          mainModule.paths = Module._nodeModulePaths(path.dirname(options.filename));
        }
        if (path.extname(mainModule.filename) !== ".gs" || require.extensions) {
          next = function (compiled) {
            mainModule._compile(compiled.code, mainModule.filename);
            if (typeof callback === "function") {
              return callback();
            }
          };
          if (callback != null) {
            compile(source, options, function (_e, ret) {
              if (_e != null) {
                return callback(_e);
              }
              return next(ret);
            });
          } else {
            next(compile(source, options));
          }
        } else {
          mainModule._compile(source, mainModule.filename);
          if (typeof callback === "function") {
            callback();
          }
        }
      };
      exports.init = function (callback) {
        if (callback != null) {
          fetchAndParsePrelude(callback);
        } else {
          fetchAndParsePrelude.sync();
        }
      };
    }.call(this, typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : this));
    
    return module.exports;
  }.call({}));
  require['./browser'] = (function () {
    var module = { exports: this };
    var exports = this;
    (function () {
      "use strict";
      var __async, __isArray, __num, __once, __slice, __toArray, __typeof, GorillaScript, runScripts;
      __async = function (limit, length, onValue, onComplete) {
        var broken, index, slotsUsed, sync;
        if (length <= 0) {
          return onComplete(null);
        }
        if (limit < 1 || limit !== limit) {
          limit = 1/0;
        }
        broken = null;
        slotsUsed = 0;
        sync = false;
        function onValueCallback(err) {
          --slotsUsed;
          if (err != null && broken == null) {
            broken = err;
          }
          if (!sync) {
            return next();
          }
        }
        index = 0;
        function next() {
          var f, i;
          while (broken == null && slotsUsed < limit && index < length) {
            ++slotsUsed;
            i = index;
            ++index;
            sync = true;
            onValue(i, __once(onValueCallback));
            sync = false;
          }
          if (broken != null || slotsUsed === 0) {
            f = onComplete;
            onComplete = void 0;
            if (f) {
              return f(broken);
            }
          }
        }
        return next();
      };
      __isArray = typeof Array.isArray === "function" ? Array.isArray
        : (function () {
          var _toString;
          _toString = Object.prototype.toString;
          return function (x) {
            return _toString.call(x) === "[object Array]";
          };
        }());
      __num = function (num) {
        if (typeof num !== "number") {
          throw TypeError("Expected a number, got " + __typeof(num));
        } else {
          return num;
        }
      };
      __once = function (func) {
        if (typeof func !== "function") {
          throw Error("Expected func to be a Function, got " + __typeof(func));
        }
        return function () {
          var f;
          if (func) {
            f = func;
            func = null;
            return f.apply(this, arguments);
          } else {
            throw Error("Attempted to call function more than once");
          }
        };
      };
      __slice = Array.prototype.slice;
      __toArray = function (x) {
        if (x == null) {
          throw TypeError("Expected an object, got " + __typeof(x));
        } else if (__isArray(x)) {
          return x;
        } else if (typeof x === "string") {
          return x.split("");
        } else {
          return __slice.call(x);
        }
      };
      __typeof = (function () {
        var _toString;
        _toString = Object.prototype.toString;
        return function (o) {
          if (o === void 0) {
            return "Undefined";
          } else if (o === null) {
            return "Null";
          } else {
            return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);
          }
        };
      }());
      GorillaScript = require("./gorilla");
      GorillaScript.require = require;
      if (typeof window !== "undefined" && window !== null) {
        GorillaScript.load = function (url, callback) {
          var xhr;
          if (typeof url !== "string") {
            throw TypeError("Expected url to be a String, got " + __typeof(url));
          }
          if (typeof callback !== "function") {
            throw TypeError("Expected callback to be a Function, got " + __typeof(callback));
          }
          if (window.ActiveXObject) {
            xhr = new (window.ActiveXObject)("Microsoft.XMLHTTP");
          } else if (XMLHttpRequest) {
            xhr = new XMLHttpRequest();
          } else {
            throw Error("Unable to create XMLHttpRequest");
          }
          xhr.open("GET", url, true);
          if (typeof xhr.overrideMimeType === "function") {
            xhr.overrideMimeType("text/plain");
          }
          xhr.onreadystatechange = function () {
            var _ref;
            if (xhr.readyState === 4) {
              if ((_ref = xhr.status) === 0 || _ref === 200) {
                return GorillaScript.run(xhr.responseText, callback);
              } else {
                return callback(Error("Could not load " + url));
              }
            }
          };
          return xhr.send(null);
        };
        runScripts = function () {
          var scripts;
          scripts = document.getElementsByTagName("script");
          return __async(
            1,
            __num(scripts.length),
            function (_i, next) {
              var script;
              script = scripts[_i];
              if (script.type === "text/gorillascript") {
                if (script.src) {
                  return GorillaScript.load(script.src, next);
                } else {
                  GorillaScript.run(script.innerHTML);
                  return next();
                }
              } else {
                return next();
              }
            },
            function (_err) {}
          );
        };
        if (window.addEventListener) {
          addEventListener("DOMContentLoaded", runScripts, false);
        } else {
          attachEvent("onload", runScripts);
        }
      }
    }.call(this));
    
    return module.exports;
  }.call({}));

    return require["./gorilla"].withPrelude({"syntax":[{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, body, macroName;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    body = _p2.body;\n    return __node(\n      \"Call\",\n      68,\n      84,\n      __node(\n        \"Function\",\n        71,\n        81,\n        [],\n        __wrap(body, 2),\n        true,\n        true,\n        void 0,\n        false\n      ),\n      [],\n      false,\n      false\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}],"names":["do"],"id":0},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, macroName;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    return this[\"debugger\"]();\n  };\n}.call(this));\n","options":{},"params":[{"type":"const","value":""}],"names":["debugger"],"id":14},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, label, macroName;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    label = _p2.label;\n    return this[\"continue\"](label);\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"label","asType":{"type":"choice","choices":[{"type":"ident","name":"Identifier"},{"type":"const","value":""}]}}],"names":["continue"],"id":15},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, label, macroName;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    label = _p2.label;\n    return this[\"break\"](label);\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"label","asType":{"type":"choice","choices":[{"type":"ident","name":"Identifier"},{"type":"const","value":""}]}}],"names":["break"],"id":16},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, func, ident, macroName;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    ident = _p2.ident;\n    func = _p2.func;\n    this[\"let\"](ident, false, this.type(func));\n    return this.block([\n      this[\"var\"](ident, false),\n      this.assign(ident, \"=\", func)\n    ]);\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"ident","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"func","asType":{"type":"ident","name":"FunctionDeclaration"}}],"names":["let"],"id":17},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, _this, body, elseBody, elseIfs, macroName, test;\n    _this = this;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    test = _p2.test;\n    body = _p2.body;\n    elseIfs = _p2.elseIfs;\n    elseBody = _p2.elseBody;\n    function dec(x) {\n      return x - 1;\n    }\n    function f(i, current) {\n      return i >= 0 && f(dec(i), _this[\"if\"](elseIfs[i].test, elseIfs[i].body, current)) || current;\n    }\n    return this[\"if\"](\n      macroName === \"unless\" && __node(\n        \"MacroAccess\",\n        2317,\n        2327,\n        3,\n        72,\n        {\n          op: \"not\",\n          node: __wrap(test, 23)\n        },\n        \"expression\",\n        false\n      ) || test,\n      body,\n      f(dec(elseIfs.length), elseBody)\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"test","asType":{"type":"ident","name":"Logic"}},{"type":"const","value":"then"},{"type":"ident","name":"body"},{"type":"ident","name":"elseIfs","asType":{"type":"many","multiplier":"*","inner":{"type":"sequence","items":[{"type":"const","value":"else"},{"type":"const","value":"if"},{"type":"ident","name":"test","asType":{"type":"ident","name":"Logic"}},{"type":"const","value":"then"},{"type":"ident","name":"body"}]}}},{"type":"ident","name":"elseBody","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"else"},{"type":"this"}]}}}],"names":["if","unless"],"id":18},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, _this, body, elseBody, elseIfs, macroName, test;\n    _this = this;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    test = _p2.test;\n    body = _p2.body;\n    elseIfs = _p2.elseIfs;\n    elseBody = _p2.elseBody;\n    function dec(x) {\n      return x - 1;\n    }\n    function f(i, current) {\n      if (i >= 0) {\n        return f(dec(i), _this[\"if\"](\n          elseIfs[i].type === \"unless\"\n            ? __node(\n              \"MacroAccess\",\n              2767,\n              2791,\n              3,\n              77,\n              {\n                op: \"not\",\n                node: __wrap(elseIfs[i].test, 28)\n              },\n              \"expression\",\n              false\n            )\n            : elseIfs[i].test,\n          elseIfs[i].body,\n          current\n        ));\n      } else {\n        return current;\n      }\n    }\n    return this[\"if\"](\n      macroName === \"unless\"\n        ? __node(\n          \"MacroAccess\",\n          2900,\n          2910,\n          3,\n          78,\n          {\n            op: \"not\",\n            node: __wrap(test, 26)\n          },\n          \"expression\",\n          false\n        )\n        : test,\n      body,\n      f(dec(elseIfs.length), elseBody)\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"test","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"elseIfs","asType":{"type":"many","multiplier":"*","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"else"},{"type":"ident","name":"type","asType":{"type":"choice","choices":[{"type":"const","value":"if"},{"type":"const","value":"unless"}]}},{"type":"ident","name":"test","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}},{"type":"ident","name":"elseBody","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"else"},{"type":"this","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}}],"names":["if","unless"],"id":19},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, _ref, _this, declarable, handle, macroName, numRealElements, value;\n    _this = this;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    declarable = _p2.declarable;\n    value = _p2.value;\n    function inc(x) {\n      return x + 1;\n    }\n    declarable = this.macroExpand1(declarable);\n    if (!declarable) {\n      throw Error(\"Unknown declarable: \" + String(declarable));\n    }\n    if (declarable.type === \"ident\") {\n      this[\"let\"](declarable.ident, declarable.isMutable, declarable.asType ? this.toType(declarable.asType) : this.type(value));\n      return this.block([\n        this[\"var\"](declarable.ident, declarable.isMutable),\n        this.mutateLast(\n          value || this.noop(),\n          function (n) {\n            return _this.assign(declarable.ident, \"=\", n);\n          },\n          true\n        )\n      ]);\n    } else if (declarable.type === \"array\") {\n      numRealElements = function (i, acc) {\n        if (i < declarable.elements.length) {\n          return numRealElements(inc(i), declarable.elements[i] ? inc(acc) : acc);\n        } else {\n          return acc;\n        }\n      };\n      if (numRealElements(0, 0) <= 1) {\n        handle = function (i) {\n          if (i < declarable.elements.length) {\n            if (declarable.elements[i]) {\n              return __node(\n                \"MacroAccess\",\n                5354,\n                5397,\n                29,\n                139,\n                {\n                  macroName: \"let\",\n                  macroData: {\n                    declarable: __node(\n                      \"MacroAccess\",\n                      5358,\n                      5384,\n                      28,\n                      139,\n                      __node(\n                        \"MacroAccess\",\n                        5358,\n                        5384,\n                        22,\n                        139,\n                        { ident: __wrap(declarable.elements[i], 35) },\n                        \"statement\",\n                        false\n                      ),\n                      \"statement\",\n                      false\n                    ),\n                    value: __node(\n                      \"Access\",\n                      5386,\n                      5397,\n                      __wrap(value, 35),\n                      __wrap(i, 35)\n                    )\n                  }\n                },\n                \"statement\",\n                false\n              );\n            } else {\n              return handle(inc(i));\n            }\n          } else {\n            return value;\n          }\n        };\n        return handle(0);\n      } else {\n        return this.maybeCache(value, function (setValue, value) {\n          function handle(i, currentValue, block) {\n            if (i < declarable.elements.length) {\n              if (declarable.elements[i]) {\n                block.push(__node(\n                  \"MacroAccess\",\n                  5719,\n                  5770,\n                  29,\n                  150,\n                  {\n                    macroName: \"let\",\n                    macroData: {\n                      declarable: __node(\n                        \"MacroAccess\",\n                        5723,\n                        5749,\n                        28,\n                        150,\n                        __node(\n                          \"MacroAccess\",\n                          5723,\n                          5749,\n                          22,\n                          150,\n                          { ident: __wrap(declarable.elements[i], 38) },\n                          \"statement\",\n                          false\n                        ),\n                        \"statement\",\n                        false\n                      ),\n                      value: __node(\n                        \"Access\",\n                        5751,\n                        5770,\n                        __wrap(currentValue, 38),\n                        __wrap(i, 38)\n                      )\n                    }\n                  },\n                  \"statement\",\n                  false\n                ));\n                return handle(inc(i), value, block);\n              } else {\n                return handle(inc(i), currentValue, block);\n              }\n            } else {\n              return _this.block(block);\n            }\n          }\n          return handle(0, setValue, []);\n        });\n      }\n    } else if (declarable.type === \"object\") {\n      if (declarable.pairs.length === 1) {\n        handle = function (pair) {\n          return __node(\n            \"MacroAccess\",\n            6079,\n            6119,\n            29,\n            160,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  6083,\n                  6097,\n                  28,\n                  160,\n                  __node(\n                    \"MacroAccess\",\n                    6083,\n                    6097,\n                    22,\n                    160,\n                    { ident: __wrap(pair.value, 40) },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\n                  \"Access\",\n                  6099,\n                  6119,\n                  __wrap(value, 40),\n                  __wrap(pair.key, 40)\n                )\n              }\n            },\n            \"statement\",\n            false\n          );\n        };\n        return handle(this.macroExpand1(declarable.pairs[0]));\n      } else {\n        return this.maybeCache(value, function (setValue, value) {\n          function handlePair(i, currentValue, pair, block) {\n            block.push(__node(\n              \"MacroAccess\",\n              6317,\n              6365,\n              29,\n              165,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    6321,\n                    6335,\n                    28,\n                    165,\n                    __node(\n                      \"MacroAccess\",\n                      6321,\n                      6335,\n                      22,\n                      165,\n                      { ident: __wrap(pair.value, 43) },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __node(\n                    \"Access\",\n                    6337,\n                    6365,\n                    __wrap(currentValue, 43),\n                    __wrap(pair.key, 43)\n                  )\n                }\n              },\n              \"statement\",\n              false\n            ));\n            return handle(inc(i), value, block);\n          }\n          function handle(i, currentValue, block) {\n            if (i < declarable.pairs.length) {\n              return handlePair(i, currentValue, _this.macroExpand1(declarable.pairs[i]), block);\n            } else {\n              return _this.block(block);\n            }\n          }\n          return handle(0, setValue, []);\n        });\n      }\n    } else {\n      throw Error(\"Unknown declarable \" + String(declarable) + \" \" + String(typeof declarable !== \"undefined\" && declarable !== null && (_ref = declarable.constructor) != null ? _ref.name : void 0));\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"declarable","asType":{"type":"ident","name":"Declarable"}},{"type":"const","value":"="},{"type":"ident","name":"value","asType":{"type":"ident","name":"ExpressionOrAssignment"}}],"names":["let"],"id":29},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, _this, macroName, node;\n    _this = this;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    node = _p2.node;\n    if (this.inGenerator) {\n      throw Error(\"Cannot use return in a generator function\");\n    }\n    if (node) {\n      return this.mutateLast(\n        node || this.noop(),\n        function (n) {\n          return _this[\"return\"](n);\n        },\n        true\n      );\n    } else {\n      return this[\"return\"]();\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"node","asType":{"type":"many","multiplier":"?","inner":{"type":"ident","name":"Expression"}}}],"names":["return"],"id":30},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, _this, macroName, node;\n    _this = this;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    node = _p2.node;\n    if (this.inGenerator) {\n      throw Error(\"Cannot use return in a generator function\");\n    }\n    return this.mutateLast(\n      node || this.noop(),\n      function (n) {\n        return _this.maybeCache(n, function (setN, n) {\n          return __node(\n            \"MacroAccess\",\n            7235,\n            7267,\n            19,\n            192,\n            {\n              macroName: \"if\",\n              macroData: {\n                test: __node(\n                  \"MacroAccess\",\n                  7237,\n                  7245,\n                  21,\n                  192,\n                  {\n                    op: \"?\",\n                    node: __wrap(setN, 50)\n                  },\n                  \"statement\",\n                  false\n                ),\n                body: __node(\n                  \"MacroAccess\",\n                  7258,\n                  7267,\n                  30,\n                  193,\n                  {\n                    macroName: \"return\",\n                    macroData: { node: __wrap(n, 50) }\n                  },\n                  \"statement\",\n                  false\n                ),\n                elseIfs: []\n              }\n            },\n            \"statement\",\n            false\n          );\n        });\n      },\n      true\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"node","asType":{"type":"ident","name":"Expression"}}],"names":["return?"],"id":31},{"code":"return (function () {\n  \"use strict\";\n  var __lt, __num, __typeof;\n  __lt = function (x, y) {\n    var type;\n    type = typeof x;\n    if (type !== \"number\" && type !== \"string\") {\n      throw TypeError(\"Cannot compare a non-number/string: \" + type);\n    } else if (type !== typeof y) {\n      throw TypeError(\"Cannot compare elements of different types: \" + type + \" vs \" + typeof y);\n    } else {\n      return x < y;\n    }\n  };\n  __num = function (num) {\n    if (typeof num !== \"number\") {\n      throw TypeError(\"Expected a number, got \" + __typeof(num));\n    } else {\n      return num;\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var _p2, _this, body, f, locals, macroName, params, values;\n    _this = this;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    locals = _p2.locals;\n    body = _p2.body;\n    params = [];\n    values = [];\n    if (locals) {\n      if (locals.ident) {\n        params.push(this.param(locals.ident));\n        values.push(locals.value);\n      }\n      f = function (i) {\n        if (__lt(i, locals.rest.length)) {\n          if (locals.rest[i].ident) {\n            params.push(_this.param(locals.rest[i].ident));\n            values.push(locals.rest[i].value);\n          }\n          return f(__num(i) + 1);\n        }\n      };\n      f(0);\n    }\n    return this.call(\n      this.func(params, body, true, true),\n      values\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"locals","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"ident","name":"ident","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":"="},{"type":"ident","name":"value"},{"type":"ident","name":"rest","asType":{"type":"many","multiplier":"*","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"ident","name":"ident","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":"="},{"type":"ident","name":"value"}]}}}]}}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}],"names":["do"],"id":91},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, body, func, macroName, node;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    node = _p2.node;\n    body = _p2.body;\n    func = __node(\n      \"Function\",\n      25739,\n      25747,\n      [],\n      __wrap(body, 184),\n      true,\n      false,\n      void 0,\n      false\n    );\n    return __node(\n      \"Call\",\n      25756,\n      25770,\n      __wrap(func, 182),\n      [__wrap(node, 182)],\n      false,\n      true\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"node","asType":{"type":"ident","name":"Expression"}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}],"names":["with"],"id":92},{"code":"return (function () {\n  \"use strict\";\n  var __strnum, __typeof;\n  __strnum = function (strnum) {\n    var type;\n    type = typeof strnum;\n    if (type === \"string\") {\n      return strnum;\n    } else if (type === \"number\") {\n      return String(strnum);\n    } else {\n      throw TypeError(\"Expected a string or number, got \" + __typeof(strnum));\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var _p2, arr, body, elseBody, init, loop, macroName, reducer, runElse, step, test;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    reducer = _p2.reducer;\n    init = _p2.init;\n    test = _p2.test;\n    step = _p2.step;\n    body = _p2.body;\n    elseBody = _p2.elseBody;\n    if (typeof init === \"undefined\" || init === null) {\n      init = this.noop();\n    }\n    if (typeof test === \"undefined\" || test === null) {\n      test = __node(\"Const\", 27325, 27330, true);\n    }\n    if (typeof step === \"undefined\" || step === null) {\n      step = this.noop();\n    }\n    if (reducer) {\n      if (reducer === \"first\") {\n        body = this.mutateLast(body || this.noop(), function (node) {\n          return __node(\n            \"MacroAccess\",\n            27454,\n            27467,\n            30,\n            871,\n            {\n              macroName: \"return\",\n              macroData: { node: __wrap(node, 198) }\n            },\n            \"statement\",\n            false\n          );\n        });\n        loop = this[\"for\"](init, test, step, body);\n        return __node(\n          \"MacroAccess\",\n          27529,\n          27569,\n          0,\n          873,\n          {\n            macroName: \"do\",\n            macroData: {\n              body: __node(\n                \"Block\",\n                27533,\n                27569,\n                [\n                  __wrap(loop, 197),\n                  __wrap(elseBody, 197)\n                ],\n                null\n              )\n            }\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        if (elseBody) {\n          throw Error(\"Cannot use a for loop with an else with \" + __strnum(reducer));\n        }\n        if (reducer === \"some\") {\n          body = this.mutateLast(body || this.noop(), function (node) {\n            return __node(\n              \"MacroAccess\",\n              27780,\n              27814,\n              19,\n              881,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __wrap(node, 200),\n                  body: __node(\n                    \"MacroAccess\",\n                    27803,\n                    27814,\n                    30,\n                    882,\n                    {\n                      macroName: \"return\",\n                      macroData: { node: __node(\"Const\", 27809, 27814, true) }\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  elseIfs: []\n                }\n              },\n              \"statement\",\n              false\n            );\n          });\n          loop = [\n            this[\"for\"](init, test, step, body),\n            __node(\n              \"MacroAccess\",\n              27871,\n              27884,\n              30,\n              883,\n              {\n                macroName: \"return\",\n                macroData: { node: __node(\"Const\", 27878, 27884, false) }\n              },\n              \"statement\",\n              false\n            )\n          ];\n          return __node(\n            \"MacroAccess\",\n            27901,\n            27922,\n            0,\n            884,\n            {\n              macroName: \"do\",\n              macroData: { body: __wrap(loop, 197) }\n            },\n            \"expression\",\n            false\n          );\n        } else if (reducer === \"every\") {\n          body = this.mutateLast(body || this.noop(), function (node) {\n            return __node(\n              \"MacroAccess\",\n              28032,\n              28071,\n              19,\n              888,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __node(\n                    \"MacroAccess\",\n                    28034,\n                    28044,\n                    3,\n                    888,\n                    {\n                      op: \"not\",\n                      node: __wrap(node, 202)\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  body: __node(\n                    \"MacroAccess\",\n                    28059,\n                    28071,\n                    30,\n                    889,\n                    {\n                      macroName: \"return\",\n                      macroData: { node: __node(\"Const\", 28065, 28071, false) }\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  elseIfs: []\n                }\n              },\n              \"statement\",\n              false\n            );\n          });\n          loop = [\n            this[\"for\"](init, test, step, body),\n            __node(\n              \"MacroAccess\",\n              28128,\n              28140,\n              30,\n              890,\n              {\n                macroName: \"return\",\n                macroData: { node: __node(\"Const\", 28135, 28140, true) }\n              },\n              \"statement\",\n              false\n            )\n          ];\n          return __node(\n            \"MacroAccess\",\n            28157,\n            28178,\n            0,\n            891,\n            {\n              macroName: \"do\",\n              macroData: { body: __wrap(loop, 197) }\n            },\n            \"expression\",\n            false\n          );\n        } else {\n          throw Error(\"Unknown reducer: \" + __strnum(reducer));\n        }\n      }\n    } else if (elseBody) {\n      if (this.position === \"expression\") {\n        throw Error(\"Cannot use a for loop with an else as an expression\");\n      }\n      runElse = this.tmp(\"else\", false, \"boolean\");\n      body = __node(\n        \"Block\",\n        28441,\n        28481,\n        [\n          __node(\n            \"Assign\",\n            28449,\n            28467,\n            __wrap(runElse, 197),\n            \"=\",\n            __node(\"Const\", 28461, 28467, false)\n          ),\n          __wrap(body, 197)\n        ],\n        null\n      );\n      init = __node(\n        \"Block\",\n        28500,\n        28539,\n        [\n          __node(\n            \"Assign\",\n            28508,\n            28525,\n            __wrap(runElse, 197),\n            \"=\",\n            __node(\"Const\", 28520, 28525, true)\n          ),\n          __wrap(init, 197)\n        ],\n        null\n      );\n      loop = this[\"for\"](init, test, step, body);\n      return __node(\n        \"Block\",\n        28596,\n        28651,\n        [\n          __wrap(loop, 197),\n          __node(\n            \"MacroAccess\",\n            28618,\n            28651,\n            19,\n            908,\n            {\n              macroName: \"if\",\n              macroData: {\n                test: __wrap(runElse, 197),\n                body: __wrap(elseBody, 197),\n                elseIfs: []\n              }\n            },\n            \"statement\",\n            false\n          )\n        ],\n        null\n      );\n    } else if (this.position === \"expression\") {\n      arr = this.tmp(\"arr\", false, this.type(body).array());\n      body = this.mutateLast(body || this.noop(), function (node) {\n        return __node(\n          \"Call\",\n          28803,\n          28819,\n          __node(\n            \"Access\",\n            28803,\n            28819,\n            __wrap(arr, 207),\n            __node(\"Const\", 28809, 28813, \"push\")\n          ),\n          [__wrap(node, 207)],\n          false,\n          false\n        );\n      });\n      init = __node(\n        \"Block\",\n        28839,\n        28871,\n        [\n          __node(\n            \"Assign\",\n            28847,\n            28857,\n            __wrap(arr, 197),\n            \"=\",\n            __node(\"Array\", 28854, 28857, [])\n          ),\n          __wrap(init, 197)\n        ],\n        null\n      );\n      loop = this[\"for\"](init, test, step, body);\n      return __node(\n        \"Block\",\n        28928,\n        28954,\n        [\n          __wrap(loop, 197),\n          __wrap(arr, 197)\n        ],\n        null\n      );\n    } else {\n      return this[\"for\"](init, test, step, body);\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"reducer","asType":{"type":"many","multiplier":"?","inner":{"type":"choice","choices":[{"type":"const","value":"every"},{"type":"const","value":"some"},{"type":"const","value":"first"}]}}},{"type":"ident","name":"init","asType":{"type":"choice","choices":[{"type":"ident","name":"ExpressionOrAssignment"},{"type":"const","value":""}]}},{"type":"const","value":";"},{"type":"ident","name":"test","asType":{"type":"choice","choices":[{"type":"ident","name":"Logic"},{"type":"const","value":""}]}},{"type":"const","value":";"},{"type":"ident","name":"step","asType":{"type":"choice","choices":[{"type":"ident","name":"ExpressionOrAssignment"},{"type":"const","value":""}]}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"elseBody","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"else"},{"type":"this","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}}],"names":["for"],"id":95},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, body, current, currentStart, init, macroName, step, test;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    init = _p2.init;\n    test = _p2.test;\n    step = _p2.step;\n    current = _p2.current;\n    currentStart = _p2.currentStart;\n    body = _p2.body;\n    if (typeof init === \"undefined\" || init === null) {\n      init = this.noop();\n    }\n    if (typeof test === \"undefined\" || test === null) {\n      test = __node(\"Const\", 29226, 29231, true);\n    }\n    if (typeof step === \"undefined\" || step === null) {\n      step = this.noop();\n    }\n    body = this.mutateLast(body || this.noop(), function (node) {\n      return __node(\n        \"Assign\",\n        29315,\n        29333,\n        __wrap(current, 210),\n        \"=\",\n        __wrap(node, 210)\n      );\n    });\n    return __node(\n      \"Block\",\n      29343,\n      29445,\n      [\n        __node(\n          \"MacroAccess\",\n          29349,\n          29386,\n          29,\n          930,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                29352,\n                29369,\n                28,\n                930,\n                __node(\n                  \"MacroAccess\",\n                  29352,\n                  29369,\n                  22,\n                  930,\n                  {\n                    isMutable: \"mutable\",\n                    ident: __wrap(current, 209)\n                  },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __wrap(currentStart, 209)\n            }\n          },\n          \"statement\",\n          false\n        ),\n        __node(\n          \"MacroAccess\",\n          29393,\n          29430,\n          95,\n          931,\n          {\n            macroName: \"for\",\n            macroData: {\n              init: __wrap(init, 209),\n              test: __wrap(test, 209),\n              step: __wrap(step, 209),\n              body: __wrap(body, 209)\n            }\n          },\n          \"statement\",\n          false\n        ),\n        __wrap(current, 209)\n      ],\n      null\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"const","value":"reduce"},{"type":"ident","name":"init","asType":{"type":"choice","choices":[{"type":"ident","name":"Expression"},{"type":"const","value":""}]}},{"type":"const","value":";"},{"type":"ident","name":"test","asType":{"type":"choice","choices":[{"type":"ident","name":"Logic"},{"type":"const","value":""}]}},{"type":"const","value":";"},{"type":"ident","name":"step","asType":{"type":"choice","choices":[{"type":"ident","name":"Statement"},{"type":"const","value":""}]}},{"type":"const","value":","},{"type":"ident","name":"current","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":"="},{"type":"ident","name":"currentStart"},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}],"names":["for"],"id":96},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, body, elseBody, macroName, reducer, step, test;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    reducer = _p2.reducer;\n    test = _p2.test;\n    step = _p2.step;\n    body = _p2.body;\n    elseBody = _p2.elseBody;\n    if (macroName === \"until\") {\n      test = __node(\n        \"MacroAccess\",\n        29738,\n        29748,\n        3,\n        938,\n        {\n          op: \"not\",\n          node: __wrap(test, 211)\n        },\n        \"expression\",\n        false\n      );\n    }\n    if (reducer === \"every\") {\n      return __node(\n        \"MacroAccess\",\n        29789,\n        29858,\n        95,\n        941,\n        {\n          macroName: \"for\",\n          macroData: {\n            reducer: \"every\",\n            test: __wrap(test, 211),\n            step: __wrap(step, 211),\n            body: __wrap(body, 211),\n            elseBody: __wrap(elseBody, 211)\n          }\n        },\n        \"expression\",\n        false\n      );\n    } else if (reducer === \"some\") {\n      return __node(\n        \"MacroAccess\",\n        29898,\n        29966,\n        95,\n        946,\n        {\n          macroName: \"for\",\n          macroData: {\n            reducer: \"some\",\n            test: __wrap(test, 211),\n            step: __wrap(step, 211),\n            body: __wrap(body, 211),\n            elseBody: __wrap(elseBody, 211)\n          }\n        },\n        \"expression\",\n        false\n      );\n    } else if (reducer === \"first\") {\n      return __node(\n        \"MacroAccess\",\n        30007,\n        30076,\n        95,\n        951,\n        {\n          macroName: \"for\",\n          macroData: {\n            reducer: \"first\",\n            test: __wrap(test, 211),\n            step: __wrap(step, 211),\n            body: __wrap(body, 211),\n            elseBody: __wrap(elseBody, 211)\n          }\n        },\n        \"expression\",\n        false\n      );\n    } else if (this.position === \"expression\") {\n      return __node(\n        \"MacroAccess\",\n        30124,\n        30187,\n        95,\n        956,\n        {\n          macroName: \"for\",\n          macroData: {\n            test: __wrap(test, 211),\n            step: __wrap(step, 211),\n            body: __wrap(body, 211),\n            elseBody: __wrap(elseBody, 211)\n          }\n        },\n        \"expression\",\n        false\n      );\n    } else {\n      return __node(\n        \"MacroAccess\",\n        30215,\n        30283,\n        95,\n        962,\n        {\n          macroName: \"for\",\n          macroData: {\n            test: __wrap(test, 211),\n            step: __wrap(step, 211),\n            body: __wrap(body, 211),\n            elseBody: __wrap(elseBody, 211)\n          }\n        },\n        \"statement\",\n        false\n      );\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"reducer","asType":{"type":"many","multiplier":"?","inner":{"type":"choice","choices":[{"type":"const","value":"every"},{"type":"const","value":"some"},{"type":"const","value":"first"}]}}},{"type":"ident","name":"test","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"step","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"ExpressionOrAssignment"}}]}}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"elseBody","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"else"},{"type":"this","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}}],"names":["while","until"],"id":97},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, body, current, currentStart, macroName, step, test;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    test = _p2.test;\n    step = _p2.step;\n    current = _p2.current;\n    currentStart = _p2.currentStart;\n    body = _p2.body;\n    if (macroName === \"until\") {\n      test = __node(\n        \"MacroAccess\",\n        30505,\n        30515,\n        3,\n        969,\n        {\n          op: \"not\",\n          node: __wrap(test, 212)\n        },\n        \"expression\",\n        false\n      );\n    }\n    return __node(\n      \"MacroAccess\",\n      30535,\n      30601,\n      96,\n      972,\n      {\n        macroName: \"for\",\n        macroData: {\n          test: __wrap(test, 212),\n          step: __wrap(step, 212),\n          current: __wrap(current, 212),\n          currentStart: __wrap(currentStart, 212),\n          body: __wrap(body, 212)\n        }\n      },\n      \"statement\",\n      false\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"const","value":"reduce"},{"type":"ident","name":"test","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"step","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"ExpressionOrAssignment"}}]}}},{"type":"const","value":","},{"type":"ident","name":"current","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":"="},{"type":"ident","name":"currentStart"},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}],"names":["while","until"],"id":98},{"code":"return (function () {\n  \"use strict\";\n  var __num, __typeof;\n  __num = function (num) {\n    if (typeof num !== \"number\") {\n      throw TypeError(\"Expected a number, got \" + __typeof(num));\n    } else {\n      return num;\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var _p2, _ref, _ref2, args, array, body, elseBody, end, func, hasIndex, hasLength, inclusive, increment, index, init, isString, length, letIndex, letLength, letValue, macroName, reducer, start, step, test, tmp, value, valueExpr, valueIdent;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    reducer = _p2.reducer;\n    value = _p2.value;\n    index = _p2.index;\n    array = _p2.array;\n    body = _p2.body;\n    elseBody = _p2.elseBody;\n    value = this.macroExpand1(value);\n    length = null;\n    if (index) {\n      length = index.length;\n      index = index.value;\n    }\n    if (this.isCall(array) && this.isIdent(this.callFunc(array)) && this.name(this.callFunc(array)) === \"__toArray\" && !this.callIsApply(array)) {\n      array = this.callArgs(array)[0];\n    }\n    if (this.isCall(array) && this.isIdent(this.callFunc(array)) && this.name(this.callFunc(array)) === \"__range\" && !this.callIsApply(array)) {\n      if (this.isArray(value) || this.isObject(value)) {\n        throw Error(\"Cannot assign a number to a complex declarable\");\n      }\n      value = value.ident;\n      start = (_ref = this.callArgs(array))[0];\n      end = _ref[1];\n      step = _ref[2];\n      inclusive = _ref[3];\n      init = [];\n      if (this.isConst(start)) {\n        if (typeof this.value(start) !== \"number\") {\n          throw Error(\"Cannot start with a non-number: #(@value start)\");\n        }\n      } else {\n        start = __node(\n          \"MacroAccess\",\n          34551,\n          34559,\n          47,\n          1087,\n          {\n            op: \"+\",\n            node: __wrap(start, 228)\n          },\n          \"expression\",\n          false\n        );\n      }\n      init.push(this.macroExpandAll(__node(\n        \"MacroAccess\",\n        34597,\n        34625,\n        29,\n        1088,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              34601,\n              34616,\n              28,\n              1088,\n              __node(\n                \"MacroAccess\",\n                34601,\n                34616,\n                22,\n                1088,\n                {\n                  isMutable: \"mutable\",\n                  ident: __wrap(value, 228)\n                },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __wrap(start, 228)\n          }\n        },\n        \"statement\",\n        false\n      )));\n      if (this.isConst(end)) {\n        if (typeof this.value(end) !== \"number\") {\n          throw Error(\"Cannot end with a non-number: #(@value start)\");\n        }\n      } else if (this.isComplex(end)) {\n        end = this.cache(\n          __node(\n            \"MacroAccess\",\n            34820,\n            34826,\n            47,\n            1094,\n            {\n              op: \"+\",\n              node: __wrap(end, 228)\n            },\n            \"expression\",\n            false\n          ),\n          init,\n          \"end\",\n          false\n        );\n      } else {\n        init.push(__node(\n          \"MacroAccess\",\n          34880,\n          34886,\n          47,\n          1096,\n          {\n            op: \"+\",\n            node: __wrap(end, 228)\n          },\n          \"expression\",\n          false\n        ));\n      }\n      if (this.isConst(step)) {\n        if (typeof this.value(step) !== \"number\") {\n          throw Error(\"Cannot step with a non-number: #(@value step)\");\n        }\n      } else if (this.isComplex(step)) {\n        step = this.cache(\n          __node(\n            \"MacroAccess\",\n            35085,\n            35092,\n            47,\n            1102,\n            {\n              op: \"+\",\n              node: __wrap(step, 228)\n            },\n            \"expression\",\n            false\n          ),\n          init,\n          \"step\",\n          false\n        );\n      } else {\n        init.push(__node(\n          \"MacroAccess\",\n          35147,\n          35154,\n          47,\n          1104,\n          {\n            op: \"+\",\n            node: __wrap(step, 228)\n          },\n          \"expression\",\n          false\n        ));\n      }\n      if (this.isComplex(inclusive)) {\n        inclusive = this.cache(\n          __wrap(inclusive, 228),\n          init,\n          \"incl\",\n          false\n        );\n      }\n      if (this.isConst(step)) {\n        if (__num(this.value(step)) > 0) {\n          if (this.isConst(end) && this.value(end) === 1/0) {\n            test = __node(\"Const\", 35399, 35404, true);\n          } else {\n            test = __node(\n              \"MacroAccess\",\n              35436,\n              35491,\n              18,\n              1114,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __wrap(inclusive, 228),\n                  body: __node(\n                    \"MacroAccess\",\n                    35455,\n                    35471,\n                    9,\n                    1114,\n                    {\n                      left: __wrap(value, 228),\n                      inverted: false,\n                      op: \"~<=\",\n                      right: __wrap(end, 228)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  elseIfs: [],\n                  elseBody: __node(\n                    \"MacroAccess\",\n                    35476,\n                    35491,\n                    9,\n                    1114,\n                    {\n                      left: __wrap(value, 228),\n                      inverted: false,\n                      op: \"~<\",\n                      right: __wrap(end, 228)\n                    },\n                    \"expression\",\n                    false\n                  )\n                }\n              },\n              \"expression\",\n              false\n            );\n          }\n        } else if (this.isConst(end) && this.value(end) === -1/0) {\n          test = __node(\"Const\", 35578, 35583, true);\n        } else {\n          test = __node(\n            \"MacroAccess\",\n            35615,\n            35670,\n            18,\n            1119,\n            {\n              macroName: \"if\",\n              macroData: {\n                test: __wrap(inclusive, 228),\n                body: __node(\n                  \"MacroAccess\",\n                  35634,\n                  35650,\n                  10,\n                  1119,\n                  {\n                    left: __wrap(value, 228),\n                    inverted: false,\n                    op: \"~>=\",\n                    right: __wrap(end, 228)\n                  },\n                  \"expression\",\n                  false\n                ),\n                elseIfs: [],\n                elseBody: __node(\n                  \"MacroAccess\",\n                  35655,\n                  35670,\n                  10,\n                  1119,\n                  {\n                    left: __wrap(value, 228),\n                    inverted: false,\n                    op: \"~>\",\n                    right: __wrap(end, 228)\n                  },\n                  \"expression\",\n                  false\n                )\n              }\n            },\n            \"expression\",\n            false\n          );\n        }\n      } else {\n        test = __node(\n          \"MacroAccess\",\n          35694,\n          35851,\n          19,\n          1121,\n          {\n            macroName: \"if\",\n            macroData: {\n              test: __node(\n                \"MacroAccess\",\n                35697,\n                35708,\n                10,\n                1121,\n                {\n                  left: __wrap(step, 228),\n                  inverted: false,\n                  op: \"~>\",\n                  right: __node(\"Const\", 35707, 35708, 0)\n                },\n                \"expression\",\n                false\n              ),\n              body: __node(\n                \"MacroAccess\",\n                35719,\n                35773,\n                18,\n                1122,\n                {\n                  macroName: \"if\",\n                  macroData: {\n                    test: __wrap(inclusive, 228),\n                    body: __node(\n                      \"MacroAccess\",\n                      35737,\n                      35753,\n                      9,\n                      1122,\n                      {\n                        left: __wrap(value, 228),\n                        inverted: false,\n                        op: \"~<=\",\n                        right: __wrap(end, 228)\n                      },\n                      \"expression\",\n                      false\n                    ),\n                    elseIfs: [],\n                    elseBody: __node(\n                      \"MacroAccess\",\n                      35758,\n                      35773,\n                      9,\n                      1122,\n                      {\n                        left: __wrap(value, 228),\n                        inverted: false,\n                        op: \"~<\",\n                        right: __wrap(end, 228)\n                      },\n                      \"expression\",\n                      false\n                    )\n                  }\n                },\n                \"statement\",\n                false\n              ),\n              elseIfs: [],\n              elseBody: __node(\n                \"MacroAccess\",\n                35797,\n                35851,\n                18,\n                1124,\n                {\n                  macroName: \"if\",\n                  macroData: {\n                    test: __wrap(inclusive, 228),\n                    body: __node(\n                      \"MacroAccess\",\n                      35815,\n                      35831,\n                      10,\n                      1124,\n                      {\n                        left: __wrap(value, 228),\n                        inverted: false,\n                        op: \"~>=\",\n                        right: __wrap(end, 228)\n                      },\n                      \"expression\",\n                      false\n                    ),\n                    elseIfs: [],\n                    elseBody: __node(\n                      \"MacroAccess\",\n                      35836,\n                      35851,\n                      10,\n                      1124,\n                      {\n                        left: __wrap(value, 228),\n                        inverted: false,\n                        op: \"~>\",\n                        right: __wrap(end, 228)\n                      },\n                      \"expression\",\n                      false\n                    )\n                  }\n                },\n                \"statement\",\n                false\n              )\n            }\n          },\n          \"expression\",\n          false\n        );\n      }\n      increment = __node(\n        \"MacroAccess\",\n        35891,\n        35908,\n        41,\n        1126,\n        {\n          left: __wrap(value, 228),\n          op: \"~+=\",\n          right: __wrap(step, 228)\n        },\n        \"expression\",\n        false\n      );\n      if (length) {\n        init.push(this.macroExpandAll(__node(\n          \"MacroAccess\",\n          35969,\n          36091,\n          29,\n          1129,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                35973,\n                35981,\n                28,\n                1129,\n                __node(\n                  \"MacroAccess\",\n                  35973,\n                  35981,\n                  22,\n                  1129,\n                  { ident: __wrap(length, 228) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __node(\n                \"MacroAccess\",\n                35983,\n                36091,\n                19,\n                1129,\n                {\n                  macroName: \"if\",\n                  macroData: {\n                    test: __wrap(inclusive, 228),\n                    body: __node(\n                      \"MacroAccess\",\n                      36008,\n                      36042,\n                      34,\n                      1130,\n                      {\n                        left: __node(\n                          \"MacroAccess\",\n                          36009,\n                          36032,\n                          38,\n                          1130,\n                          {\n                            left: __node(\n                              \"MacroAccess\",\n                              36009,\n                              36032,\n                              38,\n                              1130,\n                              {\n                                left: __wrap(end, 228),\n                                inverted: false,\n                                op: \"~-\",\n                                right: __wrap(start, 228)\n                              },\n                              \"expression\",\n                              false\n                            ),\n                            inverted: false,\n                            op: \"~+\",\n                            right: __wrap(step, 228)\n                          },\n                          \"expression\",\n                          false\n                        ),\n                        inverted: false,\n                        op: \"~\\\\\",\n                        right: __wrap(step, 228)\n                      },\n                      \"statement\",\n                      false\n                    ),\n                    elseIfs: [],\n                    elseBody: __node(\n                      \"MacroAccess\",\n                      36066,\n                      36091,\n                      34,\n                      1132,\n                      {\n                        left: __node(\n                          \"MacroAccess\",\n                          36067,\n                          36081,\n                          38,\n                          1132,\n                          {\n                            left: __wrap(end, 228),\n                            inverted: false,\n                            op: \"~-\",\n                            right: __wrap(start, 228)\n                          },\n                          \"expression\",\n                          false\n                        ),\n                        inverted: false,\n                        op: \"~\\\\\",\n                        right: __wrap(step, 228)\n                      },\n                      \"statement\",\n                      false\n                    )\n                  }\n                },\n                \"expression\",\n                false\n              )\n            }\n          },\n          \"statement\",\n          false\n        )));\n      }\n      if (index) {\n        init.push(this.macroExpandAll(__node(\n          \"MacroAccess\",\n          36151,\n          36174,\n          29,\n          1135,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                36155,\n                36170,\n                28,\n                1135,\n                __node(\n                  \"MacroAccess\",\n                  36155,\n                  36170,\n                  22,\n                  1135,\n                  {\n                    isMutable: \"mutable\",\n                    ident: __wrap(index, 228)\n                  },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __node(\"Const\", 36173, 36174, 0)\n            }\n          },\n          \"statement\",\n          false\n        )));\n        increment = __node(\n          \"Block\",\n          36200,\n          36242,\n          [\n            __wrap(increment, 228),\n            __node(\n              \"MacroAccess\",\n              36231,\n              36242,\n              90,\n              1138,\n              {\n                left: __wrap(index, 228),\n                op: \"+=\",\n                right: __node(\"Const\", 36241, 36242, 1)\n              },\n              \"statement\",\n              false\n            )\n          ],\n          null\n        );\n        if (this.hasFunc(body)) {\n          func = this.tmp(\"f\", false, \"function\");\n          init.push(__node(\n            \"MacroAccess\",\n            36341,\n            36380,\n            29,\n            1141,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  36345,\n                  36351,\n                  28,\n                  1141,\n                  __node(\n                    \"MacroAccess\",\n                    36345,\n                    36351,\n                    22,\n                    1141,\n                    { ident: __wrap(func, 228) },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\n                  \"Function\",\n                  36355,\n                  36380,\n                  [\n                    __node(\n                      \"Param\",\n                      36356,\n                      36362,\n                      __wrap(value, 234),\n                      void 0,\n                      false,\n                      false,\n                      void 0\n                    ),\n                    __node(\n                      \"Param\",\n                      36363,\n                      36370,\n                      __wrap(index, 234),\n                      void 0,\n                      false,\n                      false,\n                      void 0\n                    )\n                  ],\n                  __wrap(body, 234),\n                  true,\n                  false,\n                  void 0,\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          ));\n          body = __node(\n            \"Call\",\n            36405,\n            36434,\n            __wrap(func, 228),\n            [\n              __node(\"This\", 36413, 36417),\n              __wrap(value, 228),\n              __wrap(index, 228)\n            ],\n            false,\n            true\n          );\n        }\n      } else if (this.hasFunc(body)) {\n        func = this.tmp(\"f\", false, \"function\");\n        init.push(__node(\n          \"MacroAccess\",\n          36533,\n          36564,\n          29,\n          1145,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                36537,\n                36543,\n                28,\n                1145,\n                __node(\n                  \"MacroAccess\",\n                  36537,\n                  36543,\n                  22,\n                  1145,\n                  { ident: __wrap(func, 228) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __node(\n                \"Function\",\n                36547,\n                36564,\n                [\n                  __node(\n                    \"Param\",\n                    36548,\n                    36554,\n                    __wrap(value, 237),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  )\n                ],\n                __wrap(body, 237),\n                true,\n                false,\n                void 0,\n                false\n              )\n            }\n          },\n          \"statement\",\n          false\n        ));\n        body = __node(\n          \"Call\",\n          36587,\n          36608,\n          __wrap(func, 228),\n          [\n            __node(\"This\", 36595, 36599),\n            __wrap(value, 228)\n          ],\n          false,\n          true\n        );\n      }\n      if (reducer === \"every\") {\n        return __node(\n          \"MacroAccess\",\n          36654,\n          36739,\n          95,\n          1149,\n          {\n            macroName: \"for\",\n            macroData: {\n              reducer: \"every\",\n              init: __wrap(init, 228),\n              test: __wrap(test, 228),\n              step: __wrap(increment, 228),\n              body: __wrap(body, 228),\n              elseBody: __wrap(elseBody, 228)\n            }\n          },\n          \"expression\",\n          false\n        );\n      } else if (reducer === \"some\") {\n        return __node(\n          \"MacroAccess\",\n          36783,\n          36867,\n          95,\n          1154,\n          {\n            macroName: \"for\",\n            macroData: {\n              reducer: \"some\",\n              init: __wrap(init, 228),\n              test: __wrap(test, 228),\n              step: __wrap(increment, 228),\n              body: __wrap(body, 228),\n              elseBody: __wrap(elseBody, 228)\n            }\n          },\n          \"expression\",\n          false\n        );\n      } else if (reducer === \"first\") {\n        return __node(\n          \"MacroAccess\",\n          36912,\n          36997,\n          95,\n          1159,\n          {\n            macroName: \"for\",\n            macroData: {\n              reducer: \"first\",\n              init: __wrap(init, 228),\n              test: __wrap(test, 228),\n              step: __wrap(increment, 228),\n              body: __wrap(body, 228),\n              elseBody: __wrap(elseBody, 228)\n            }\n          },\n          \"expression\",\n          false\n        );\n      } else if (reducer === \"filter\") {\n        body = this.mutateLast(body, function (node) {\n          return __node(\n            \"MacroAccess\",\n            37087,\n            37115,\n            19,\n            1165,\n            {\n              macroName: \"if\",\n              macroData: {\n                test: __wrap(node, 238),\n                body: __wrap(value, 238),\n                elseIfs: []\n              }\n            },\n            \"statement\",\n            false\n          );\n        });\n        return __node(\n          \"MacroAccess\",\n          37128,\n          37207,\n          95,\n          1167,\n          {\n            macroName: \"for\",\n            macroData: {\n              init: __wrap(init, 228),\n              test: __wrap(test, 228),\n              step: __wrap(increment, 228),\n              body: __wrap(body, 228),\n              elseBody: __wrap(elseBody, 228)\n            }\n          },\n          \"expression\",\n          false\n        );\n      } else if (this.position === \"expression\") {\n        return __node(\n          \"MacroAccess\",\n          37260,\n          37339,\n          95,\n          1172,\n          {\n            macroName: \"for\",\n            macroData: {\n              init: __wrap(init, 228),\n              test: __wrap(test, 228),\n              step: __wrap(increment, 228),\n              body: __wrap(body, 228),\n              elseBody: __wrap(elseBody, 228)\n            }\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        return __node(\n          \"MacroAccess\",\n          37373,\n          37457,\n          95,\n          1178,\n          {\n            macroName: \"for\",\n            macroData: {\n              init: __wrap(init, 228),\n              test: __wrap(test, 228),\n              step: __wrap(increment, 228),\n              body: __wrap(body, 228),\n              elseBody: __wrap(elseBody, 228)\n            }\n          },\n          \"statement\",\n          false\n        );\n      }\n    } else {\n      init = [];\n      isString = this.isType(array, \"string\");\n      hasIndex = typeof index !== \"undefined\" && index !== null;\n      if (typeof index === \"undefined\" || index === null) {\n        index = this.tmp(\"i\", false, \"number\");\n      }\n      hasLength = length != null;\n      if (length == null) {\n        length = this.tmp(\"len\", false, \"number\");\n      }\n      this.macroExpandAll(__node(\n        \"MacroAccess\",\n        37717,\n        37733,\n        29,\n        1191,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              37721,\n              37729,\n              28,\n              1191,\n              __node(\n                \"MacroAccess\",\n                37721,\n                37729,\n                22,\n                1191,\n                { ident: __wrap(length, 228) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\"Const\", 37732, 37733, 0)\n          }\n        },\n        \"statement\",\n        false\n      ));\n      array = this.macroExpandAll(array);\n      step = __node(\"Const\", 37818, 37819, 1);\n      start = __node(\"Const\", 37851, 37852, 0);\n      end = __node(\"Const\", 37881, 37890, 1/0);\n      inclusive = __node(\"Const\", 37925, 37931, false);\n      if (this.isCall(array) && this.isIdent(this.callFunc(array))) {\n        if (this.name(this.callFunc(array)) === \"__step\" && !this.callIsApply(array)) {\n          args = this.callArgs(array);\n          array = args[0];\n          step = args[1];\n          if (this.isConst(step)) {\n            if (__num(this.value(step)) >= 0) {\n              start = __node(\"Const\", 38249, 38250, 0);\n              end = __node(\"Const\", 38276, 38285, 1/0);\n            } else {\n              start = __node(\"Const\", 38330, 38339, 1/0);\n              end = __node(\"Const\", 38366, 38367, 0);\n            }\n          } else {\n            start = void 0;\n            end = void 0;\n          }\n          inclusive = __node(\"Const\", 38460, 38465, true);\n        } else if (this.name(this.callFunc(array)) === \"__slice\" && this.callIsApply(array)) {\n          args = this.callArgs(array);\n          array = args[0];\n          start = args[1];\n          end = args[2];\n          if (this.isConst(end) && this.value(end) === void 0) {\n            end = __node(\"Const\", 38738, 38747, 1/0);\n          }\n        } else if (this.name(this.callFunc(array)) === \"__sliceStep\" && !this.callIsApply(array)) {\n          args = this.callArgs(array);\n          array = args[0];\n          start = args[1];\n          end = args[2];\n          step = args[3];\n          inclusive = args[4];\n        }\n      }\n      if (this.isConst(step)) {\n        if (typeof this.value(step) !== \"number\" || __num(this.value(step)) % 1 !== 0) {\n          throw Error(\"Expected step to be an integer, got \" + typeof this.value(step) + \" (\" + String(this.value(step)) + \")\");\n        } else if (this.value(step) === 0) {\n          throw Error(\"Step must be non-zero\");\n        }\n      }\n      if (start && this.isConst(start) && this.value(start) !== 1/0 && (typeof this.value(start) !== \"number\" || __num(this.value(start)) % 1 !== 0)) {\n        throw Error(\"Expected start to be an integer, got \" + typeof this.value(start) + \" (\" + String(this.value(start)) + \")\");\n      }\n      if (end && this.isConst(end) && this.value(end) !== 1/0 && (typeof this.value(end) !== \"number\" || __num(this.value(end)) % 1 !== 0)) {\n        throw Error(\"Expected end to be an integer or Infinity, got \" + typeof this.value(end) + \" (\" + String(this.value(end)) + \")\");\n      }\n      if (!isString && !this.isType(array, \"arrayLike\")) {\n        array = __node(\n          \"Call\",\n          39852,\n          39870,\n          __node(\"Ident\", 39852, 39863, \"__toArray\"),\n          [__wrap(array, 228)],\n          false,\n          false\n        );\n      }\n      array = this.cache(\n        array,\n        init,\n        isString ? \"str\" : \"arr\",\n        false\n      );\n      valueExpr = __node(\n        \"MacroAccess\",\n        39980,\n        40042,\n        18,\n        1243,\n        {\n          macroName: \"if\",\n          macroData: {\n            test: __wrap(isString, 228),\n            body: __node(\n              \"Call\",\n              39999,\n              40022,\n              __node(\n                \"Access\",\n                39999,\n                40022,\n                __wrap(array, 228),\n                __node(\"Const\", 40007, 40014, \"charAt\")\n              ),\n              [__wrap(index, 228)],\n              false,\n              false\n            ),\n            elseIfs: [],\n            elseBody: __node(\n              \"Access\",\n              40027,\n              40042,\n              __wrap(array, 228),\n              __wrap(index, 228)\n            )\n          }\n        },\n        \"expression\",\n        false\n      );\n      letIndex = this.macroExpandAll(__node(\n        \"MacroAccess\",\n        40086,\n        40109,\n        29,\n        1244,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              40090,\n              40105,\n              28,\n              1244,\n              __node(\n                \"MacroAccess\",\n                40090,\n                40105,\n                22,\n                1244,\n                {\n                  isMutable: \"mutable\",\n                  ident: __wrap(index, 228)\n                },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\"Const\", 40108, 40109, 0)\n          }\n        },\n        \"statement\",\n        false\n      ));\n      if (value && value.type === \"ident\" && !value.isMutable) {\n        valueIdent = value.ident;\n      } else {\n        valueIdent = this.tmp(\"v\", false);\n      }\n      letValue = this.macroExpandAll(__node(\n        \"MacroAccess\",\n        40273,\n        40298,\n        29,\n        1246,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              40277,\n              40284,\n              28,\n              1246,\n              __node(\n                \"MacroAccess\",\n                40277,\n                40284,\n                22,\n                1246,\n                { ident: __wrap(value, 228) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __wrap(valueExpr, 228)\n          }\n        },\n        \"statement\",\n        false\n      ));\n      letLength = this.macroExpandAll(__node(\n        \"MacroAccess\",\n        40343,\n        40372,\n        29,\n        1247,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              40347,\n              40355,\n              28,\n              1247,\n              __node(\n                \"MacroAccess\",\n                40347,\n                40355,\n                22,\n                1247,\n                { ident: __wrap(length, 228) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\n              \"MacroAccess\",\n              40357,\n              40372,\n              47,\n              1247,\n              {\n                op: \"+\",\n                node: __node(\n                  \"Access\",\n                  40359,\n                  40372,\n                  __wrap(array, 228),\n                  __node(\"Const\", 40366, 40372, \"length\")\n                )\n              },\n              \"expression\",\n              false\n            )\n          }\n        },\n        \"statement\",\n        false\n      ));\n      test = (_ref = this.isConst(step)\n        ? (__num(this.value(step)) > 0\n          ? (this.isConst(start)\n            ? (__num(this.value(start)) >= 0\n              ? (init.push(__node(\n                \"MacroAccess\",\n                40548,\n                40576,\n                29,\n                1253,\n                {\n                  macroName: \"let\",\n                  macroData: {\n                    declarable: __node(\n                      \"MacroAccess\",\n                      40552,\n                      40567,\n                      28,\n                      1253,\n                      __node(\n                        \"MacroAccess\",\n                        40552,\n                        40567,\n                        22,\n                        1253,\n                        {\n                          isMutable: \"mutable\",\n                          ident: __wrap(index, 228)\n                        },\n                        \"statement\",\n                        false\n                      ),\n                      \"statement\",\n                      false\n                    ),\n                    value: __wrap(start, 228)\n                  }\n                },\n                \"statement\",\n                false\n              )), init.push(letLength))\n              : (init.push(letLength), init.push(__node(\n                \"MacroAccess\",\n                40691,\n                40729,\n                29,\n                1257,\n                {\n                  macroName: \"let\",\n                  macroData: {\n                    declarable: __node(\n                      \"MacroAccess\",\n                      40695,\n                      40710,\n                      28,\n                      1257,\n                      __node(\n                        \"MacroAccess\",\n                        40695,\n                        40710,\n                        22,\n                        1257,\n                        {\n                          isMutable: \"mutable\",\n                          ident: __wrap(index, 228)\n                        },\n                        \"statement\",\n                        false\n                      ),\n                      \"statement\",\n                      false\n                    ),\n                    value: __node(\n                      \"MacroAccess\",\n                      40712,\n                      40729,\n                      53,\n                      1257,\n                      {\n                        left: __wrap(length, 228),\n                        inverted: false,\n                        op: \"+\",\n                        right: __wrap(start, 228)\n                      },\n                      \"expression\",\n                      false\n                    )\n                  }\n                },\n                \"statement\",\n                false\n              ))))\n            : (init.push(letLength), init.push(__node(\n              \"MacroAccess\",\n              40803,\n              40838,\n              29,\n              1260,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    40807,\n                    40822,\n                    28,\n                    1260,\n                    __node(\n                      \"MacroAccess\",\n                      40807,\n                      40822,\n                      22,\n                      1260,\n                      {\n                        isMutable: \"mutable\",\n                        ident: __wrap(index, 228)\n                      },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __node(\n                    \"Call\",\n                    40824,\n                    40838,\n                    __node(\"Ident\", 40824, 40830, \"__int\"),\n                    [__wrap(start, 228)],\n                    false,\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            )), init.push(__node(\n              \"MacroAccess\",\n              40865,\n              40905,\n              18,\n              1261,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __node(\n                    \"MacroAccess\",\n                    40868,\n                    40880,\n                    9,\n                    1261,\n                    {\n                      left: __wrap(index, 228),\n                      inverted: false,\n                      op: \"~<\",\n                      right: __node(\"Const\", 40879, 40880, 0)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  body: __node(\n                    \"MacroAccess\",\n                    40887,\n                    40904,\n                    90,\n                    1261,\n                    {\n                      left: __wrap(index, 228),\n                      op: \"+=\",\n                      right: __wrap(length, 228)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  elseIfs: []\n                }\n              },\n              \"expression\",\n              false\n            ))), this.isConst(end) && (this.value(end) === 1/0 || this.isConst(inclusive) && this.value(inclusive) && this.value(end) === -1)\n            ? [\n              __node(\n                \"MacroAccess\",\n                41051,\n                41069,\n                9,\n                1263,\n                {\n                  left: __wrap(index, 228),\n                  inverted: false,\n                  op: \"~<\",\n                  right: __wrap(length, 228)\n                },\n                \"expression\",\n                false\n              ),\n              __node(\n                \"MacroAccess\",\n                41077,\n                41093,\n                41,\n                1263,\n                {\n                  left: __wrap(index, 228),\n                  op: \"~+=\",\n                  right: __wrap(step, 228)\n                },\n                \"expression\",\n                false\n              )\n            ]\n            : (tmp = this.tmp(\"end\", false, \"number\"), init.push(__node(\n              \"MacroAccess\",\n              41184,\n              41209,\n              29,\n              1266,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    41188,\n                    41201,\n                    28,\n                    1266,\n                    __node(\n                      \"MacroAccess\",\n                      41188,\n                      41201,\n                      22,\n                      1266,\n                      {\n                        isMutable: \"mutable\",\n                        ident: __wrap(tmp, 228)\n                      },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __node(\n                    \"MacroAccess\",\n                    41203,\n                    41209,\n                    47,\n                    1266,\n                    {\n                      op: \"+\",\n                      node: __wrap(end, 228)\n                    },\n                    \"expression\",\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            )), !this.isConst(end)\n              ? init.push(__node(\n                \"MacroAccess\",\n                41272,\n                41309,\n                18,\n                1268,\n                {\n                  macroName: \"if\",\n                  macroData: {\n                    test: __node(\n                      \"MacroAccess\",\n                      41275,\n                      41285,\n                      9,\n                      1268,\n                      {\n                        left: __wrap(tmp, 228),\n                        inverted: false,\n                        op: \"~<\",\n                        right: __node(\"Const\", 41284, 41285, 0)\n                      },\n                      \"expression\",\n                      false\n                    ),\n                    body: __node(\n                      \"MacroAccess\",\n                      41292,\n                      41308,\n                      41,\n                      1268,\n                      {\n                        left: __wrap(tmp, 228),\n                        op: \"~+=\",\n                        right: __wrap(length, 228)\n                      },\n                      \"expression\",\n                      false\n                    ),\n                    elseIfs: []\n                  }\n                },\n                \"expression\",\n                false\n              ))\n              : __num(this.value(end)) < 0\n              ? init.push(__node(\n                \"MacroAccess\",\n                41374,\n                41391,\n                41,\n                1270,\n                {\n                  left: __wrap(tmp, 228),\n                  op: \"~+=\",\n                  right: __wrap(length, 228)\n                },\n                \"expression\",\n                false\n              ))\n              : void 0, init.push(__node(\n              \"MacroAccess\",\n              41418,\n              41468,\n              18,\n              1271,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __wrap(inclusive, 228),\n                  body: __node(\n                    \"Assign\",\n                    41439,\n                    41467,\n                    __wrap(tmp, 228),\n                    \"=\",\n                    __node(\n                      \"MacroAccess\",\n                      41446,\n                      41467,\n                      2,\n                      1271,\n                      {\n                        left: __node(\n                          \"MacroAccess\",\n                          41446,\n                          41455,\n                          53,\n                          1271,\n                          {\n                            left: __wrap(tmp, 228),\n                            inverted: false,\n                            op: \"+\",\n                            right: __node(\"Const\", 41454, 41455, 1)\n                          },\n                          \"expression\",\n                          false\n                        ),\n                        inverted: false,\n                        op: \"or\",\n                        right: __node(\"Const\", 41458, 41467, 1/0)\n                      },\n                      \"expression\",\n                      false\n                    )\n                  ),\n                  elseIfs: []\n                }\n              },\n              \"expression\",\n              false\n            )), init.push(__node(\n              \"MacroAccess\",\n              41495,\n              41514,\n              73,\n              1272,\n              {\n                left: __wrap(tmp, 228),\n                op: \"~min=\",\n                right: __wrap(length, 228)\n              },\n              \"expression\",\n              false\n            )), [\n              __node(\n                \"MacroAccess\",\n                41532,\n                41547,\n                9,\n                1273,\n                {\n                  left: __wrap(index, 228),\n                  inverted: false,\n                  op: \"~<\",\n                  right: __wrap(tmp, 228)\n                },\n                \"expression\",\n                false\n              ),\n              __node(\n                \"MacroAccess\",\n                41553,\n                41570,\n                41,\n                1273,\n                {\n                  left: __wrap(index, 228),\n                  op: \"~+=\",\n                  right: __wrap(step, 228)\n                },\n                \"expression\",\n                false\n              )\n            ]))\n          : this.value(step) === -1 && (!start || this.isConst(start) && ((_ref2 = this.value(start)) === -1 || _ref2 === 1/0) && this.isConst(end) && this.value(end) === 0 && this.isConst(inclusive) && this.value(inclusive))\n          ? (hasLength\n            ? (init.push(letLength), init.push(__node(\n              \"MacroAccess\",\n              41850,\n              41879,\n              29,\n              1277,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    41854,\n                    41869,\n                    28,\n                    1277,\n                    __node(\n                      \"MacroAccess\",\n                      41854,\n                      41869,\n                      22,\n                      1277,\n                      {\n                        isMutable: \"mutable\",\n                        ident: __wrap(index, 228)\n                      },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __wrap(length, 228)\n                }\n              },\n              \"statement\",\n              false\n            )))\n            : init.push(__node(\n              \"MacroAccess\",\n              41920,\n              41956,\n              29,\n              1279,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    41924,\n                    41939,\n                    28,\n                    1279,\n                    __node(\n                      \"MacroAccess\",\n                      41924,\n                      41939,\n                      22,\n                      1279,\n                      {\n                        isMutable: \"mutable\",\n                        ident: __wrap(index, 228)\n                      },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __node(\n                    \"MacroAccess\",\n                    41941,\n                    41956,\n                    47,\n                    1279,\n                    {\n                      op: \"+\",\n                      node: __node(\n                        \"Access\",\n                        41943,\n                        41956,\n                        __wrap(array, 228),\n                        __node(\"Const\", 41950, 41956, \"length\")\n                      )\n                    },\n                    \"expression\",\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            )), [\n            __node(\n              \"MacroAccess\",\n              41972,\n              41989,\n              13,\n              1280,\n              {\n                op: \"postDec!\",\n                node: __wrap(index, 228)\n              },\n              \"expression\",\n              false\n            ),\n            this.noop()\n          ])\n          : (!this.isConst(end) || __num(this.value(end)) < 0 ? (hasLength = true) : void 0, this.isConst(start)\n            ? ((_ref2 = this.value(start)) === -1 || _ref2 === 1/0\n              ? (hasLength\n                ? (init.push(letLength), init.push(__node(\n                  \"MacroAccess\",\n                  42266,\n                  42300,\n                  29,\n                  1288,\n                  {\n                    macroName: \"let\",\n                    macroData: {\n                      declarable: __node(\n                        \"MacroAccess\",\n                        42270,\n                        42285,\n                        28,\n                        1288,\n                        __node(\n                          \"MacroAccess\",\n                          42270,\n                          42285,\n                          22,\n                          1288,\n                          {\n                            isMutable: \"mutable\",\n                            ident: __wrap(index, 228)\n                          },\n                          \"statement\",\n                          false\n                        ),\n                        \"statement\",\n                        false\n                      ),\n                      value: __node(\n                        \"MacroAccess\",\n                        42287,\n                        42300,\n                        38,\n                        1288,\n                        {\n                          left: __wrap(length, 228),\n                          inverted: false,\n                          op: \"~-\",\n                          right: __node(\"Const\", 42299, 42300, 1)\n                        },\n                        \"expression\",\n                        false\n                      )\n                    }\n                  },\n                  \"statement\",\n                  false\n                )))\n                : init.push(__node(\n                  \"MacroAccess\",\n                  42349,\n                  42390,\n                  29,\n                  1290,\n                  {\n                    macroName: \"let\",\n                    macroData: {\n                      declarable: __node(\n                        \"MacroAccess\",\n                        42353,\n                        42368,\n                        28,\n                        1290,\n                        __node(\n                          \"MacroAccess\",\n                          42353,\n                          42368,\n                          22,\n                          1290,\n                          {\n                            isMutable: \"mutable\",\n                            ident: __wrap(index, 228)\n                          },\n                          \"statement\",\n                          false\n                        ),\n                        \"statement\",\n                        false\n                      ),\n                      value: __node(\n                        \"MacroAccess\",\n                        42370,\n                        42390,\n                        38,\n                        1290,\n                        {\n                          left: __node(\n                            \"MacroAccess\",\n                            42370,\n                            42385,\n                            47,\n                            1290,\n                            {\n                              op: \"+\",\n                              node: __node(\n                                \"Access\",\n                                42372,\n                                42385,\n                                __wrap(array, 228),\n                                __node(\"Const\", 42379, 42385, \"length\")\n                              )\n                            },\n                            \"expression\",\n                            false\n                          ),\n                          inverted: false,\n                          op: \"~-\",\n                          right: __node(\"Const\", 42389, 42390, 1)\n                        },\n                        \"expression\",\n                        false\n                      )\n                    }\n                  },\n                  \"statement\",\n                  false\n                )))\n              : (init.push(letLength), __num(this.value(start)) >= 0\n                ? init.push(__node(\n                  \"MacroAccess\",\n                  42508,\n                  42580,\n                  29,\n                  1294,\n                  {\n                    macroName: \"let\",\n                    macroData: {\n                      declarable: __node(\n                        \"MacroAccess\",\n                        42512,\n                        42527,\n                        28,\n                        1294,\n                        __node(\n                          \"MacroAccess\",\n                          42512,\n                          42527,\n                          22,\n                          1294,\n                          {\n                            isMutable: \"mutable\",\n                            ident: __wrap(index, 228)\n                          },\n                          \"statement\",\n                          false\n                        ),\n                        \"statement\",\n                        false\n                      ),\n                      value: __node(\n                        \"MacroAccess\",\n                        42529,\n                        42580,\n                        18,\n                        1294,\n                        {\n                          macroName: \"if\",\n                          macroData: {\n                            test: __node(\n                              \"MacroAccess\",\n                              42532,\n                              42550,\n                              9,\n                              1294,\n                              {\n                                left: __wrap(start, 228),\n                                inverted: false,\n                                op: \"~<\",\n                                right: __wrap(length, 228)\n                              },\n                              \"expression\",\n                              false\n                            ),\n                            body: __wrap(start, 228),\n                            elseIfs: [],\n                            elseBody: __node(\n                              \"MacroAccess\",\n                              42567,\n                              42580,\n                              38,\n                              1294,\n                              {\n                                left: __wrap(length, 228),\n                                inverted: false,\n                                op: \"~-\",\n                                right: __node(\"Const\", 42579, 42580, 1)\n                              },\n                              \"expression\",\n                              false\n                            )\n                          }\n                        },\n                        \"expression\",\n                        false\n                      )\n                    }\n                  },\n                  \"statement\",\n                  false\n                ))\n                : init.push(__node(\n                  \"MacroAccess\",\n                  42629,\n                  42669,\n                  29,\n                  1296,\n                  {\n                    macroName: \"let\",\n                    macroData: {\n                      declarable: __node(\n                        \"MacroAccess\",\n                        42633,\n                        42648,\n                        28,\n                        1296,\n                        __node(\n                          \"MacroAccess\",\n                          42633,\n                          42648,\n                          22,\n                          1296,\n                          {\n                            isMutable: \"mutable\",\n                            ident: __wrap(index, 228)\n                          },\n                          \"statement\",\n                          false\n                        ),\n                        \"statement\",\n                        false\n                      ),\n                      value: __node(\n                        \"MacroAccess\",\n                        42650,\n                        42669,\n                        38,\n                        1296,\n                        {\n                          left: __wrap(length, 228),\n                          inverted: false,\n                          op: \"~+\",\n                          right: __node(\n                            \"MacroAccess\",\n                            42661,\n                            42669,\n                            47,\n                            1296,\n                            {\n                              op: \"+\",\n                              node: __wrap(start, 228)\n                            },\n                            \"expression\",\n                            false\n                          )\n                        },\n                        \"expression\",\n                        false\n                      )\n                    }\n                  },\n                  \"statement\",\n                  false\n                ))))\n            : (init.push(letLength), init.push(__node(\n              \"MacroAccess\",\n              42743,\n              42772,\n              29,\n              1299,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    42747,\n                    42762,\n                    28,\n                    1299,\n                    __node(\n                      \"MacroAccess\",\n                      42747,\n                      42762,\n                      22,\n                      1299,\n                      {\n                        isMutable: \"mutable\",\n                        ident: __wrap(index, 228)\n                      },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __node(\n                    \"MacroAccess\",\n                    42764,\n                    42772,\n                    47,\n                    1299,\n                    {\n                      op: \"+\",\n                      node: __wrap(start, 228)\n                    },\n                    \"expression\",\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            )), init.push(__node(\n              \"MacroAccess\",\n              42798,\n              42867,\n              18,\n              1300,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __node(\n                    \"MacroAccess\",\n                    42801,\n                    42813,\n                    9,\n                    1300,\n                    {\n                      left: __wrap(index, 228),\n                      inverted: false,\n                      op: \"~<\",\n                      right: __node(\"Const\", 42812, 42813, 0)\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  body: __node(\n                    \"MacroAccess\",\n                    42820,\n                    42838,\n                    41,\n                    1300,\n                    {\n                      left: __wrap(index, 228),\n                      op: \"~+=\",\n                      right: __wrap(length, 228)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  elseIfs: [],\n                  elseBody: __node(\n                    \"MacroAccess\",\n                    42846,\n                    42866,\n                    73,\n                    1300,\n                    {\n                      left: __wrap(index, 228),\n                      op: \"~min=\",\n                      right: __wrap(length, 228)\n                    },\n                    \"expression\",\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            )), init.push(__node(\n              \"MacroAccess\",\n              42893,\n              42906,\n              42,\n              1301,\n              {\n                left: __wrap(index, 228),\n                op: \"~-=\",\n                right: __node(\"Const\", 42905, 42906, 1)\n              },\n              \"statement\",\n              false\n            ))), this.isConst(end)\n            ? (__num(this.value(end)) >= 0\n              ? [\n                __node(\n                  \"MacroAccess\",\n                  42986,\n                  43041,\n                  18,\n                  1304,\n                  {\n                    macroName: \"if\",\n                    macroData: {\n                      test: __wrap(inclusive, 228),\n                      body: __node(\n                        \"MacroAccess\",\n                        43005,\n                        43021,\n                        10,\n                        1304,\n                        {\n                          left: __wrap(index, 228),\n                          inverted: false,\n                          op: \"~>=\",\n                          right: __wrap(end, 228)\n                        },\n                        \"expression\",\n                        false\n                      ),\n                      elseIfs: [],\n                      elseBody: __node(\n                        \"MacroAccess\",\n                        43026,\n                        43041,\n                        10,\n                        1304,\n                        {\n                          left: __wrap(index, 228),\n                          inverted: false,\n                          op: \"~>\",\n                          right: __wrap(end, 228)\n                        },\n                        \"expression\",\n                        false\n                      )\n                    }\n                  },\n                  \"expression\",\n                  false\n                ),\n                __node(\n                  \"MacroAccess\",\n                  43047,\n                  43064,\n                  41,\n                  1304,\n                  {\n                    left: __wrap(index, 228),\n                    op: \"~+=\",\n                    right: __wrap(step, 228)\n                  },\n                  \"expression\",\n                  false\n                )\n              ]\n              : [\n                __node(\n                  \"MacroAccess\",\n                  43102,\n                  43177,\n                  18,\n                  1306,\n                  {\n                    macroName: \"if\",\n                    macroData: {\n                      test: __wrap(inclusive, 228),\n                      body: __node(\n                        \"MacroAccess\",\n                        43121,\n                        43147,\n                        10,\n                        1306,\n                        {\n                          left: __wrap(index, 228),\n                          inverted: false,\n                          op: \"~>=\",\n                          right: __node(\n                            \"MacroAccess\",\n                            43132,\n                            43147,\n                            53,\n                            1306,\n                            {\n                              left: __wrap(end, 228),\n                              inverted: false,\n                              op: \"+\",\n                              right: __wrap(length, 228)\n                            },\n                            \"expression\",\n                            false\n                          )\n                        },\n                        \"expression\",\n                        false\n                      ),\n                      elseIfs: [],\n                      elseBody: __node(\n                        \"MacroAccess\",\n                        43152,\n                        43177,\n                        10,\n                        1306,\n                        {\n                          left: __wrap(index, 228),\n                          inverted: false,\n                          op: \"~>\",\n                          right: __node(\n                            \"MacroAccess\",\n                            43162,\n                            43177,\n                            53,\n                            1306,\n                            {\n                              left: __wrap(end, 228),\n                              inverted: false,\n                              op: \"+\",\n                              right: __wrap(length, 228)\n                            },\n                            \"expression\",\n                            false\n                          )\n                        },\n                        \"expression\",\n                        false\n                      )\n                    }\n                  },\n                  \"expression\",\n                  false\n                ),\n                __node(\n                  \"MacroAccess\",\n                  43183,\n                  43200,\n                  41,\n                  1306,\n                  {\n                    left: __wrap(index, 228),\n                    op: \"~+=\",\n                    right: __wrap(step, 228)\n                  },\n                  \"expression\",\n                  false\n                )\n              ])\n            : (tmp = this.tmp(\"end\", false, \"number\"), init.push(__node(\n              \"MacroAccess\",\n              43290,\n              43315,\n              29,\n              1309,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    43294,\n                    43307,\n                    28,\n                    1309,\n                    __node(\n                      \"MacroAccess\",\n                      43294,\n                      43307,\n                      22,\n                      1309,\n                      {\n                        isMutable: \"mutable\",\n                        ident: __wrap(tmp, 228)\n                      },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __node(\n                    \"MacroAccess\",\n                    43309,\n                    43315,\n                    47,\n                    1309,\n                    {\n                      op: \"+\",\n                      node: __wrap(end, 228)\n                    },\n                    \"expression\",\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            )), init.push(__node(\n              \"MacroAccess\",\n              43341,\n              43378,\n              18,\n              1310,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __node(\n                    \"MacroAccess\",\n                    43344,\n                    43354,\n                    9,\n                    1310,\n                    {\n                      left: __wrap(tmp, 228),\n                      inverted: false,\n                      op: \"~<\",\n                      right: __node(\"Const\", 43353, 43354, 0)\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  body: __node(\n                    \"MacroAccess\",\n                    43361,\n                    43377,\n                    41,\n                    1310,\n                    {\n                      left: __wrap(tmp, 228),\n                      op: \"~+=\",\n                      right: __wrap(length, 228)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  elseIfs: []\n                }\n              },\n              \"statement\",\n              false\n            )), [\n              __node(\n                \"MacroAccess\",\n                43396,\n                43451,\n                18,\n                1311,\n                {\n                  macroName: \"if\",\n                  macroData: {\n                    test: __wrap(inclusive, 228),\n                    body: __node(\n                      \"MacroAccess\",\n                      43415,\n                      43431,\n                      10,\n                      1311,\n                      {\n                        left: __wrap(index, 228),\n                        inverted: false,\n                        op: \"~>=\",\n                        right: __wrap(tmp, 228)\n                      },\n                      \"expression\",\n                      false\n                    ),\n                    elseIfs: [],\n                    elseBody: __node(\n                      \"MacroAccess\",\n                      43436,\n                      43451,\n                      10,\n                      1311,\n                      {\n                        left: __wrap(index, 228),\n                        inverted: false,\n                        op: \"~>\",\n                        right: __wrap(tmp, 228)\n                      },\n                      \"expression\",\n                      false\n                    )\n                  }\n                },\n                \"expression\",\n                false\n              ),\n              __node(\n                \"MacroAccess\",\n                43457,\n                43474,\n                41,\n                1311,\n                {\n                  left: __wrap(index, 228),\n                  op: \"~+=\",\n                  right: __wrap(step, 228)\n                },\n                \"expression\",\n                false\n              )\n            ])))\n        : (this.isComplex(step)\n          ? (step = this.cache(\n            __node(\n              \"Call\",\n              43546,\n              43570,\n              __node(\"Ident\", 43546, 43552, \"__int\"),\n              [\n                __node(\n                  \"Call\",\n                  43553,\n                  43569,\n                  __node(\"Ident\", 43553, 43562, \"__nonzero\"),\n                  [__wrap(step, 228)],\n                  false,\n                  false\n                )\n              ],\n              false,\n              false\n            ),\n            init,\n            \"step\",\n            false\n          ))\n          : init.unshift(__node(\n            \"Call\",\n            43632,\n            43656,\n            __node(\"Ident\", 43632, 43638, \"__int\"),\n            [\n              __node(\n                \"Call\",\n                43639,\n                43655,\n                __node(\"Ident\", 43639, 43648, \"__nonzero\"),\n                [__wrap(step, 228)],\n                false,\n                false\n              )\n            ],\n            false,\n            false\n          )), init.push(letLength), !start\n          ? (init.push(__node(\n            \"MacroAccess\",\n            43730,\n            43790,\n            29,\n            1319,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  43734,\n                  43749,\n                  28,\n                  1319,\n                  __node(\n                    \"MacroAccess\",\n                    43734,\n                    43749,\n                    22,\n                    1319,\n                    {\n                      isMutable: \"mutable\",\n                      ident: __wrap(index, 228)\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\n                  \"MacroAccess\",\n                  43751,\n                  43790,\n                  18,\n                  1319,\n                  {\n                    macroName: \"if\",\n                    macroData: {\n                      test: __node(\n                        \"MacroAccess\",\n                        43754,\n                        43765,\n                        10,\n                        1319,\n                        {\n                          left: __wrap(step, 228),\n                          inverted: false,\n                          op: \"~>\",\n                          right: __node(\"Const\", 43764, 43765, 0)\n                        },\n                        \"expression\",\n                        false\n                      ),\n                      body: __node(\"Const\", 43771, 43772, 0),\n                      elseIfs: [],\n                      elseBody: __node(\n                        \"MacroAccess\",\n                        43777,\n                        43790,\n                        38,\n                        1319,\n                        {\n                          left: __wrap(length, 228),\n                          inverted: false,\n                          op: \"~-\",\n                          right: __node(\"Const\", 43789, 43790, 1)\n                        },\n                        \"expression\",\n                        false\n                      )\n                    }\n                  },\n                  \"expression\",\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          )), [\n            __node(\n              \"MacroAccess\",\n              43819,\n              43874,\n              18,\n              1321,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __node(\n                    \"MacroAccess\",\n                    43822,\n                    43833,\n                    10,\n                    1321,\n                    {\n                      left: __wrap(step, 228),\n                      inverted: false,\n                      op: \"~>\",\n                      right: __node(\"Const\", 43832, 43833, 0)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  body: __node(\n                    \"MacroAccess\",\n                    43838,\n                    43856,\n                    9,\n                    1321,\n                    {\n                      left: __wrap(index, 228),\n                      inverted: false,\n                      op: \"~<\",\n                      right: __wrap(length, 228)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  elseIfs: [],\n                  elseBody: __node(\n                    \"MacroAccess\",\n                    43861,\n                    43874,\n                    10,\n                    1321,\n                    {\n                      left: __wrap(index, 228),\n                      inverted: false,\n                      op: \"~>=\",\n                      right: __node(\"Const\", 43873, 43874, 0)\n                    },\n                    \"expression\",\n                    false\n                  )\n                }\n              },\n              \"expression\",\n              false\n            ),\n            __node(\n              \"MacroAccess\",\n              43891,\n              43908,\n              41,\n              1322,\n              {\n                left: __wrap(index, 228),\n                op: \"~+=\",\n                right: __wrap(step, 228)\n              },\n              \"expression\",\n              false\n            )\n          ])\n          : (this.isConst(start)\n            ? (this.value(start) === 1/0\n              ? init.push(__node(\n                \"MacroAccess\",\n                44032,\n                44066,\n                29,\n                1327,\n                {\n                  macroName: \"let\",\n                  macroData: {\n                    declarable: __node(\n                      \"MacroAccess\",\n                      44036,\n                      44051,\n                      28,\n                      1327,\n                      __node(\n                        \"MacroAccess\",\n                        44036,\n                        44051,\n                        22,\n                        1327,\n                        {\n                          isMutable: \"mutable\",\n                          ident: __wrap(index, 228)\n                        },\n                        \"statement\",\n                        false\n                      ),\n                      \"statement\",\n                      false\n                    ),\n                    value: __node(\n                      \"MacroAccess\",\n                      44053,\n                      44066,\n                      38,\n                      1327,\n                      {\n                        left: __wrap(length, 228),\n                        inverted: false,\n                        op: \"~-\",\n                        right: __node(\"Const\", 44065, 44066, 1)\n                      },\n                      \"expression\",\n                      false\n                    )\n                  }\n                },\n                \"statement\",\n                false\n              ))\n              : init.push(__node(\n                \"MacroAccess\",\n                44111,\n                44182,\n                29,\n                1329,\n                {\n                  macroName: \"let\",\n                  macroData: {\n                    declarable: __node(\n                      \"MacroAccess\",\n                      44115,\n                      44130,\n                      28,\n                      1329,\n                      __node(\n                        \"MacroAccess\",\n                        44115,\n                        44130,\n                        22,\n                        1329,\n                        {\n                          isMutable: \"mutable\",\n                          ident: __wrap(index, 228)\n                        },\n                        \"statement\",\n                        false\n                      ),\n                      \"statement\",\n                      false\n                    ),\n                    value: __node(\n                      \"MacroAccess\",\n                      44132,\n                      44182,\n                      18,\n                      1329,\n                      {\n                        macroName: \"if\",\n                        macroData: {\n                          test: __node(\n                            \"MacroAccess\",\n                            44135,\n                            44148,\n                            10,\n                            1329,\n                            {\n                              left: __wrap(start, 228),\n                              inverted: false,\n                              op: \"~>=\",\n                              right: __node(\"Const\", 44147, 44148, 0)\n                            },\n                            \"expression\",\n                            false\n                          ),\n                          body: __wrap(start, 228),\n                          elseIfs: [],\n                          elseBody: __node(\n                            \"MacroAccess\",\n                            44165,\n                            44182,\n                            53,\n                            1329,\n                            {\n                              left: __wrap(start, 228),\n                              inverted: false,\n                              op: \"+\",\n                              right: __wrap(length, 228)\n                            },\n                            \"expression\",\n                            false\n                          )\n                        }\n                      },\n                      \"expression\",\n                      false\n                    )\n                  }\n                },\n                \"statement\",\n                false\n              )))\n            : (init.push(__node(\n              \"MacroAccess\",\n              44223,\n              44251,\n              29,\n              1331,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    44227,\n                    44242,\n                    28,\n                    1331,\n                    __node(\n                      \"MacroAccess\",\n                      44227,\n                      44242,\n                      22,\n                      1331,\n                      {\n                        isMutable: \"mutable\",\n                        ident: __wrap(index, 228)\n                      },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __wrap(start, 228)\n                }\n              },\n              \"statement\",\n              false\n            )), init.push(__node(\n              \"MacroAccess\",\n              44277,\n              44364,\n              18,\n              1332,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __node(\n                    \"MacroAccess\",\n                    44280,\n                    44292,\n                    9,\n                    1332,\n                    {\n                      left: __wrap(index, 228),\n                      inverted: false,\n                      op: \"~<\",\n                      right: __node(\"Const\", 44291, 44292, 0)\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  body: __node(\n                    \"MacroAccess\",\n                    44299,\n                    44316,\n                    90,\n                    1332,\n                    {\n                      left: __wrap(index, 228),\n                      op: \"+=\",\n                      right: __wrap(length, 228)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  elseIfs: [\n                    {\n                      test: __node(\n                        \"MacroAccess\",\n                        44325,\n                        44336,\n                        9,\n                        1332,\n                        {\n                          left: __wrap(step, 228),\n                          inverted: false,\n                          op: \"~<\",\n                          right: __node(\"Const\", 44335, 44336, 0)\n                        },\n                        \"statement\",\n                        false\n                      ),\n                      body: __node(\n                        \"MacroAccess\",\n                        44343,\n                        44363,\n                        73,\n                        1332,\n                        {\n                          left: __wrap(index, 228),\n                          op: \"~min=\",\n                          right: __wrap(length, 228)\n                        },\n                        \"expression\",\n                        false\n                      )\n                    }\n                  ]\n                }\n              },\n              \"statement\",\n              false\n            ))), tmp = this.tmp(\"end\", false, \"number\"), this.isConst(end)\n            ? init.push(__node(\n              \"MacroAccess\",\n              44464,\n              44578,\n              29,\n              1335,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    44468,\n                    44481,\n                    28,\n                    1335,\n                    __node(\n                      \"MacroAccess\",\n                      44468,\n                      44481,\n                      22,\n                      1335,\n                      {\n                        isMutable: \"mutable\",\n                        ident: __wrap(tmp, 228)\n                      },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __node(\n                    \"MacroAccess\",\n                    44483,\n                    44578,\n                    18,\n                    1335,\n                    {\n                      macroName: \"if\",\n                      macroData: {\n                        test: __node(\n                          \"MacroAccess\",\n                          44486,\n                          44496,\n                          9,\n                          1335,\n                          {\n                            left: __wrap(end, 228),\n                            inverted: false,\n                            op: \"~<\",\n                            right: __node(\"Const\", 44495, 44496, 0)\n                          },\n                          \"expression\",\n                          false\n                        ),\n                        body: __node(\n                          \"MacroAccess\",\n                          44501,\n                          44517,\n                          38,\n                          1335,\n                          {\n                            left: __wrap(end, 228),\n                            inverted: false,\n                            op: \"~+\",\n                            right: __wrap(length, 228)\n                          },\n                          \"expression\",\n                          false\n                        ),\n                        elseIfs: [],\n                        elseBody: __node(\n                          \"MacroAccess\",\n                          44522,\n                          44578,\n                          70,\n                          1335,\n                          {\n                            left: __wrap(end, 228),\n                            inverted: false,\n                            op: \"max\",\n                            right: __node(\n                              \"MacroAccess\",\n                              44533,\n                              44577,\n                              18,\n                              1335,\n                              {\n                                macroName: \"if\",\n                                macroData: {\n                                  test: __wrap(inclusive, 228),\n                                  body: __node(\n                                    \"MacroAccess\",\n                                    44551,\n                                    44564,\n                                    38,\n                                    1335,\n                                    {\n                                      left: __wrap(length, 228),\n                                      inverted: false,\n                                      op: \"~-\",\n                                      right: __node(\"Const\", 44563, 44564, 1)\n                                    },\n                                    \"expression\",\n                                    false\n                                  ),\n                                  elseIfs: [],\n                                  elseBody: __wrap(length, 228)\n                                }\n                              },\n                              \"expression\",\n                              false\n                            )\n                          },\n                          \"expression\",\n                          false\n                        )\n                      }\n                    },\n                    \"expression\",\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            ))\n            : (init.push(__node(\n              \"MacroAccess\",\n              44619,\n              44644,\n              29,\n              1337,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    44623,\n                    44636,\n                    28,\n                    1337,\n                    __node(\n                      \"MacroAccess\",\n                      44623,\n                      44636,\n                      22,\n                      1337,\n                      {\n                        isMutable: \"mutable\",\n                        ident: __wrap(tmp, 228)\n                      },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __node(\n                    \"MacroAccess\",\n                    44638,\n                    44644,\n                    47,\n                    1337,\n                    {\n                      op: \"+\",\n                      node: __wrap(end, 228)\n                    },\n                    \"expression\",\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            )), init.push(__node(\n              \"MacroAccess\",\n              44670,\n              44837,\n              18,\n              1338,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __node(\n                    \"MacroAccess\",\n                    44673,\n                    44683,\n                    9,\n                    1338,\n                    {\n                      left: __wrap(tmp, 228),\n                      inverted: false,\n                      op: \"~<\",\n                      right: __node(\"Const\", 44682, 44683, 0)\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  body: __node(\n                    \"MacroAccess\",\n                    44690,\n                    44705,\n                    90,\n                    1338,\n                    {\n                      left: __wrap(tmp, 228),\n                      op: \"+=\",\n                      right: __wrap(length, 228)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  elseIfs: [\n                    {\n                      test: __node(\n                        \"MacroAccess\",\n                        44714,\n                        44725,\n                        10,\n                        1338,\n                        {\n                          left: __wrap(step, 228),\n                          inverted: false,\n                          op: \"~>\",\n                          right: __node(\"Const\", 44724, 44725, 0)\n                        },\n                        \"statement\",\n                        false\n                      ),\n                      body: __node(\n                        \"MacroAccess\",\n                        44732,\n                        44787,\n                        73,\n                        1338,\n                        {\n                          left: __wrap(tmp, 228),\n                          op: \"~min=\",\n                          right: __node(\n                            \"MacroAccess\",\n                            44742,\n                            44787,\n                            18,\n                            1338,\n                            {\n                              macroName: \"if\",\n                              macroData: {\n                                test: __wrap(inclusive, 228),\n                                body: __node(\n                                  \"MacroAccess\",\n                                  44761,\n                                  44774,\n                                  38,\n                                  1338,\n                                  {\n                                    left: __wrap(length, 228),\n                                    inverted: false,\n                                    op: \"~-\",\n                                    right: __node(\"Const\", 44773, 44774, 1)\n                                  },\n                                  \"expression\",\n                                  false\n                                ),\n                                elseIfs: [],\n                                elseBody: __wrap(length, 228)\n                              }\n                            },\n                            \"expression\",\n                            false\n                          )\n                        },\n                        \"expression\",\n                        false\n                      )\n                    }\n                  ],\n                  elseBody: __node(\n                    \"MacroAccess\",\n                    44795,\n                    44836,\n                    74,\n                    1338,\n                    {\n                      left: __wrap(tmp, 228),\n                      op: \"~max=\",\n                      right: __node(\n                        \"MacroAccess\",\n                        44807,\n                        44835,\n                        18,\n                        1338,\n                        {\n                          macroName: \"if\",\n                          macroData: {\n                            test: __wrap(inclusive, 228),\n                            body: __node(\"Const\", 44826, 44827, 0),\n                            elseIfs: [],\n                            elseBody: __node(\n                              \"MacroAccess\",\n                              44832,\n                              44835,\n                              48,\n                              1338,\n                              {\n                                op: \"-\",\n                                node: __node(\"Const\", 44834, 44835, 1)\n                              },\n                              \"expression\",\n                              false\n                            )\n                          }\n                        },\n                        \"expression\",\n                        false\n                      )\n                    },\n                    \"expression\",\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            ))), end = tmp, [\n            __node(\n              \"MacroAccess\",\n              44887,\n              45056,\n              19,\n              1341,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __node(\n                    \"MacroAccess\",\n                    44890,\n                    44901,\n                    10,\n                    1341,\n                    {\n                      left: __wrap(step, 228),\n                      inverted: false,\n                      op: \"~>\",\n                      right: __node(\"Const\", 44900, 44901, 0)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  body: __node(\n                    \"MacroAccess\",\n                    44916,\n                    44970,\n                    18,\n                    1342,\n                    {\n                      macroName: \"if\",\n                      macroData: {\n                        test: __wrap(inclusive, 228),\n                        body: __node(\n                          \"MacroAccess\",\n                          44934,\n                          44950,\n                          9,\n                          1342,\n                          {\n                            left: __wrap(index, 228),\n                            inverted: false,\n                            op: \"~<=\",\n                            right: __wrap(end, 228)\n                          },\n                          \"expression\",\n                          false\n                        ),\n                        elseIfs: [],\n                        elseBody: __node(\n                          \"MacroAccess\",\n                          44955,\n                          44970,\n                          9,\n                          1342,\n                          {\n                            left: __wrap(index, 228),\n                            inverted: false,\n                            op: \"~<\",\n                            right: __wrap(end, 228)\n                          },\n                          \"expression\",\n                          false\n                        )\n                      }\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  elseIfs: [],\n                  elseBody: __node(\n                    \"MacroAccess\",\n                    45002,\n                    45056,\n                    18,\n                    1344,\n                    {\n                      macroName: \"if\",\n                      macroData: {\n                        test: __wrap(inclusive, 228),\n                        body: __node(\n                          \"MacroAccess\",\n                          45020,\n                          45036,\n                          10,\n                          1344,\n                          {\n                            left: __wrap(index, 228),\n                            inverted: false,\n                            op: \"~>=\",\n                            right: __wrap(end, 228)\n                          },\n                          \"expression\",\n                          false\n                        ),\n                        elseIfs: [],\n                        elseBody: __node(\n                          \"MacroAccess\",\n                          45041,\n                          45056,\n                          9,\n                          1344,\n                          {\n                            left: __wrap(index, 228),\n                            inverted: false,\n                            op: \"~<\",\n                            right: __wrap(end, 228)\n                          },\n                          \"expression\",\n                          false\n                        )\n                      }\n                    },\n                    \"statement\",\n                    false\n                  )\n                }\n              },\n              \"expression\",\n              false\n            ),\n            __node(\n              \"MacroAccess\",\n              45073,\n              45090,\n              41,\n              1345,\n              {\n                left: __wrap(index, 228),\n                op: \"~+=\",\n                right: __wrap(step, 228)\n              },\n              \"expression\",\n              false\n            )\n          ])))[0];\n      increment = _ref[1];\n      if (this.hasFunc(body)) {\n        func = this.tmp(\"f\", false, \"function\");\n        if (value && valueIdent !== value.ident) {\n          body = __node(\n            \"Block\",\n            45248,\n            45303,\n            [\n              __node(\n                \"MacroAccess\",\n                45260,\n                45285,\n                29,\n                1352,\n                {\n                  macroName: \"let\",\n                  macroData: {\n                    declarable: __node(\n                      \"MacroAccess\",\n                      45263,\n                      45270,\n                      28,\n                      1352,\n                      __node(\n                        \"MacroAccess\",\n                        45263,\n                        45270,\n                        22,\n                        1352,\n                        { ident: __wrap(value, 228) },\n                        \"statement\",\n                        false\n                      ),\n                      \"statement\",\n                      false\n                    ),\n                    value: __wrap(valueIdent, 228)\n                  }\n                },\n                \"statement\",\n                false\n              ),\n              __wrap(body, 228)\n            ],\n            null\n          );\n        }\n        if (hasIndex) {\n          init.push(__node(\n            \"MacroAccess\",\n            45348,\n            45393,\n            29,\n            1355,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  45352,\n                  45358,\n                  28,\n                  1355,\n                  __node(\n                    \"MacroAccess\",\n                    45352,\n                    45358,\n                    22,\n                    1355,\n                    { ident: __wrap(func, 228) },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\n                  \"Function\",\n                  45362,\n                  45393,\n                  [\n                    __node(\n                      \"Param\",\n                      45363,\n                      45375,\n                      __wrap(valueIdent, 259),\n                      void 0,\n                      false,\n                      false,\n                      void 0\n                    ),\n                    __node(\n                      \"Param\",\n                      45376,\n                      45383,\n                      __wrap(index, 259),\n                      void 0,\n                      false,\n                      false,\n                      void 0\n                    )\n                  ],\n                  __wrap(body, 259),\n                  true,\n                  false,\n                  void 0,\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          ));\n          body = __node(\n            \"Call\",\n            45416,\n            45450,\n            __wrap(func, 228),\n            [\n              __node(\"This\", 45424, 45428),\n              __wrap(valueExpr, 228),\n              __wrap(index, 228)\n            ],\n            false,\n            true\n          );\n        } else {\n          init.push(__node(\n            \"MacroAccess\",\n            45487,\n            45524,\n            29,\n            1358,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  45491,\n                  45497,\n                  28,\n                  1358,\n                  __node(\n                    \"MacroAccess\",\n                    45491,\n                    45497,\n                    22,\n                    1358,\n                    { ident: __wrap(func, 228) },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\n                  \"Function\",\n                  45501,\n                  45524,\n                  [\n                    __node(\n                      \"Param\",\n                      45502,\n                      45514,\n                      __wrap(valueIdent, 261),\n                      void 0,\n                      false,\n                      false,\n                      void 0\n                    )\n                  ],\n                  __wrap(body, 261),\n                  true,\n                  false,\n                  void 0,\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          ));\n          body = __node(\n            \"Call\",\n            45547,\n            45573,\n            __wrap(func, 228),\n            [\n              __node(\"This\", 45555, 45559),\n              __wrap(valueExpr, 228)\n            ],\n            false,\n            true\n          );\n        }\n      } else if (valueIdent === value.ident || reducer !== \"filter\") {\n        body = __node(\n          \"Block\",\n          45657,\n          45707,\n          [\n            __node(\n              \"MacroAccess\",\n              45667,\n              45691,\n              29,\n              1362,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    45670,\n                    45677,\n                    28,\n                    1362,\n                    __node(\n                      \"MacroAccess\",\n                      45670,\n                      45677,\n                      22,\n                      1362,\n                      { ident: __wrap(value, 228) },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __wrap(valueExpr, 228)\n                }\n              },\n              \"statement\",\n              false\n            ),\n            __wrap(body, 228)\n          ],\n          null\n        );\n      } else {\n        body = __node(\n          \"Block\",\n          45739,\n          45831,\n          [\n            __node(\n              \"MacroAccess\",\n              45749,\n              45779,\n              29,\n              1366,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    45752,\n                    45765,\n                    28,\n                    1366,\n                    __node(\n                      \"MacroAccess\",\n                      45752,\n                      45765,\n                      22,\n                      1366,\n                      { ident: __wrap(valueIdent, 228) },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __wrap(valueExpr, 228)\n                }\n              },\n              \"statement\",\n              false\n            ),\n            __node(\n              \"MacroAccess\",\n              45790,\n              45815,\n              29,\n              1367,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    45793,\n                    45800,\n                    28,\n                    1367,\n                    __node(\n                      \"MacroAccess\",\n                      45793,\n                      45800,\n                      22,\n                      1367,\n                      { ident: __wrap(value, 228) },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __wrap(valueIdent, 228)\n                }\n              },\n              \"statement\",\n              false\n            ),\n            __wrap(body, 228)\n          ],\n          null\n        );\n      }\n      if (reducer === \"every\") {\n        return __node(\n          \"MacroAccess\",\n          45874,\n          45959,\n          95,\n          1371,\n          {\n            macroName: \"for\",\n            macroData: {\n              reducer: \"every\",\n              init: __wrap(init, 228),\n              test: __wrap(test, 228),\n              step: __wrap(increment, 228),\n              body: __wrap(body, 228),\n              elseBody: __wrap(elseBody, 228)\n            }\n          },\n          \"expression\",\n          false\n        );\n      } else if (reducer === \"some\") {\n        return __node(\n          \"MacroAccess\",\n          46003,\n          46087,\n          95,\n          1376,\n          {\n            macroName: \"for\",\n            macroData: {\n              reducer: \"some\",\n              init: __wrap(init, 228),\n              test: __wrap(test, 228),\n              step: __wrap(increment, 228),\n              body: __wrap(body, 228),\n              elseBody: __wrap(elseBody, 228)\n            }\n          },\n          \"expression\",\n          false\n        );\n      } else if (reducer === \"first\") {\n        return __node(\n          \"MacroAccess\",\n          46132,\n          46217,\n          95,\n          1381,\n          {\n            macroName: \"for\",\n            macroData: {\n              reducer: \"first\",\n              init: __wrap(init, 228),\n              test: __wrap(test, 228),\n              step: __wrap(increment, 228),\n              body: __wrap(body, 228),\n              elseBody: __wrap(elseBody, 228)\n            }\n          },\n          \"expression\",\n          false\n        );\n      } else if (reducer === \"filter\") {\n        body = this.mutateLast(body, function (node) {\n          return __node(\n            \"MacroAccess\",\n            46307,\n            46341,\n            19,\n            1387,\n            {\n              macroName: \"if\",\n              macroData: {\n                test: __wrap(node, 265),\n                body: __wrap(valueIdent, 265),\n                elseIfs: []\n              }\n            },\n            \"statement\",\n            false\n          );\n        });\n        return __node(\n          \"MacroAccess\",\n          46354,\n          46433,\n          95,\n          1389,\n          {\n            macroName: \"for\",\n            macroData: {\n              init: __wrap(init, 228),\n              test: __wrap(test, 228),\n              step: __wrap(increment, 228),\n              body: __wrap(body, 228),\n              elseBody: __wrap(elseBody, 228)\n            }\n          },\n          \"expression\",\n          false\n        );\n      } else if (this.position === \"expression\") {\n        return __node(\n          \"MacroAccess\",\n          46485,\n          46564,\n          95,\n          1394,\n          {\n            macroName: \"for\",\n            macroData: {\n              init: __wrap(init, 228),\n              test: __wrap(test, 228),\n              step: __wrap(increment, 228),\n              body: __wrap(body, 228),\n              elseBody: __wrap(elseBody, 228)\n            }\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        return __node(\n          \"MacroAccess\",\n          46598,\n          46682,\n          95,\n          1400,\n          {\n            macroName: \"for\",\n            macroData: {\n              init: __wrap(init, 228),\n              test: __wrap(test, 228),\n              step: __wrap(increment, 228),\n              body: __wrap(body, 228),\n              elseBody: __wrap(elseBody, 228)\n            }\n          },\n          \"statement\",\n          false\n        );\n      }\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"reducer","asType":{"type":"many","multiplier":"?","inner":{"type":"choice","choices":[{"type":"const","value":"every"},{"type":"const","value":"some"},{"type":"const","value":"first"},{"type":"const","value":"filter"}]}}},{"type":"ident","name":"value","asType":{"type":"ident","name":"Declarable"}},{"type":"ident","name":"index","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"ident","name":"value","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"length","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}}]}}},{"type":"const","value":"in"},{"type":"ident","name":"array","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"elseBody","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"else"},{"type":"this","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}}],"names":["for"],"id":102},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, array, body, current, currentStart, index, length, macroName, value;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    value = _p2.value;\n    index = _p2.index;\n    array = _p2.array;\n    current = _p2.current;\n    currentStart = _p2.currentStart;\n    body = _p2.body;\n    value = this.macroExpand1(value);\n    body = this.mutateLast(body || this.noop(), function (node) {\n      return __node(\n        \"Assign\",\n        47006,\n        47024,\n        __wrap(current, 267),\n        \"=\",\n        __wrap(node, 267)\n      );\n    });\n    if (typeof index !== \"undefined\" && index !== null) {\n      length = index.length;\n    }\n    index = typeof index !== \"undefined\" && index !== null ? index.value : void 0;\n    return __node(\n      \"Block\",\n      47091,\n      47207,\n      [\n        __node(\n          \"MacroAccess\",\n          47097,\n          47134,\n          29,\n          1411,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                47100,\n                47117,\n                28,\n                1411,\n                __node(\n                  \"MacroAccess\",\n                  47100,\n                  47117,\n                  22,\n                  1411,\n                  {\n                    isMutable: \"mutable\",\n                    ident: __wrap(current, 266)\n                  },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __wrap(currentStart, 266)\n            }\n          },\n          \"statement\",\n          false\n        ),\n        __node(\n          \"MacroAccess\",\n          47141,\n          47192,\n          102,\n          1412,\n          {\n            macroName: \"for\",\n            macroData: {\n              value: __node(\n                \"MacroAccess\",\n                47144,\n                47151,\n                28,\n                1412,\n                __node(\n                  \"MacroAccess\",\n                  47144,\n                  47151,\n                  22,\n                  1412,\n                  { ident: __wrap(value, 266) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              index: {\n                value: __wrap(index, 266),\n                length: __wrap(length, 266)\n              },\n              array: __wrap(array, 266),\n              body: __wrap(body, 266)\n            }\n          },\n          \"statement\",\n          false\n        ),\n        __wrap(current, 266)\n      ],\n      null\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"const","value":"reduce"},{"type":"ident","name":"value","asType":{"type":"ident","name":"Declarable"}},{"type":"ident","name":"index","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"ident","name":"value","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"length","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}}]}}},{"type":"const","value":"in"},{"type":"ident","name":"array","asType":{"type":"ident","name":"Logic"}},{"type":"const","value":","},{"type":"ident","name":"current","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":"="},{"type":"ident","name":"currentStart"},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}],"names":["for"],"id":103},{"code":"return (function () {\n  \"use strict\";\n  var __strnum, __typeof;\n  __strnum = function (strnum) {\n    var type;\n    type = typeof strnum;\n    if (type === \"string\") {\n      return strnum;\n    } else if (type === \"number\") {\n      return String(strnum);\n    } else {\n      throw TypeError(\"Expected a string or number, got \" + __typeof(strnum));\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var _p2, arr, body, elseBody, func, index, init, key, letIndex, letValue, loop, macroName, object, own, post, reducer, runElse, type, value, valueIdent;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    reducer = _p2.reducer;\n    key = _p2.key;\n    value = _p2.value;\n    type = _p2.type;\n    object = _p2.object;\n    body = _p2.body;\n    elseBody = _p2.elseBody;\n    index = null;\n    if (value) {\n      index = value.index;\n      value = this.macroExpand1(value.value);\n    }\n    own = type === \"of\";\n    init = [];\n    if (own || value) {\n      object = this.cache(object, init, \"obj\", false);\n    }\n    this[\"let\"](key, false, this.type(\"string\"));\n    letValue = value && this.macroExpandAll(__node(\n      \"MacroAccess\",\n      47829,\n      47856,\n      29,\n      1428,\n      {\n        macroName: \"let\",\n        macroData: {\n          declarable: __node(\n            \"MacroAccess\",\n            47833,\n            47840,\n            28,\n            1428,\n            __node(\n              \"MacroAccess\",\n              47833,\n              47840,\n              22,\n              1428,\n              { ident: __wrap(value, 269) },\n              \"statement\",\n              false\n            ),\n            \"statement\",\n            false\n          ),\n          value: __node(\n            \"Access\",\n            47842,\n            47856,\n            __wrap(object, 269),\n            __wrap(key, 269)\n          )\n        }\n      },\n      \"statement\",\n      false\n    ));\n    letIndex = index && this.macroExpandAll(__node(\n      \"MacroAccess\",\n      47908,\n      47932,\n      29,\n      1429,\n      {\n        macroName: \"let\",\n        macroData: {\n          declarable: __node(\n            \"MacroAccess\",\n            47912,\n            47927,\n            28,\n            1429,\n            __node(\n              \"MacroAccess\",\n              47912,\n              47927,\n              22,\n              1429,\n              {\n                isMutable: \"mutable\",\n                ident: __wrap(index, 269)\n              },\n              \"statement\",\n              false\n            ),\n            \"statement\",\n            false\n          ),\n          value: __node(\n            \"MacroAccess\",\n            47929,\n            47932,\n            48,\n            1429,\n            {\n              op: \"-\",\n              node: __node(\"Const\", 47931, 47932, 1)\n            },\n            \"expression\",\n            false\n          )\n        }\n      },\n      \"statement\",\n      false\n    ));\n    if (this.hasFunc(body)) {\n      func = this.tmp(\"f\", false, \"function\");\n      if (value) {\n        if (value.type === \"ident\") {\n          valueIdent = value.ident;\n        } else {\n          valueIdent = this.tmp(\"v\", false);\n        }\n      }\n      if (value && valueIdent !== value.ident) {\n        body = __node(\n          \"Block\",\n          48166,\n          48217,\n          [\n            __node(\n              \"MacroAccess\",\n              48176,\n              48201,\n              29,\n              1435,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    48179,\n                    48186,\n                    28,\n                    1435,\n                    __node(\n                      \"MacroAccess\",\n                      48179,\n                      48186,\n                      22,\n                      1435,\n                      { ident: __wrap(value, 269) },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __wrap(valueIdent, 269)\n                }\n              },\n              \"statement\",\n              false\n            ),\n            __wrap(body, 269)\n          ],\n          null\n        );\n      }\n      if (index) {\n        init.push(__node(\n          \"MacroAccess\",\n          48255,\n          48306,\n          29,\n          1438,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                48259,\n                48265,\n                28,\n                1438,\n                __node(\n                  \"MacroAccess\",\n                  48259,\n                  48265,\n                  22,\n                  1438,\n                  { ident: __wrap(func, 269) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __node(\n                \"Function\",\n                48269,\n                48306,\n                [\n                  __node(\n                    \"Param\",\n                    48270,\n                    48274,\n                    __wrap(key, 279),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  ),\n                  __node(\n                    \"Param\",\n                    48275,\n                    48288,\n                    __wrap(valueIdent, 279),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  ),\n                  __node(\n                    \"Param\",\n                    48289,\n                    48296,\n                    __wrap(index, 279),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  )\n                ],\n                __wrap(body, 279),\n                true,\n                false,\n                void 0,\n                false\n              )\n            }\n          },\n          \"statement\",\n          false\n        ));\n        body = __node(\n          \"Call\",\n          48329,\n          48371,\n          __wrap(func, 269),\n          [\n            __node(\"This\", 48337, 48341),\n            __wrap(key, 269),\n            __node(\n              \"Access\",\n              48348,\n              48362,\n              __wrap(object, 269),\n              __wrap(key, 269)\n            ),\n            __wrap(index, 269)\n          ],\n          false,\n          true\n        );\n      } else if (value) {\n        init.push(__node(\n          \"MacroAccess\",\n          48415,\n          48458,\n          29,\n          1441,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                48419,\n                48425,\n                28,\n                1441,\n                __node(\n                  \"MacroAccess\",\n                  48419,\n                  48425,\n                  22,\n                  1441,\n                  { ident: __wrap(func, 269) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __node(\n                \"Function\",\n                48429,\n                48458,\n                [\n                  __node(\n                    \"Param\",\n                    48430,\n                    48434,\n                    __wrap(key, 281),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  ),\n                  __node(\n                    \"Param\",\n                    48435,\n                    48448,\n                    __wrap(valueIdent, 281),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  )\n                ],\n                __wrap(body, 281),\n                true,\n                false,\n                void 0,\n                false\n              )\n            }\n          },\n          \"statement\",\n          false\n        ));\n        body = __node(\n          \"Call\",\n          48481,\n          48515,\n          __wrap(func, 269),\n          [\n            __node(\"This\", 48489, 48493),\n            __wrap(key, 269),\n            __node(\n              \"Access\",\n              48500,\n              48514,\n              __wrap(object, 269),\n              __wrap(key, 269)\n            )\n          ],\n          false,\n          true\n        );\n      } else {\n        init.push(__node(\n          \"MacroAccess\",\n          48550,\n          48579,\n          29,\n          1444,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                48554,\n                48560,\n                28,\n                1444,\n                __node(\n                  \"MacroAccess\",\n                  48554,\n                  48560,\n                  22,\n                  1444,\n                  { ident: __wrap(func, 269) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __node(\n                \"Function\",\n                48564,\n                48579,\n                [\n                  __node(\n                    \"Param\",\n                    48565,\n                    48569,\n                    __wrap(key, 283),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  )\n                ],\n                __wrap(body, 283),\n                true,\n                false,\n                void 0,\n                false\n              )\n            }\n          },\n          \"statement\",\n          false\n        ));\n        body = __node(\n          \"Call\",\n          48602,\n          48621,\n          __wrap(func, 269),\n          [\n            __node(\"This\", 48610, 48614),\n            __wrap(key, 269)\n          ],\n          false,\n          true\n        );\n      }\n    } else if (value) {\n      body = __node(\n        \"Block\",\n        48659,\n        48691,\n        [\n          __wrap(letValue, 269),\n          __wrap(body, 269)\n        ],\n        null\n      );\n    }\n    post = [];\n    if (elseBody) {\n      runElse = this.tmp(\"else\", false, \"boolean\");\n      init.push(__node(\n        \"MacroAccess\",\n        48797,\n        48818,\n        29,\n        1454,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              48801,\n              48811,\n              28,\n              1454,\n              __node(\n                \"MacroAccess\",\n                48801,\n                48811,\n                22,\n                1454,\n                { ident: __wrap(runElse, 269) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\"Const\", 48813, 48818, true)\n          }\n        },\n        \"statement\",\n        false\n      ));\n      body = __node(\n        \"Block\",\n        48838,\n        48878,\n        [\n          __node(\n            \"Assign\",\n            48846,\n            48864,\n            __wrap(runElse, 269),\n            \"=\",\n            __node(\"Const\", 48858, 48864, false)\n          ),\n          __wrap(body, 269)\n        ],\n        null\n      );\n      post.push(__node(\n        \"MacroAccess\",\n        48907,\n        48940,\n        19,\n        1459,\n        {\n          macroName: \"if\",\n          macroData: {\n            test: __wrap(runElse, 269),\n            body: __wrap(elseBody, 269),\n            elseIfs: []\n          }\n        },\n        \"statement\",\n        false\n      ));\n    }\n    if (index) {\n      init.push(letIndex);\n      body = __node(\n        \"Block\",\n        49001,\n        49035,\n        [\n          __node(\n            \"MacroAccess\",\n            49009,\n            49021,\n            41,\n            1465,\n            {\n              left: __wrap(index, 269),\n              op: \"~+=\",\n              right: __node(\"Const\", 49020, 49021, 1)\n            },\n            \"statement\",\n            false\n          ),\n          __wrap(body, 269)\n        ],\n        null\n      );\n    }\n    if (own) {\n      body = __node(\n        \"MacroAccess\",\n        49076,\n        49115,\n        19,\n        1470,\n        {\n          macroName: \"if\",\n          macroData: {\n            test: __node(\n              \"MacroAccess\",\n              49078,\n              49099,\n              60,\n              1470,\n              {\n                left: __wrap(object, 269),\n                inverted: false,\n                op: \"ownskey\",\n                right: __wrap(key, 269)\n              },\n              \"statement\",\n              false\n            ),\n            body: __wrap(body, 269),\n            elseIfs: []\n          }\n        },\n        \"statement\",\n        false\n      );\n    }\n    if (reducer) {\n      if (reducer === \"first\") {\n        body = this.mutateLast(body || this.noop(), function (node) {\n          return __node(\n            \"MacroAccess\",\n            49222,\n            49235,\n            30,\n            1475,\n            {\n              macroName: \"return\",\n              macroData: { node: __wrap(node, 287) }\n            },\n            \"statement\",\n            false\n          );\n        });\n        loop = this.forIn(key, object, body);\n        return __node(\n          \"MacroAccess\",\n          49294,\n          49350,\n          0,\n          1477,\n          {\n            macroName: \"do\",\n            macroData: {\n              body: __node(\n                \"Block\",\n                49298,\n                49350,\n                [\n                  __wrap(init, 269),\n                  __wrap(loop, 269),\n                  __wrap(elseBody, 269)\n                ],\n                null\n              )\n            }\n          },\n          \"statement\",\n          false\n        );\n      } else {\n        if (elseBody) {\n          throw Error(\"Cannot use a for loop with an else with \" + __strnum(reducer));\n        }\n        if (reducer === \"some\") {\n          body = this.mutateLast(body || this.noop(), function (node) {\n            return __node(\n              \"MacroAccess\",\n              49560,\n              49594,\n              19,\n              1486,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __wrap(node, 289),\n                  body: __node(\n                    \"MacroAccess\",\n                    49583,\n                    49594,\n                    30,\n                    1487,\n                    {\n                      macroName: \"return\",\n                      macroData: { node: __node(\"Const\", 49589, 49594, true) }\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  elseIfs: []\n                }\n              },\n              \"statement\",\n              false\n            );\n          });\n          loop = this.forIn(key, object, body);\n          return __node(\n            \"MacroAccess\",\n            49656,\n            49713,\n            0,\n            1489,\n            {\n              macroName: \"do\",\n              macroData: {\n                body: __node(\n                  \"Block\",\n                  49660,\n                  49713,\n                  [\n                    __wrap(init, 269),\n                    __wrap(loop, 269),\n                    __node(\"Const\", 49708, 49713, false)\n                  ],\n                  null\n                )\n              }\n            },\n            \"statement\",\n            false\n          );\n        } else if (reducer === \"every\") {\n          body = this.mutateLast(body || this.noop(), function (node) {\n            return __node(\n              \"MacroAccess\",\n              49823,\n              49862,\n              19,\n              1495,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __node(\n                    \"MacroAccess\",\n                    49825,\n                    49835,\n                    3,\n                    1495,\n                    {\n                      op: \"not\",\n                      node: __wrap(node, 291)\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  body: __node(\n                    \"MacroAccess\",\n                    49850,\n                    49862,\n                    30,\n                    1496,\n                    {\n                      macroName: \"return\",\n                      macroData: { node: __node(\"Const\", 49856, 49862, false) }\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  elseIfs: []\n                }\n              },\n              \"statement\",\n              false\n            );\n          });\n          loop = this.forIn(key, object, body);\n          return __node(\n            \"MacroAccess\",\n            49924,\n            49980,\n            0,\n            1498,\n            {\n              macroName: \"do\",\n              macroData: {\n                body: __node(\n                  \"Block\",\n                  49928,\n                  49980,\n                  [\n                    __wrap(init, 269),\n                    __wrap(loop, 269),\n                    __node(\"Const\", 49976, 49980, true)\n                  ],\n                  null\n                )\n              }\n            },\n            \"statement\",\n            false\n          );\n        } else {\n          throw Error(\"Unknown reducer: \" + __strnum(reducer));\n        }\n      }\n    } else if (this.position === \"expression\") {\n      if (elseBody) {\n        throw Error(\"Cannot use a for loop with an else as an expression\");\n      }\n      arr = this.tmp(\"arr\", false, this.type(body).array());\n      body = this.mutateLast(body || this.noop(), function (node) {\n        return __node(\n          \"Call\",\n          50290,\n          50306,\n          __node(\n            \"Access\",\n            50290,\n            50306,\n            __wrap(arr, 294),\n            __node(\"Const\", 50296, 50300, \"push\")\n          ),\n          [__wrap(node, 294)],\n          false,\n          false\n        );\n      });\n      init = __node(\n        \"Block\",\n        50326,\n        50358,\n        [\n          __node(\n            \"Assign\",\n            50334,\n            50344,\n            __wrap(arr, 269),\n            \"=\",\n            __node(\"Array\", 50341, 50344, [])\n          ),\n          __wrap(init, 269)\n        ],\n        null\n      );\n      loop = this.forIn(key, object, body);\n      return __node(\n        \"Block\",\n        50413,\n        50453,\n        [\n          __wrap(init, 269),\n          __wrap(loop, 269),\n          __wrap(arr, 269)\n        ],\n        null\n      );\n    } else {\n      loop = this.forIn(key, object, body);\n      return __node(\n        \"Block\",\n        50517,\n        50558,\n        [\n          __wrap(init, 269),\n          __wrap(loop, 269),\n          __wrap(post, 269)\n        ],\n        null\n      );\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"reducer","asType":{"type":"many","multiplier":"?","inner":{"type":"choice","choices":[{"type":"const","value":"every"},{"type":"const","value":"some"},{"type":"const","value":"first"}]}}},{"type":"ident","name":"key","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"value","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"ident","name":"value","asType":{"type":"ident","name":"Declarable"}},{"type":"ident","name":"index","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}}]}}},{"type":"ident","name":"type","asType":{"type":"choice","choices":[{"type":"const","value":"of"},{"type":"const","value":"ofall"}]}},{"type":"ident","name":"object","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"elseBody","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"else"},{"type":"this","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}}],"names":["for"],"id":104},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, body, current, currentStart, index, key, loop, macroName, object, type, value;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    key = _p2.key;\n    value = _p2.value;\n    type = _p2.type;\n    object = _p2.object;\n    current = _p2.current;\n    currentStart = _p2.currentStart;\n    body = _p2.body;\n    body = this.mutateLast(body || this.noop(), function (node) {\n      return __node(\n        \"Assign\",\n        50866,\n        50884,\n        __wrap(current, 298),\n        \"=\",\n        __wrap(node, 298)\n      );\n    });\n    if (typeof value !== \"undefined\" && value !== null) {\n      index = value.index;\n    }\n    value = typeof value !== \"undefined\" && value !== null ? value.value : void 0;\n    if (type === \"of\") {\n      loop = __node(\n        \"MacroAccess\",\n        50981,\n        51031,\n        104,\n        1529,\n        {\n          macroName: \"for\",\n          macroData: {\n            key: __wrap(key, 297),\n            value: {\n              value: __node(\n                \"MacroAccess\",\n                50991,\n                50998,\n                28,\n                1529,\n                __node(\n                  \"MacroAccess\",\n                  50991,\n                  50998,\n                  22,\n                  1529,\n                  { ident: __wrap(value, 297) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              index: __wrap(index, 297)\n            },\n            type: \"of\",\n            object: __wrap(object, 297),\n            body: __wrap(body, 297)\n          }\n        },\n        \"statement\",\n        false\n      );\n    } else {\n      loop = __node(\n        \"MacroAccess\",\n        51050,\n        51103,\n        104,\n        1532,\n        {\n          macroName: \"for\",\n          macroData: {\n            key: __wrap(key, 297),\n            value: {\n              value: __node(\n                \"MacroAccess\",\n                51060,\n                51067,\n                28,\n                1532,\n                __node(\n                  \"MacroAccess\",\n                  51060,\n                  51067,\n                  22,\n                  1532,\n                  { ident: __wrap(value, 297) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              index: __wrap(index, 297)\n            },\n            type: \"ofall\",\n            object: __wrap(object, 297),\n            body: __wrap(body, 297)\n          }\n        },\n        \"statement\",\n        false\n      );\n    }\n    return __node(\n      \"Block\",\n      51112,\n      51182,\n      [\n        __node(\n          \"MacroAccess\",\n          51118,\n          51155,\n          29,\n          1535,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                51121,\n                51138,\n                28,\n                1535,\n                __node(\n                  \"MacroAccess\",\n                  51121,\n                  51138,\n                  22,\n                  1535,\n                  {\n                    isMutable: \"mutable\",\n                    ident: __wrap(current, 297)\n                  },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __wrap(currentStart, 297)\n            }\n          },\n          \"statement\",\n          false\n        ),\n        __wrap(loop, 297),\n        __wrap(current, 297)\n      ],\n      null\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"const","value":"reduce"},{"type":"ident","name":"key","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"value","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"ident","name":"value","asType":{"type":"ident","name":"Declarable"}},{"type":"ident","name":"index","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}}]}}},{"type":"ident","name":"type","asType":{"type":"choice","choices":[{"type":"const","value":"of"},{"type":"const","value":"ofall"}]}},{"type":"ident","name":"object","asType":{"type":"ident","name":"Logic"}},{"type":"const","value":","},{"type":"ident","name":"current","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":"="},{"type":"ident","name":"currentStart"},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}],"names":["for"],"id":105},{"code":"return (function () {\n  \"use strict\";\n  var __isArray, __slice, __toArray, __typeof;\n  __isArray = typeof Array.isArray === \"function\" ? Array.isArray\n    : (function () {\n      var _toString;\n      _toString = Object.prototype.toString;\n      return function (x) {\n        return _toString.call(x) === \"[object Array]\";\n      };\n    }());\n  __slice = Array.prototype.slice;\n  __toArray = function (x) {\n    if (x == null) {\n      throw TypeError(\"Expected an object, got \" + __typeof(x));\n    } else if (__isArray(x)) {\n      return x;\n    } else if (typeof x === \"string\") {\n      return x.split(\"\");\n    } else {\n      return __slice.call(x);\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var _p2, _this, catchBody, catchIdent, catchPart, current, elseBody, finallyBody, hasElse, init, macroName, runElse, tryBody, typedCatches;\n    _this = this;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    tryBody = _p2.tryBody;\n    typedCatches = _p2.typedCatches;\n    catchPart = _p2.catchPart;\n    elseBody = _p2.elseBody;\n    finallyBody = _p2.finallyBody;\n    hasElse = !!elseBody;\n    if (!catchPart && hasElse && !finallyBody) {\n      throw Error(\"Must provide at least a catch, else, or finally to a try block\");\n    }\n    if (typeof catchPart !== \"undefined\" && catchPart !== null) {\n      catchIdent = catchPart.ident;\n    }\n    if (typeof catchPart !== \"undefined\" && catchPart !== null) {\n      catchBody = catchPart.body;\n    }\n    if (typedCatches.length !== 0) {\n      if (!catchIdent) {\n        catchIdent = typedCatches[0].ident;\n      }\n      catchBody = (function () {\n        var _arr, _f, _i, current;\n        current = catchBody || __node(\n          \"MacroAccess\",\n          52865,\n          52884,\n          11,\n          1577,\n          {\n            op: \"throw\",\n            node: __wrap(catchIdent, 308)\n          },\n          \"statement\",\n          false\n        );\n        for (_arr = __toArray(typedCatches), _i = _arr.length, _f = function (typeCatch) {\n          var _this, letErr, typeIdent, types;\n          _this = this;\n          typeIdent = typeCatch.ident;\n          if (this.name(typeIdent) !== this.name(catchIdent)) {\n            letErr = __node(\n              \"MacroAccess\",\n              53005,\n              53036,\n              29,\n              1580,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    53009,\n                    53021,\n                    28,\n                    1580,\n                    __node(\n                      \"MacroAccess\",\n                      53009,\n                      53021,\n                      22,\n                      1580,\n                      { ident: __wrap(typeIdent, 308) },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __wrap(catchIdent, 308)\n                }\n              },\n              \"statement\",\n              false\n            );\n          } else {\n            letErr = this.noop();\n          }\n          types = this.array((function () {\n            var _arr, _arr2, _i, _len, type;\n            for (_arr = [], _arr2 = __toArray(_this.isTypeUnion(typeCatch.type) ? _this.types(typeCatch.type) : [typeCatch.type]), _i = 0, _len = _arr2.length; _i < _len; ++_i) {\n              type = _arr2[_i];\n              if (_this.isTypeArray(type)) {\n                throw Error(\"Expected a normal type, cannot use an array type\");\n              } else if (_this.isTypeFunction(type)) {\n                throw Error(\"Expected a normal type, cannot use a function type\");\n              } else if (_this.isTypeObject(type)) {\n                throw Error(\"Expected a normal type, cannot use an object type\");\n              }\n              _arr.push(type);\n            }\n            return _arr;\n          }()));\n          return current = __node(\n            \"MacroAccess\",\n            53577,\n            53702,\n            19,\n            1592,\n            {\n              macroName: \"if\",\n              macroData: {\n                test: __node(\n                  \"MacroAccess\",\n                  53579,\n                  53614,\n                  106,\n                  1592,\n                  {\n                    left: __wrap(catchIdent, 308),\n                    inverted: false,\n                    op: \"instanceofsome\",\n                    right: __wrap(types, 308)\n                  },\n                  \"statement\",\n                  false\n                ),\n                body: __node(\n                  \"Block\",\n                  53615,\n                  53666,\n                  [\n                    __wrap(letErr, 308),\n                    __wrap(typeCatch.body, 308)\n                  ],\n                  null\n                ),\n                elseIfs: [],\n                elseBody: __wrap(current, 308)\n              }\n            },\n            \"statement\",\n            false\n          );\n        }; _i--; ) {\n          _f.call(_this, _arr[_i]);\n        }\n        return current;\n      }());\n    }\n    init = [];\n    if (hasElse) {\n      runElse = this.tmp(\"else\", false, \"boolean\");\n      init.push(__node(\n        \"MacroAccess\",\n        53834,\n        53855,\n        29,\n        1601,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              53838,\n              53848,\n              28,\n              1601,\n              __node(\n                \"MacroAccess\",\n                53838,\n                53848,\n                22,\n                1601,\n                { ident: __wrap(runElse, 308) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\"Const\", 53850, 53855, true)\n          }\n        },\n        \"statement\",\n        false\n      ));\n      if (catchBody) {\n        catchBody = __node(\n          \"Block\",\n          53902,\n          53952,\n          [\n            __node(\n              \"Assign\",\n              53912,\n              53930,\n              __wrap(runElse, 308),\n              \"=\",\n              __node(\"Const\", 53924, 53930, false)\n            ),\n            __wrap(catchBody, 308)\n          ],\n          null\n        );\n      } else {\n        catchIdent = this.tmp(\"err\");\n        catchBody = __node(\n          \"Block\",\n          54023,\n          54080,\n          [\n            __node(\n              \"Assign\",\n              54033,\n              54051,\n              __wrap(runElse, 308),\n              \"=\",\n              __node(\"Const\", 54045, 54051, false)\n            ),\n            __node(\n              \"MacroAccess\",\n              54062,\n              54080,\n              11,\n              1610,\n              {\n                op: \"throw\",\n                node: __wrap(catchIdent, 308)\n              },\n              \"statement\",\n              false\n            )\n          ],\n          null\n        );\n      }\n    }\n    current = tryBody;\n    if (catchBody) {\n      current = this.tryCatch(current, catchIdent, catchBody);\n    }\n    if (hasElse) {\n      current = this.tryFinally(current, __node(\n        \"MacroAccess\",\n        54264,\n        54297,\n        19,\n        1617,\n        {\n          macroName: \"if\",\n          macroData: {\n            test: __wrap(runElse, 308),\n            body: __wrap(elseBody, 308),\n            elseIfs: []\n          }\n        },\n        \"statement\",\n        false\n      ));\n    }\n    if (finallyBody) {\n      current = this.tryFinally(current, finallyBody);\n    }\n    return __node(\n      \"Block\",\n      54380,\n      54406,\n      [\n        __wrap(init, 308),\n        __wrap(current, 308)\n      ],\n      null\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"tryBody","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"typedCatches","asType":{"type":"many","multiplier":"*","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"catch"},{"type":"ident","name":"ident","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":"as"},{"type":"ident","name":"type","asType":{"type":"ident","name":"Type"}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}},{"type":"ident","name":"catchPart","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"catch"},{"type":"ident","name":"ident","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}},{"type":"ident","name":"elseBody","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"else"},{"type":"this","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}},{"type":"ident","name":"finallyBody","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"finally"},{"type":"this","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}}],"names":["try"],"id":107},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, body, captureValue, elseBody, func, index, init, iterable, iterator, macroName, main, post, reducer, runElse, step, value;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    reducer = _p2.reducer;\n    value = _p2.value;\n    index = _p2.index;\n    iterable = _p2.iterable;\n    body = _p2.body;\n    elseBody = _p2.elseBody;\n    init = [];\n    iterator = this.cache(\n      __node(\n        \"Call\",\n        54724,\n        54745,\n        __node(\n          \"Access\",\n          54724,\n          54745,\n          __wrap(iterable, 318),\n          __node(\"Const\", 54735, 54743, \"iterator\")\n        ),\n        [],\n        false,\n        false\n      ),\n      init,\n      \"iter\",\n      false\n    );\n    step = [];\n    if (index) {\n      init.push(__node(\n        \"MacroAccess\",\n        54821,\n        54844,\n        29,\n        1634,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              54825,\n              54840,\n              28,\n              1634,\n              __node(\n                \"MacroAccess\",\n                54825,\n                54840,\n                22,\n                1634,\n                {\n                  isMutable: \"mutable\",\n                  ident: __wrap(index, 318)\n                },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\"Const\", 54843, 54844, 0)\n          }\n        },\n        \"statement\",\n        false\n      ));\n      step.push(__node(\n        \"MacroAccess\",\n        54865,\n        54878,\n        41,\n        1635,\n        {\n          left: __wrap(index, 318),\n          op: \"~+=\",\n          right: __node(\"Const\", 54877, 54878, 1)\n        },\n        \"expression\",\n        false\n      ));\n    }\n    captureValue = __node(\n      \"MacroAccess\",\n      54909,\n      55030,\n      107,\n      1637,\n      {\n        macroName: \"try\",\n        macroData: {\n          tryBody: __node(\n            \"MacroAccess\",\n            54920,\n            54949,\n            29,\n            1638,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  54923,\n                  54930,\n                  28,\n                  1638,\n                  __node(\n                    \"MacroAccess\",\n                    54923,\n                    54930,\n                    22,\n                    1638,\n                    { ident: __wrap(value, 318) },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\n                  \"Call\",\n                  54932,\n                  54949,\n                  __node(\n                    \"Access\",\n                    54932,\n                    54949,\n                    __wrap(iterator, 318),\n                    __node(\"Const\", 54943, 54947, \"next\")\n                  ),\n                  [],\n                  false,\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          ),\n          typedCatches: [],\n          catchPart: {\n            ident: __node(\"Ident\", 54959, 54961, \"e\"),\n            body: __node(\n              \"MacroAccess\",\n              54968,\n              55030,\n              19,\n              1640,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __node(\n                    \"MacroAccess\",\n                    54970,\n                    54989,\n                    5,\n                    1640,\n                    {\n                      left: __node(\"Ident\", 54970, 54972, \"e\"),\n                      inverted: false,\n                      op: \"==\",\n                      right: __node(\"Ident\", 54975, 54989, \"StopIteration\")\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  body: __node(\n                    \"MacroAccess\",\n                    54998,\n                    55003,\n                    16,\n                    1641,\n                    { macroName: \"break\", macroData: {} },\n                    \"statement\",\n                    false\n                  ),\n                  elseIfs: [],\n                  elseBody: __node(\n                    \"MacroAccess\",\n                    55023,\n                    55030,\n                    11,\n                    1643,\n                    {\n                      op: \"throw\",\n                      node: __node(\"Ident\", 55028, 55030, \"e\")\n                    },\n                    \"statement\",\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            )\n          }\n        }\n      },\n      \"statement\",\n      false\n    );\n    post = [];\n    if (elseBody && !reducer && this.position !== \"expression\") {\n      runElse = this.tmp(\"else\", false, \"boolean\");\n      init.push(__node(\n        \"MacroAccess\",\n        55183,\n        55204,\n        29,\n        1648,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              55187,\n              55197,\n              28,\n              1648,\n              __node(\n                \"MacroAccess\",\n                55187,\n                55197,\n                22,\n                1648,\n                { ident: __wrap(runElse, 318) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\"Const\", 55199, 55204, true)\n          }\n        },\n        \"statement\",\n        false\n      ));\n      body = __node(\n        \"Block\",\n        55224,\n        55264,\n        [\n          __node(\n            \"Assign\",\n            55232,\n            55250,\n            __wrap(runElse, 318),\n            \"=\",\n            __node(\"Const\", 55244, 55250, false)\n          ),\n          __wrap(body, 318)\n        ],\n        null\n      );\n      post.push(__node(\n        \"MacroAccess\",\n        55293,\n        55326,\n        19,\n        1653,\n        {\n          macroName: \"if\",\n          macroData: {\n            test: __wrap(runElse, 318),\n            body: __wrap(elseBody, 318),\n            elseIfs: []\n          }\n        },\n        \"statement\",\n        false\n      ));\n    }\n    if (this.hasFunc(body)) {\n      func = this.tmp(\"f\", false, \"function\");\n      if (!index) {\n        init.push(__node(\n          \"MacroAccess\",\n          55434,\n          55465,\n          29,\n          1659,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                55438,\n                55444,\n                28,\n                1659,\n                __node(\n                  \"MacroAccess\",\n                  55438,\n                  55444,\n                  22,\n                  1659,\n                  { ident: __wrap(func, 318) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __node(\n                \"Function\",\n                55448,\n                55465,\n                [\n                  __node(\n                    \"Param\",\n                    55449,\n                    55455,\n                    __wrap(value, 329),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  )\n                ],\n                __wrap(body, 329),\n                true,\n                false,\n                void 0,\n                false\n              )\n            }\n          },\n          \"statement\",\n          false\n        ));\n        body = __node(\n          \"Block\",\n          55486,\n          55541,\n          [\n            __wrap(captureValue, 318),\n            __node(\n              \"Call\",\n              55521,\n              55541,\n              __wrap(func, 318),\n              [\n                __node(\"This\", 55528, 55532),\n                __wrap(value, 318)\n              ],\n              false,\n              true\n            )\n          ],\n          null\n        );\n      } else {\n        init.push(__node(\n          \"MacroAccess\",\n          55574,\n          55613,\n          29,\n          1664,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                55578,\n                55584,\n                28,\n                1664,\n                __node(\n                  \"MacroAccess\",\n                  55578,\n                  55584,\n                  22,\n                  1664,\n                  { ident: __wrap(func, 318) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __node(\n                \"Function\",\n                55588,\n                55613,\n                [\n                  __node(\n                    \"Param\",\n                    55589,\n                    55595,\n                    __wrap(value, 331),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  ),\n                  __node(\n                    \"Param\",\n                    55596,\n                    55603,\n                    __wrap(index, 331),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  )\n                ],\n                __wrap(body, 331),\n                true,\n                false,\n                void 0,\n                false\n              )\n            }\n          },\n          \"statement\",\n          false\n        ));\n        body = __node(\n          \"Block\",\n          55634,\n          55697,\n          [\n            __wrap(captureValue, 318),\n            __node(\n              \"Call\",\n              55669,\n              55697,\n              __wrap(func, 318),\n              [\n                __node(\"This\", 55676, 55680),\n                __wrap(value, 318),\n                __wrap(index, 318)\n              ],\n              false,\n              true\n            )\n          ],\n          null\n        );\n      }\n    } else {\n      body = __node(\n        \"Block\",\n        55725,\n        55761,\n        [\n          __wrap(captureValue, 318),\n          __wrap(body, 318)\n        ],\n        null\n      );\n    }\n    if (reducer === \"every\") {\n      main = __node(\n        \"MacroAccess\",\n        55809,\n        55882,\n        95,\n        1674,\n        {\n          macroName: \"for\",\n          macroData: {\n            reducer: \"every\",\n            init: __wrap(init, 318),\n            test: __node(\"Const\", 55826, 55831, true),\n            step: __wrap(step, 318),\n            body: __wrap(body, 318),\n            elseBody: __wrap(elseBody, 318)\n          }\n        },\n        \"expression\",\n        false\n      );\n    } else if (reducer === \"some\") {\n      main = __node(\n        \"MacroAccess\",\n        55922,\n        55994,\n        95,\n        1679,\n        {\n          macroName: \"for\",\n          macroData: {\n            reducer: \"some\",\n            init: __wrap(init, 318),\n            test: __node(\"Const\", 55938, 55943, true),\n            step: __wrap(step, 318),\n            body: __wrap(body, 318),\n            elseBody: __wrap(elseBody, 318)\n          }\n        },\n        \"expression\",\n        false\n      );\n    } else if (reducer === \"first\") {\n      main = __node(\n        \"MacroAccess\",\n        56035,\n        56108,\n        95,\n        1684,\n        {\n          macroName: \"for\",\n          macroData: {\n            reducer: \"first\",\n            init: __wrap(init, 318),\n            test: __node(\"Const\", 56052, 56057, true),\n            step: __wrap(step, 318),\n            body: __wrap(body, 318),\n            elseBody: __wrap(elseBody, 318)\n          }\n        },\n        \"expression\",\n        false\n      );\n    } else if (reducer === \"filter\") {\n      body = this.mutateLast(body, function (node) {\n        return __node(\n          \"MacroAccess\",\n          56192,\n          56218,\n          19,\n          1690,\n          {\n            macroName: \"if\",\n            macroData: {\n              test: __wrap(node, 333),\n              body: __wrap(value, 333),\n              elseIfs: []\n            }\n          },\n          \"statement\",\n          false\n        );\n      });\n      main = __node(\n        \"MacroAccess\",\n        56229,\n        56296,\n        95,\n        1692,\n        {\n          macroName: \"for\",\n          macroData: {\n            init: __wrap(init, 318),\n            test: __node(\"Const\", 56240, 56245, true),\n            step: __wrap(step, 318),\n            body: __wrap(body, 318),\n            elseBody: __wrap(elseBody, 318)\n          }\n        },\n        \"expression\",\n        false\n      );\n    } else if (this.position === \"expression\") {\n      main = __node(\n        \"MacroAccess\",\n        56344,\n        56411,\n        95,\n        1697,\n        {\n          macroName: \"for\",\n          macroData: {\n            init: __wrap(init, 318),\n            test: __node(\"Const\", 56355, 56360, true),\n            step: __wrap(step, 318),\n            body: __wrap(body, 318),\n            elseBody: __wrap(elseBody, 318)\n          }\n        },\n        \"expression\",\n        false\n      );\n    } else {\n      main = __node(\n        \"Block\",\n        56431,\n        56491,\n        [\n          __node(\n            \"MacroAccess\",\n            56439,\n            56477,\n            95,\n            1703,\n            {\n              macroName: \"for\",\n              macroData: {\n                init: __wrap(init, 318),\n                test: __node(\"Const\", 56449, 56454, true),\n                step: __wrap(step, 318),\n                body: __wrap(body, 318)\n              }\n            },\n            \"statement\",\n            false\n          ),\n          __wrap(post, 318)\n        ],\n        null\n      );\n    }\n    return __node(\n      \"MacroAccess\",\n      56504,\n      56558,\n      107,\n      1707,\n      {\n        macroName: \"try\",\n        macroData: {\n          tryBody: __wrap(main, 318),\n          typedCatches: [],\n          finallyBody: __node(\n            \"If\",\n            56539,\n            56558,\n            __node(\n              \"MacroAccess\",\n              56539,\n              56558,\n              21,\n              1710,\n              {\n                op: \"\",\n                node: __wrap(iterator, 318)\n              },\n              \"statement\",\n              false\n            ),\n            __node(\n              \"If\",\n              56539,\n              56558,\n              __node(\n                \"Binary\",\n                56539,\n                56558,\n                __node(\n                  \"Unary\",\n                  56539,\n                  56558,\n                  \"typeof\",\n                  __node(\n                    \"Access\",\n                    56539,\n                    56558,\n                    __wrap(iterator, 318),\n                    __node(\"Const\", 56550, 56555, \"close\")\n                  )\n                ),\n                \"===\",\n                __node(\"Const\", 56539, 56558, \"function\")\n              ),\n              __node(\n                \"Call\",\n                56539,\n                56558,\n                __node(\n                  \"Access\",\n                  56539,\n                  56558,\n                  __wrap(iterator, 318),\n                  __node(\"Const\", 56550, 56555, \"close\")\n                ),\n                [],\n                false,\n                false\n              ),\n              __node(\"Nothing\", 0, 0),\n              null\n            ),\n            __node(\"Nothing\", 0, 0),\n            null\n          )\n        }\n      },\n      \"statement\",\n      false\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"reducer","asType":{"type":"many","multiplier":"?","inner":{"type":"choice","choices":[{"type":"const","value":"every"},{"type":"const","value":"some"},{"type":"const","value":"first"},{"type":"const","value":"filter"}]}}},{"type":"ident","name":"value","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"index","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}},{"type":"const","value":"from"},{"type":"ident","name":"iterable","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"elseBody","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"else"},{"type":"this","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}}],"names":["for"],"id":108},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, body, current, currentStart, index, iterator, macroName, value;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    value = _p2.value;\n    index = _p2.index;\n    iterator = _p2.iterator;\n    current = _p2.current;\n    currentStart = _p2.currentStart;\n    body = _p2.body;\n    body = this.mutateLast(body || this.noop(), function (node) {\n      return __node(\n        \"Assign\",\n        56812,\n        56830,\n        __wrap(current, 335),\n        \"=\",\n        __wrap(node, 335)\n      );\n    });\n    return __node(\n      \"Block\",\n      56840,\n      56952,\n      [\n        __node(\n          \"MacroAccess\",\n          56846,\n          56883,\n          29,\n          1715,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                56849,\n                56866,\n                28,\n                1715,\n                __node(\n                  \"MacroAccess\",\n                  56849,\n                  56866,\n                  22,\n                  1715,\n                  {\n                    isMutable: \"mutable\",\n                    ident: __wrap(current, 334)\n                  },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __wrap(currentStart, 334)\n            }\n          },\n          \"statement\",\n          false\n        ),\n        __node(\n          \"MacroAccess\",\n          56890,\n          56937,\n          108,\n          1716,\n          {\n            macroName: \"for\",\n            macroData: {\n              value: __wrap(value, 334),\n              index: __wrap(index, 334),\n              iterable: __wrap(iterator, 334),\n              body: __wrap(body, 334)\n            }\n          },\n          \"statement\",\n          false\n        ),\n        __wrap(current, 334)\n      ],\n      null\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"const","value":"reduce"},{"type":"ident","name":"value","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"index","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}},{"type":"const","value":"from"},{"type":"ident","name":"iterator","asType":{"type":"ident","name":"Logic"}},{"type":"const","value":","},{"type":"ident","name":"current","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":"="},{"type":"ident","name":"currentStart"},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}],"names":["for"],"id":109},{"code":"return (function () {\n  \"use strict\";\n  var __isArray, __num, __slice, __toArray, __typeof;\n  __isArray = typeof Array.isArray === \"function\" ? Array.isArray\n    : (function () {\n      var _toString;\n      _toString = Object.prototype.toString;\n      return function (x) {\n        return _toString.call(x) === \"[object Array]\";\n      };\n    }());\n  __num = function (num) {\n    if (typeof num !== \"number\") {\n      throw TypeError(\"Expected a number, got \" + __typeof(num));\n    } else {\n      return num;\n    }\n  };\n  __slice = Array.prototype.slice;\n  __toArray = function (x) {\n    if (x == null) {\n      throw TypeError(\"Expected an object, got \" + __typeof(x));\n    } else if (__isArray(x)) {\n      return x;\n    } else if (typeof x === \"string\") {\n      return x.split(\"\");\n    } else {\n      return __slice.call(x);\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var _arr, _arr2, _i, _i2, _len, _len2, _p2, body, case_, caseNode, caseNodes, cases, defaultCase, isFallthrough, lastNode, macroName, node, nodes, resultCases;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    node = _p2.node;\n    cases = _p2.cases;\n    defaultCase = _p2.defaultCase;\n    resultCases = [];\n    for (_arr = __toArray(cases), _i = 0, _len = _arr.length; _i < _len; ++_i) {\n      case_ = _arr[_i];\n      caseNodes = [case_.nodeHead].concat(case_.nodeTail);\n      body = case_.body;\n      isFallthrough = false;\n      if (this.isBlock(body)) {\n        nodes = this.nodes(body);\n        lastNode = nodes[__num(nodes.length) - 1];\n        if (this.isIdent(lastNode) && this.name(lastNode) === \"fallthrough\") {\n          body = this.block(nodes.slice(0, -1));\n          isFallthrough = true;\n        }\n      } else if (this.isIdent(body) && this.name(body) === \"fallthrough\") {\n        body = this.noop();\n        isFallthrough = true;\n      }\n      for (_arr2 = __toArray(caseNodes.slice(0, -1)), _i2 = 0, _len2 = _arr2.length; _i2 < _len2; ++_i2) {\n        caseNode = _arr2[_i2];\n        resultCases.push({ node: caseNode, body: this.noop(), fallthrough: true });\n      }\n      resultCases.push({ node: caseNodes[__num(caseNodes.length) - 1], body: body, fallthrough: isFallthrough });\n    }\n    return this[\"switch\"](node, resultCases, defaultCase);\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"node","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"cases","asType":{"type":"many","multiplier":"*","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"case"},{"type":"ident","name":"nodeHead","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"nodeTail","asType":{"type":"many","multiplier":"*","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Logic"}}]}}},{"type":"ident","name":"body","asType":{"type":"many","multiplier":"?","inner":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}}]}}},{"type":"ident","name":"defaultCase","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"default"},{"type":"this","asType":{"type":"many","multiplier":"?","inner":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}}]}}}],"names":["switch"],"id":110},{"code":"return (function () {\n  \"use strict\";\n  var __isArray, __num, __slice, __toArray, __typeof;\n  __isArray = typeof Array.isArray === \"function\" ? Array.isArray\n    : (function () {\n      var _toString;\n      _toString = Object.prototype.toString;\n      return function (x) {\n        return _toString.call(x) === \"[object Array]\";\n      };\n    }());\n  __num = function (num) {\n    if (typeof num !== \"number\") {\n      throw TypeError(\"Expected a number, got \" + __typeof(num));\n    } else {\n      return num;\n    }\n  };\n  __slice = Array.prototype.slice;\n  __toArray = function (x) {\n    if (x == null) {\n      throw TypeError(\"Expected an object, got \" + __typeof(x));\n    } else if (__isArray(x)) {\n      return x;\n    } else if (typeof x === \"string\") {\n      return x.split(\"\");\n    } else {\n      return __slice.call(x);\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var _arr, _i, _p2, body, case_, cases, current, defaultCase, fall, isFallthrough, lastNode, macroName, nodes, result, test;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    cases = _p2.cases;\n    defaultCase = _p2.defaultCase;\n    current = defaultCase;\n    for (_arr = __toArray(cases), _i = _arr.length; _i--; ) {\n      case_ = _arr[_i];\n      test = case_.test;\n      body = case_.body;\n      isFallthrough = false;\n      result = void 0;\n      if (this.isBlock(body)) {\n        nodes = this.nodes(body);\n        lastNode = nodes[__num(nodes.length) - 1];\n        if (this.isIdent(lastNode) && this.name(lastNode) === \"fallthrough\") {\n          body = this.block(nodes.slice(0, -1));\n          result = this.isIf(current)\n            ? (fall = this.tmp(\"fall\", false, \"boolean\"), __node(\n              \"Block\",\n              58744,\n              59000,\n              [\n                __node(\n                  \"MacroAccess\",\n                  58758,\n                  58783,\n                  29,\n                  1763,\n                  {\n                    macroName: \"let\",\n                    macroData: {\n                      declarable: __node(\n                        \"MacroAccess\",\n                        58761,\n                        58775,\n                        28,\n                        1763,\n                        __node(\n                          \"MacroAccess\",\n                          58761,\n                          58775,\n                          22,\n                          1763,\n                          {\n                            isMutable: \"mutable\",\n                            ident: __wrap(fall, 341)\n                          },\n                          \"statement\",\n                          false\n                        ),\n                        \"statement\",\n                        false\n                      ),\n                      value: __node(\"Const\", 58777, 58783, false)\n                    }\n                  },\n                  \"statement\",\n                  false\n                ),\n                __node(\n                  \"MacroAccess\",\n                  58798,\n                  58858,\n                  19,\n                  1764,\n                  {\n                    macroName: \"if\",\n                    macroData: {\n                      test: __wrap(test, 341),\n                      body: __node(\n                        \"Block\",\n                        58807,\n                        58858,\n                        [\n                          __node(\n                            \"Assign\",\n                            58823,\n                            58836,\n                            __wrap(fall, 341),\n                            \"=\",\n                            __node(\"Const\", 58831, 58836, true)\n                          ),\n                          __wrap(body, 341)\n                        ],\n                        null\n                      ),\n                      elseIfs: []\n                    }\n                  },\n                  \"statement\",\n                  false\n                ),\n                __node(\n                  \"MacroAccess\",\n                  58873,\n                  59000,\n                  19,\n                  1767,\n                  {\n                    macroName: \"if\",\n                    macroData: {\n                      test: __node(\n                        \"MacroAccess\",\n                        58875,\n                        58902,\n                        2,\n                        1767,\n                        {\n                          left: __wrap(fall, 341),\n                          inverted: false,\n                          op: \"or\",\n                          right: __wrap(this.test(current), 341)\n                        },\n                        \"statement\",\n                        false\n                      ),\n                      body: __wrap(this.whenTrue(current), 341),\n                      elseIfs: [],\n                      elseBody: __wrap(this.whenFalse(current), 341)\n                    }\n                  },\n                  \"statement\",\n                  false\n                )\n              ],\n              null\n            ))\n            : __node(\n              \"Block\",\n              59032,\n              59099,\n              [\n                __node(\n                  \"MacroAccess\",\n                  59046,\n                  59076,\n                  19,\n                  1773,\n                  {\n                    macroName: \"if\",\n                    macroData: {\n                      test: __wrap(test, 341),\n                      body: __wrap(body, 341),\n                      elseIfs: []\n                    }\n                  },\n                  \"statement\",\n                  false\n                ),\n                __wrap(current, 341)\n              ],\n              null\n            );\n        }\n      } else if (this.isIdent(body) && this.name(body) === \"fallthrough\") {\n        if (this.isIf(current)) {\n          result = __node(\n            \"MacroAccess\",\n            59212,\n            59328,\n            19,\n            1778,\n            {\n              macroName: \"if\",\n              macroData: {\n                test: __node(\n                  \"MacroAccess\",\n                  59215,\n                  59242,\n                  2,\n                  1778,\n                  {\n                    left: __wrap(test, 341),\n                    inverted: false,\n                    op: \"or\",\n                    right: __wrap(this.test(current), 341)\n                  },\n                  \"statement\",\n                  false\n                ),\n                body: __wrap(this.whenTrue(current), 341),\n                elseIfs: [],\n                elseBody: __wrap(this.whenFalse(current), 341)\n              }\n            },\n            \"statement\",\n            false\n          );\n        } else {\n          result = __node(\n            \"Block\",\n            59366,\n            59404,\n            [\n              __wrap(test, 341),\n              __wrap(current, 341)\n            ],\n            null\n          );\n        }\n      }\n      current = result || __node(\n        \"MacroAccess\",\n        59437,\n        59496,\n        19,\n        1787,\n        {\n          macroName: \"if\",\n          macroData: {\n            test: __wrap(case_.test, 341),\n            body: __wrap(body, 341),\n            elseIfs: [],\n            elseBody: __wrap(current, 341)\n          }\n        },\n        \"statement\",\n        false\n      );\n    }\n    return current;\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"cases","asType":{"type":"many","multiplier":"*","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"case"},{"type":"ident","name":"test","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"body","asType":{"type":"many","multiplier":"?","inner":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}}]}}},{"type":"ident","name":"defaultCase","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"default"},{"type":"this","asType":{"type":"many","multiplier":"?","inner":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}}]}}}],"names":["switch"],"id":111},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, body, call, func, macroName, params;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    params = _p2.params;\n    call = _p2.call;\n    body = _p2.body;\n    if (!this.isCall(call)) {\n      throw Error(\"async call expression must be a call\");\n    }\n    params = params ? [params.head].concat(params.tail) : [];\n    func = this.func(params, body, true, true);\n    return this.call(this.callFunc(call), this.callArgs(call).concat([func]), this.callIsNew(call), this.callIsApply(call));\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"params","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"ident","name":"head","asType":{"type":"ident","name":"Parameter"}},{"type":"ident","name":"tail","asType":{"type":"many","multiplier":"*","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Parameter"}}]}}}]}}},{"type":"const","value":"<-"},{"type":"ident","name":"call","asType":{"type":"ident","name":"Expression"}},{"type":"ident","name":"body","asType":{"type":"ident","name":"DedentedBody"}}],"names":["async"],"id":114},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, body, call, callback, error, func, macroName, params;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    callback = _p2.callback;\n    params = _p2.params;\n    call = _p2.call;\n    body = _p2.body;\n    if (!this.isCall(call)) {\n      throw Error(\"async! call expression must be a call\");\n    }\n    error = this.tmp(\"e\", false);\n    params = [this.param(error)].concat(params);\n    func = this.func(\n      params,\n      __node(\n        \"Block\",\n        61189,\n        61255,\n        [\n          __node(\n            \"MacroAccess\",\n            61197,\n            61241,\n            19,\n            1851,\n            {\n              macroName: \"if\",\n              macroData: {\n                test: __node(\n                  \"MacroAccess\",\n                  61199,\n                  61207,\n                  21,\n                  1851,\n                  {\n                    op: \"?\",\n                    node: __wrap(error, 360)\n                  },\n                  \"statement\",\n                  false\n                ),\n                body: __node(\n                  \"MacroAccess\",\n                  61218,\n                  61241,\n                  30,\n                  1852,\n                  {\n                    macroName: \"return\",\n                    macroData: {\n                      node: __node(\n                        \"Call\",\n                        61224,\n                        61241,\n                        __wrap(callback, 360),\n                        [__wrap(error, 360)],\n                        false,\n                        false\n                      )\n                    }\n                  },\n                  \"statement\",\n                  false\n                ),\n                elseIfs: []\n              }\n            },\n            \"statement\",\n            false\n          ),\n          __wrap(body, 360)\n        ],\n        null\n      ),\n      true,\n      true\n    );\n    return this.call(this.callFunc(call), this.callArgs(call).concat([func]), this.callIsNew(call), this.callIsApply(call));\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"callback","asType":{"type":"ident","name":"Expression"}},{"type":"ident","name":"params","asType":{"type":"many","multiplier":"*","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Parameter"}}]}}},{"type":"const","value":"<-"},{"type":"ident","name":"call","asType":{"type":"ident","name":"Expression"}},{"type":"ident","name":"body","asType":{"type":"ident","name":"DedentedBody"}}],"names":["async!"],"id":115},{"code":"return (function () {\n  \"use strict\";\n  var __isArray, __num, __slice, __toArray, __typeof;\n  __isArray = typeof Array.isArray === \"function\" ? Array.isArray\n    : (function () {\n      var _toString;\n      _toString = Object.prototype.toString;\n      return function (x) {\n        return _toString.call(x) === \"[object Array]\";\n      };\n    }());\n  __num = function (num) {\n    if (typeof num !== \"number\") {\n      throw TypeError(\"Expected a number, got \" + __typeof(num));\n    } else {\n      return num;\n    }\n  };\n  __slice = Array.prototype.slice;\n  __toArray = function (x) {\n    if (x == null) {\n      throw TypeError(\"Expected an object, got \" + __typeof(x));\n    } else if (__isArray(x)) {\n      return x;\n    } else if (typeof x === \"string\") {\n      return x.split(\"\");\n    } else {\n      return __slice.call(x);\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var _arr, _i, _len, _p2, ident, identName, key, macroName, name, obj, path, requires, value;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    name = _p2.name;\n    if (this.isConst(name) && typeof this.value(name) !== \"string\") {\n      throw Error(\"Expected a constant string, got \" + typeof this.value(name));\n    }\n    if (this.isConst(name)) {\n      identName = this.value(name);\n      if (identName.indexOf(\"/\") !== -1) {\n        identName = identName.substring(__num(identName.lastIndexOf(\"/\")) + 1);\n      }\n      ident = this.ident(identName);\n      return __node(\n        \"MacroAccess\",\n        61891,\n        61918,\n        29,\n        1878,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              61895,\n              61902,\n              28,\n              1878,\n              __node(\n                \"MacroAccess\",\n                61895,\n                61902,\n                22,\n                1878,\n                { ident: __wrap(ident, 364) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\n              \"Call\",\n              61904,\n              61918,\n              __node(\"Ident\", 61904, 61912, \"require\"),\n              [__wrap(name, 364)],\n              false,\n              false\n            )\n          }\n        },\n        \"statement\",\n        false\n      );\n    } else if (this.isIdent(name)) {\n      path = this.name(name);\n      return __node(\n        \"MacroAccess\",\n        61983,\n        62009,\n        29,\n        1881,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              61987,\n              61993,\n              28,\n              1881,\n              __node(\n                \"MacroAccess\",\n                61987,\n                61993,\n                22,\n                1881,\n                { ident: __wrap(name, 364) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\n              \"Call\",\n              61995,\n              62009,\n              __node(\"Ident\", 61995, 62003, \"require\"),\n              [__wrap(path, 364)],\n              false,\n              false\n            )\n          }\n        },\n        \"statement\",\n        false\n      );\n    } else if (this.isObject(name)) {\n      requires = [];\n      for (_arr = __toArray(this.pairs(name)), _i = 0, _len = _arr.length; _i < _len; ++_i) {\n        obj = _arr[_i];\n        key = obj.key;\n        value = obj.value;\n        if (!this.isConst(key)) {\n          throw Error(\"If providing an object to require!, all keys must be constant strings\");\n        }\n        identName = this.value(key);\n        if (identName.indexOf(\"/\") !== -1) {\n          identName = identName.substring(__num(identName.lastIndexOf(\"/\")) + 1);\n        }\n        ident = this.ident(identName);\n        if (this.isConst(value)) {\n          requires.push(__node(\n            \"MacroAccess\",\n            62504,\n            62532,\n            29,\n            1893,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  62508,\n                  62515,\n                  28,\n                  1893,\n                  __node(\n                    \"MacroAccess\",\n                    62508,\n                    62515,\n                    22,\n                    1893,\n                    { ident: __wrap(ident, 364) },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\n                  \"Call\",\n                  62517,\n                  62532,\n                  __node(\"Ident\", 62517, 62525, \"require\"),\n                  [__wrap(value, 364)],\n                  false,\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          ));\n        } else if (this.isIdent(value)) {\n          path = this.name(value);\n          requires.push(__node(\n            \"MacroAccess\",\n            62625,\n            62652,\n            29,\n            1896,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  62629,\n                  62636,\n                  28,\n                  1896,\n                  __node(\n                    \"MacroAccess\",\n                    62629,\n                    62636,\n                    22,\n                    1896,\n                    { ident: __wrap(ident, 364) },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\n                  \"Call\",\n                  62638,\n                  62652,\n                  __node(\"Ident\", 62638, 62646, \"require\"),\n                  [__wrap(path, 364)],\n                  false,\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          ));\n        } else {\n          throw Error(\"If providing an object to require!, all values must be constant strings or idents\");\n        }\n      }\n      return this.block(requires);\n    } else {\n      throw Error(\"Expected either a constant string or ident or object\");\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"name","asType":{"type":"ident","name":"Expression"}}],"names":["require!"],"id":116},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, _ref, body, done, err, first, init, macroName, next, rest, result, results, step, test, value;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    results = _p2.results;\n    next = _p2.next;\n    init = _p2.init;\n    test = _p2.test;\n    step = _p2.step;\n    body = _p2.body;\n    rest = _p2.rest;\n    err = (_ref = typeof results !== \"undefined\" && results !== null ? results : {}).err;\n    result = _ref.result;\n    if (err == null) {\n      err = this.tmp(\"err\", true);\n    }\n    if (typeof init === \"undefined\" || init === null) {\n      init = this.noop();\n    }\n    if (typeof test === \"undefined\" || test === null) {\n      test = __node(\"Const\", 67558, 67563, true);\n    }\n    if (typeof step === \"undefined\" || step === null) {\n      step = this.noop(step);\n    }\n    done = this.tmp(\"done\", true, \"function\");\n    if (!result) {\n      if (!step) {\n        return __node(\n          \"Block\",\n          67679,\n          67914,\n          [\n            __wrap(init, 403),\n            __node(\n              \"MacroAccess\",\n              67705,\n              67851,\n              17,\n              2093,\n              {\n                macroName: \"let\",\n                macroData: {\n                  ident: __wrap(next, 403),\n                  func: __node(\n                    \"Function\",\n                    67714,\n                    67851,\n                    [\n                      __node(\n                        \"Param\",\n                        67715,\n                        67719,\n                        __wrap(err, 405),\n                        void 0,\n                        false,\n                        false,\n                        void 0\n                      )\n                    ],\n                    __node(\n                      \"Block\",\n                      67722,\n                      67851,\n                      [\n                        __node(\n                          \"MacroAccess\",\n                          67734,\n                          67775,\n                          19,\n                          2094,\n                          {\n                            macroName: \"if\",\n                            macroData: {\n                              test: __node(\n                                \"MacroAccess\",\n                                67736,\n                                67742,\n                                21,\n                                2094,\n                                {\n                                  op: \"?\",\n                                  node: __wrap(err, 405)\n                                },\n                                \"statement\",\n                                false\n                              ),\n                              body: __node(\n                                \"MacroAccess\",\n                                67757,\n                                67775,\n                                30,\n                                2095,\n                                {\n                                  macroName: \"return\",\n                                  macroData: {\n                                    node: __node(\n                                      \"Call\",\n                                      67763,\n                                      67775,\n                                      __wrap(done, 405),\n                                      [__wrap(err, 405)],\n                                      false,\n                                      false\n                                    )\n                                  }\n                                },\n                                \"statement\",\n                                false\n                              ),\n                              elseIfs: []\n                            }\n                          },\n                          \"statement\",\n                          false\n                        ),\n                        __node(\n                          \"MacroAccess\",\n                          67788,\n                          67833,\n                          19,\n                          2096,\n                          {\n                            macroName: \"unless\",\n                            macroData: {\n                              test: __wrap(test, 405),\n                              body: __node(\n                                \"MacroAccess\",\n                                67815,\n                                67833,\n                                30,\n                                2097,\n                                {\n                                  macroName: \"return\",\n                                  macroData: {\n                                    node: __node(\n                                      \"Call\",\n                                      67821,\n                                      67833,\n                                      __wrap(done, 405),\n                                      [__node(\"Const\", 67828, 67832, null)],\n                                      false,\n                                      false\n                                    )\n                                  }\n                                },\n                                \"statement\",\n                                false\n                              ),\n                              elseIfs: []\n                            }\n                          },\n                          \"statement\",\n                          false\n                        ),\n                        __wrap(body, 405)\n                      ],\n                      null\n                    ),\n                    true,\n                    true,\n                    void 0,\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            ),\n            __node(\n              \"MacroAccess\",\n              67862,\n              67896,\n              17,\n              2099,\n              {\n                macroName: \"let\",\n                macroData: {\n                  ident: __wrap(done, 403),\n                  func: __node(\n                    \"Function\",\n                    67871,\n                    67896,\n                    [\n                      __node(\n                        \"Param\",\n                        67872,\n                        67876,\n                        __wrap(err, 406),\n                        void 0,\n                        false,\n                        false,\n                        void 0\n                      )\n                    ],\n                    __wrap(rest, 406),\n                    true,\n                    true,\n                    void 0,\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            ),\n            __node(\n              \"Call\",\n              67907,\n              67914,\n              __wrap(next, 403),\n              [],\n              false,\n              false\n            )\n          ],\n          null\n        );\n      } else {\n        first = this.tmp(\"first\", true, \"boolean\");\n        return __node(\n          \"Block\",\n          67986,\n          68338,\n          [\n            __wrap(init, 403),\n            __node(\n              \"MacroAccess\",\n              68012,\n              68029,\n              29,\n              2106,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    68015,\n                    68022,\n                    28,\n                    2106,\n                    __node(\n                      \"MacroAccess\",\n                      68015,\n                      68022,\n                      22,\n                      2106,\n                      { ident: __wrap(first, 403) },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __node(\"Const\", 68024, 68029, true)\n                }\n              },\n              \"statement\",\n              false\n            ),\n            __node(\n              \"MacroAccess\",\n              68040,\n              68275,\n              17,\n              2107,\n              {\n                macroName: \"let\",\n                macroData: {\n                  ident: __wrap(next, 403),\n                  func: __node(\n                    \"Function\",\n                    68049,\n                    68275,\n                    [\n                      __node(\n                        \"Param\",\n                        68050,\n                        68054,\n                        __wrap(err, 409),\n                        void 0,\n                        false,\n                        false,\n                        void 0\n                      )\n                    ],\n                    __node(\n                      \"Block\",\n                      68057,\n                      68275,\n                      [\n                        __node(\n                          \"MacroAccess\",\n                          68069,\n                          68110,\n                          19,\n                          2108,\n                          {\n                            macroName: \"if\",\n                            macroData: {\n                              test: __node(\n                                \"MacroAccess\",\n                                68071,\n                                68077,\n                                21,\n                                2108,\n                                {\n                                  op: \"?\",\n                                  node: __wrap(err, 409)\n                                },\n                                \"statement\",\n                                false\n                              ),\n                              body: __node(\n                                \"MacroAccess\",\n                                68092,\n                                68110,\n                                30,\n                                2109,\n                                {\n                                  macroName: \"return\",\n                                  macroData: {\n                                    node: __node(\n                                      \"Call\",\n                                      68098,\n                                      68110,\n                                      __wrap(done, 409),\n                                      [__wrap(err, 409)],\n                                      false,\n                                      false\n                                    )\n                                  }\n                                },\n                                \"statement\",\n                                false\n                              ),\n                              elseIfs: []\n                            }\n                          },\n                          \"statement\",\n                          false\n                        ),\n                        __node(\n                          \"MacroAccess\",\n                          68123,\n                          68199,\n                          19,\n                          2110,\n                          {\n                            macroName: \"if\",\n                            macroData: {\n                              test: __wrap(first, 409),\n                              body: __node(\n                                \"Assign\",\n                                68147,\n                                68162,\n                                __wrap(first, 409),\n                                \"=\",\n                                __node(\"Const\", 68156, 68162, false)\n                              ),\n                              elseIfs: [],\n                              elseBody: __wrap(step, 409)\n                            }\n                          },\n                          \"statement\",\n                          false\n                        ),\n                        __node(\n                          \"MacroAccess\",\n                          68212,\n                          68257,\n                          19,\n                          2114,\n                          {\n                            macroName: \"unless\",\n                            macroData: {\n                              test: __wrap(test, 409),\n                              body: __node(\n                                \"MacroAccess\",\n                                68239,\n                                68257,\n                                30,\n                                2115,\n                                {\n                                  macroName: \"return\",\n                                  macroData: {\n                                    node: __node(\n                                      \"Call\",\n                                      68245,\n                                      68257,\n                                      __wrap(done, 409),\n                                      [__node(\"Const\", 68252, 68256, null)],\n                                      false,\n                                      false\n                                    )\n                                  }\n                                },\n                                \"statement\",\n                                false\n                              ),\n                              elseIfs: []\n                            }\n                          },\n                          \"statement\",\n                          false\n                        ),\n                        __wrap(body, 409)\n                      ],\n                      null\n                    ),\n                    true,\n                    true,\n                    void 0,\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            ),\n            __node(\n              \"MacroAccess\",\n              68286,\n              68320,\n              17,\n              2117,\n              {\n                macroName: \"let\",\n                macroData: {\n                  ident: __wrap(done, 403),\n                  func: __node(\n                    \"Function\",\n                    68295,\n                    68320,\n                    [\n                      __node(\n                        \"Param\",\n                        68296,\n                        68300,\n                        __wrap(err, 410),\n                        void 0,\n                        false,\n                        false,\n                        void 0\n                      )\n                    ],\n                    __wrap(rest, 410),\n                    true,\n                    true,\n                    void 0,\n                    false\n                  )\n                }\n              },\n              \"statement\",\n              false\n            ),\n            __node(\n              \"Call\",\n              68331,\n              68338,\n              __wrap(next, 403),\n              [],\n              false,\n              false\n            )\n          ],\n          null\n        );\n      }\n    } else {\n      first = this.tmp(\"first\", true, \"boolean\");\n      value = this.tmp(\"value\", true);\n      return __node(\n        \"Block\",\n        68440,\n        68925,\n        [\n          __wrap(init, 403),\n          __node(\n            \"MacroAccess\",\n            68462,\n            68479,\n            29,\n            2125,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  68465,\n                  68472,\n                  28,\n                  2125,\n                  __node(\n                    \"MacroAccess\",\n                    68465,\n                    68472,\n                    22,\n                    2125,\n                    { ident: __wrap(first, 403) },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\"Const\", 68474, 68479, true)\n              }\n            },\n            \"statement\",\n            false\n          ),\n          __node(\n            \"MacroAccess\",\n            68488,\n            68859,\n            29,\n            2126,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  68491,\n                  68497,\n                  28,\n                  2126,\n                  __node(\n                    \"MacroAccess\",\n                    68491,\n                    68497,\n                    22,\n                    2126,\n                    { ident: __wrap(next, 403) },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\n                  \"MacroAccess\",\n                  68499,\n                  68859,\n                  0,\n                  2126,\n                  {\n                    macroName: \"do\",\n                    macroData: {\n                      body: __node(\n                        \"Block\",\n                        68503,\n                        68859,\n                        [\n                          __node(\n                            \"MacroAccess\",\n                            68513,\n                            68529,\n                            29,\n                            2127,\n                            {\n                              macroName: \"let\",\n                              macroData: {\n                                declarable: __node(\n                                  \"MacroAccess\",\n                                  68516,\n                                  68524,\n                                  28,\n                                  2127,\n                                  __node(\n                                    \"MacroAccess\",\n                                    68516,\n                                    68524,\n                                    22,\n                                    2127,\n                                    { ident: __wrap(result, 403) },\n                                    \"statement\",\n                                    false\n                                  ),\n                                  \"statement\",\n                                  false\n                                ),\n                                value: __node(\"Array\", 68526, 68529, [])\n                              }\n                            },\n                            \"statement\",\n                            false\n                          ),\n                          __node(\n                            \"Function\",\n                            68541,\n                            68859,\n                            [\n                              __node(\n                                \"Param\",\n                                68542,\n                                68546,\n                                __wrap(err, 416),\n                                void 0,\n                                false,\n                                false,\n                                void 0\n                              ),\n                              __node(\n                                \"Param\",\n                                68547,\n                                68554,\n                                __wrap(value, 416),\n                                void 0,\n                                false,\n                                false,\n                                void 0\n                              )\n                            ],\n                            __node(\n                              \"Block\",\n                              68557,\n                              68859,\n                              [\n                                __node(\n                                  \"MacroAccess\",\n                                  68569,\n                                  68610,\n                                  19,\n                                  2129,\n                                  {\n                                    macroName: \"if\",\n                                    macroData: {\n                                      test: __node(\n                                        \"MacroAccess\",\n                                        68571,\n                                        68577,\n                                        21,\n                                        2129,\n                                        {\n                                          op: \"?\",\n                                          node: __wrap(err, 416)\n                                        },\n                                        \"statement\",\n                                        false\n                                      ),\n                                      body: __node(\n                                        \"MacroAccess\",\n                                        68592,\n                                        68610,\n                                        30,\n                                        2130,\n                                        {\n                                          macroName: \"return\",\n                                          macroData: {\n                                            node: __node(\n                                              \"Call\",\n                                              68598,\n                                              68610,\n                                              __wrap(done, 416),\n                                              [__wrap(err, 416)],\n                                              false,\n                                              false\n                                            )\n                                          }\n                                        },\n                                        \"statement\",\n                                        false\n                                      ),\n                                      elseIfs: []\n                                    }\n                                  },\n                                  \"statement\",\n                                  false\n                                ),\n                                __node(\n                                  \"MacroAccess\",\n                                  68623,\n                                  68774,\n                                  19,\n                                  2131,\n                                  {\n                                    macroName: \"if\",\n                                    macroData: {\n                                      test: __wrap(first, 416),\n                                      body: __node(\n                                        \"Assign\",\n                                        68647,\n                                        68662,\n                                        __wrap(first, 416),\n                                        \"=\",\n                                        __node(\"Const\", 68656, 68662, false)\n                                      ),\n                                      elseIfs: [],\n                                      elseBody: __node(\n                                        \"Block\",\n                                        68680,\n                                        68774,\n                                        [\n                                          __wrap(step, 416),\n                                          __node(\n                                            \"MacroAccess\",\n                                            68714,\n                                            68774,\n                                            19,\n                                            2135,\n                                            {\n                                              macroName: \"if\",\n                                              macroData: {\n                                                test: __node(\n                                                  \"MacroAccess\",\n                                                  68716,\n                                                  68738,\n                                                  10,\n                                                  2135,\n                                                  {\n                                                    left: __node(\n                                                      \"Access\",\n                                                      68716,\n                                                      68733,\n                                                      __node(\"Args\", 68716, 68726),\n                                                      __node(\"Const\", 68727, 68733, \"length\")\n                                                    ),\n                                                    inverted: false,\n                                                    op: \"~>\",\n                                                    right: __node(\"Const\", 68737, 68738, 1)\n                                                  },\n                                                  \"statement\",\n                                                  false\n                                                ),\n                                                body: __node(\n                                                  \"Call\",\n                                                  68755,\n                                                  68774,\n                                                  __node(\n                                                    \"Access\",\n                                                    68755,\n                                                    68774,\n                                                    __wrap(result, 416),\n                                                    __node(\"Const\", 68763, 68767, \"push\")\n                                                  ),\n                                                  [__wrap(value, 416)],\n                                                  false,\n                                                  false\n                                                ),\n                                                elseIfs: []\n                                              }\n                                            },\n                                            \"statement\",\n                                            false\n                                          )\n                                        ],\n                                        null\n                                      )\n                                    }\n                                  },\n                                  \"statement\",\n                                  false\n                                ),\n                                __node(\n                                  \"MacroAccess\",\n                                  68787,\n                                  68841,\n                                  19,\n                                  2137,\n                                  {\n                                    macroName: \"unless\",\n                                    macroData: {\n                                      test: __wrap(test, 416),\n                                      body: __node(\n                                        \"MacroAccess\",\n                                        68814,\n                                        68841,\n                                        30,\n                                        2138,\n                                        {\n                                          macroName: \"return\",\n                                          macroData: {\n                                            node: __node(\n                                              \"Call\",\n                                              68820,\n                                              68841,\n                                              __wrap(done, 416),\n                                              [\n                                                __node(\"Const\", 68827, 68831, null),\n                                                __wrap(result, 416)\n                                              ],\n                                              false,\n                                              false\n                                            )\n                                          }\n                                        },\n                                        \"statement\",\n                                        false\n                                      ),\n                                      elseIfs: []\n                                    }\n                                  },\n                                  \"statement\",\n                                  false\n                                ),\n                                __wrap(body, 416)\n                              ],\n                              null\n                            ),\n                            true,\n                            true,\n                            void 0,\n                            false\n                          )\n                        ],\n                        null\n                      )\n                    }\n                  },\n                  \"expression\",\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          ),\n          __node(\n            \"MacroAccess\",\n            68868,\n            68909,\n            17,\n            2140,\n            {\n              macroName: \"let\",\n              macroData: {\n                ident: __wrap(done, 403),\n                func: __node(\n                  \"Function\",\n                  68877,\n                  68909,\n                  [\n                    __node(\n                      \"Param\",\n                      68878,\n                      68882,\n                      __wrap(err, 417),\n                      void 0,\n                      false,\n                      false,\n                      void 0\n                    ),\n                    __node(\n                      \"Param\",\n                      68883,\n                      68891,\n                      __wrap(result, 417),\n                      void 0,\n                      false,\n                      false,\n                      void 0\n                    )\n                  ],\n                  __wrap(rest, 417),\n                  true,\n                  true,\n                  void 0,\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          ),\n          __node(\n            \"Call\",\n            68918,\n            68925,\n            __wrap(next, 403),\n            [],\n            false,\n            false\n          )\n        ],\n        null\n      );\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"results","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"ident","name":"err","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"result","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}},{"type":"const","value":"<-"}]}}},{"type":"ident","name":"next","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":","},{"type":"ident","name":"init","asType":{"type":"choice","choices":[{"type":"ident","name":"Statement"},{"type":"const","value":""}]}},{"type":"const","value":";"},{"type":"ident","name":"test","asType":{"type":"choice","choices":[{"type":"ident","name":"Logic"},{"type":"const","value":""}]}},{"type":"const","value":";"},{"type":"ident","name":"step","asType":{"type":"choice","choices":[{"type":"ident","name":"Statement"},{"type":"const","value":""}]}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"rest","asType":{"type":"ident","name":"DedentedBody"}}],"names":["asyncfor"],"id":117},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, _ref, array, body, end, err, inclusive, index, init, length, lengthCalc, macroName, next, parallelism, rest, result, results, start, step, value;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    parallelism = _p2.parallelism;\n    results = _p2.results;\n    next = _p2.next;\n    value = _p2.value;\n    index = _p2.index;\n    array = _p2.array;\n    body = _p2.body;\n    rest = _p2.rest;\n    err = (_ref = typeof results !== \"undefined\" && results !== null ? results : {}).err;\n    result = _ref.result;\n    if (err == null) {\n      err = this.tmp(\"err\", true);\n    }\n    init = [];\n    value = this.macroExpand1(value);\n    length = null;\n    if (index) {\n      length = index.length;\n      index = index.value;\n    }\n    if (typeof parallelism === \"undefined\" || parallelism === null) {\n      parallelism = __node(\"Const\", 69521, 69522, 1);\n    }\n    if (typeof index === \"undefined\" || index === null) {\n      index = this.tmp(\"i\", true, \"number\");\n    }\n    if (this.isCall(array) && this.isIdent(this.callFunc(array)) && this.name(this.callFunc(array)) === \"__range\" && !this.callIsApply(array)) {\n      if (this.isArray(value) || this.isObject(value)) {\n        throw Error(\"Cannot assign a number to a complex declarable\");\n      }\n      value = value.ident;\n      start = (_ref = this.callArgs(array))[0];\n      end = _ref[1];\n      step = _ref[2];\n      inclusive = _ref[3];\n      if (this.isConst(start)) {\n        if (typeof this.value(start) !== \"number\") {\n          throw Error(\"Cannot start with a non-number: #(@value start)\");\n        }\n      } else {\n        start = __node(\n          \"MacroAccess\",\n          70074,\n          70082,\n          47,\n          2168,\n          {\n            op: \"+\",\n            node: __wrap(start, 418)\n          },\n          \"expression\",\n          false\n        );\n      }\n      if (this.isConst(end)) {\n        if (typeof this.value(end) !== \"number\") {\n          throw Error(\"Cannot end with a non-number: #(@value start)\");\n        }\n      } else if (this.isComplex(end)) {\n        end = this.cache(\n          __node(\n            \"MacroAccess\",\n            70277,\n            70283,\n            47,\n            2174,\n            {\n              op: \"+\",\n              node: __wrap(end, 418)\n            },\n            \"expression\",\n            false\n          ),\n          init,\n          \"end\",\n          false\n        );\n      } else {\n        init.push(__node(\n          \"MacroAccess\",\n          70337,\n          70343,\n          47,\n          2176,\n          {\n            op: \"+\",\n            node: __wrap(end, 418)\n          },\n          \"expression\",\n          false\n        ));\n      }\n      if (this.isConst(step)) {\n        if (typeof this.value(step) !== \"number\") {\n          throw Error(\"Cannot step with a non-number: #(@value step)\");\n        }\n      } else if (this.isComplex(step)) {\n        step = this.cache(\n          __node(\n            \"MacroAccess\",\n            70542,\n            70549,\n            47,\n            2182,\n            {\n              op: \"+\",\n              node: __wrap(step, 418)\n            },\n            \"expression\",\n            false\n          ),\n          init,\n          \"step\",\n          false\n        );\n      } else {\n        init.push(__node(\n          \"MacroAccess\",\n          70604,\n          70611,\n          47,\n          2184,\n          {\n            op: \"+\",\n            node: __wrap(step, 418)\n          },\n          \"expression\",\n          false\n        ));\n      }\n      body = __node(\n        \"Block\",\n        70637,\n        70697,\n        [\n          __node(\n            \"MacroAccess\",\n            70645,\n            70683,\n            29,\n            2187,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  70648,\n                  70655,\n                  28,\n                  2187,\n                  __node(\n                    \"MacroAccess\",\n                    70648,\n                    70655,\n                    22,\n                    2187,\n                    { ident: __wrap(value, 418) },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\n                  \"MacroAccess\",\n                  70657,\n                  70683,\n                  38,\n                  2187,\n                  {\n                    left: __node(\n                      \"MacroAccess\",\n                      70657,\n                      70673,\n                      34,\n                      2187,\n                      {\n                        left: __wrap(index, 418),\n                        inverted: false,\n                        op: \"~*\",\n                        right: __wrap(step, 418)\n                      },\n                      \"expression\",\n                      false\n                    ),\n                    inverted: false,\n                    op: \"~+\",\n                    right: __wrap(start, 418)\n                  },\n                  \"expression\",\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          ),\n          __wrap(body, 418)\n        ],\n        null\n      );\n      lengthCalc = __node(\n        \"MacroAccess\",\n        70727,\n        70829,\n        19,\n        2190,\n        {\n          macroName: \"if\",\n          macroData: {\n            test: __wrap(inclusive, 418),\n            body: __node(\n              \"MacroAccess\",\n              70750,\n              70784,\n              34,\n              2191,\n              {\n                left: __node(\n                  \"MacroAccess\",\n                  70751,\n                  70774,\n                  38,\n                  2191,\n                  {\n                    left: __node(\n                      \"MacroAccess\",\n                      70751,\n                      70774,\n                      38,\n                      2191,\n                      {\n                        left: __wrap(end, 418),\n                        inverted: false,\n                        op: \"~-\",\n                        right: __wrap(start, 418)\n                      },\n                      \"expression\",\n                      false\n                    ),\n                    inverted: false,\n                    op: \"~+\",\n                    right: __wrap(step, 418)\n                  },\n                  \"expression\",\n                  false\n                ),\n                inverted: false,\n                op: \"~\\\\\",\n                right: __wrap(step, 418)\n              },\n              \"statement\",\n              false\n            ),\n            elseIfs: [],\n            elseBody: __node(\n              \"MacroAccess\",\n              70804,\n              70829,\n              34,\n              2193,\n              {\n                left: __node(\n                  \"MacroAccess\",\n                  70805,\n                  70819,\n                  38,\n                  2193,\n                  {\n                    left: __wrap(end, 418),\n                    inverted: false,\n                    op: \"~-\",\n                    right: __wrap(start, 418)\n                  },\n                  \"expression\",\n                  false\n                ),\n                inverted: false,\n                op: \"~\\\\\",\n                right: __wrap(step, 418)\n              },\n              \"statement\",\n              false\n            )\n          }\n        },\n        \"expression\",\n        false\n      );\n      if (!length) {\n        length = lengthCalc;\n      } else {\n        init.push(__node(\n          \"MacroAccess\",\n          70912,\n          70939,\n          29,\n          2197,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                70916,\n                70924,\n                28,\n                2197,\n                __node(\n                  \"MacroAccess\",\n                  70916,\n                  70924,\n                  22,\n                  2197,\n                  { ident: __wrap(length, 418) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __wrap(lengthCalc, 418)\n            }\n          },\n          \"statement\",\n          false\n        ));\n      }\n    } else {\n      array = this.cache(array, init, \"arr\", true);\n      body = __node(\n        \"Block\",\n        71014,\n        71063,\n        [\n          __node(\n            \"MacroAccess\",\n            71022,\n            71049,\n            29,\n            2202,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  71025,\n                  71032,\n                  28,\n                  2202,\n                  __node(\n                    \"MacroAccess\",\n                    71025,\n                    71032,\n                    22,\n                    2202,\n                    { ident: __wrap(value, 418) },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\n                  \"Access\",\n                  71034,\n                  71049,\n                  __wrap(array, 418),\n                  __wrap(index, 418)\n                )\n              }\n            },\n            \"statement\",\n            false\n          ),\n          __wrap(body, 418)\n        ],\n        null\n      );\n      if (!length) {\n        length = __node(\n          \"MacroAccess\",\n          71113,\n          71128,\n          47,\n          2206,\n          {\n            op: \"+\",\n            node: __node(\n              \"Access\",\n              71115,\n              71128,\n              __wrap(array, 418),\n              __node(\"Const\", 71122, 71128, \"length\")\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        init.push(__node(\n          \"MacroAccess\",\n          71161,\n          71190,\n          29,\n          2208,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                71165,\n                71173,\n                28,\n                2208,\n                __node(\n                  \"MacroAccess\",\n                  71165,\n                  71173,\n                  22,\n                  2208,\n                  { ident: __wrap(length, 418) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __node(\n                \"MacroAccess\",\n                71175,\n                71190,\n                47,\n                2208,\n                {\n                  op: \"+\",\n                  node: __node(\n                    \"Access\",\n                    71177,\n                    71190,\n                    __wrap(array, 418),\n                    __node(\"Const\", 71184, 71190, \"length\")\n                  )\n                },\n                \"expression\",\n                false\n              )\n            }\n          },\n          \"statement\",\n          false\n        ));\n      }\n    }\n    if (!result) {\n      return __node(\n        \"Block\",\n        71224,\n        71324,\n        [\n          __wrap(init, 418),\n          __node(\n            \"Call\",\n            71246,\n            71324,\n            __node(\"Ident\", 71246, 71253, \"__async\"),\n            [\n              __node(\n                \"MacroAccess\",\n                71254,\n                71267,\n                47,\n                2213,\n                {\n                  op: \"+\",\n                  node: __wrap(parallelism, 418)\n                },\n                \"expression\",\n                false\n              ),\n              __wrap(length, 418),\n              __node(\n                \"Function\",\n                71279,\n                71304,\n                [\n                  __node(\n                    \"Param\",\n                    71280,\n                    71286,\n                    __wrap(index, 425),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  ),\n                  __node(\n                    \"Param\",\n                    71287,\n                    71293,\n                    __wrap(next, 425),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  )\n                ],\n                __wrap(body, 425),\n                true,\n                true,\n                void 0,\n                false\n              ),\n              __node(\n                \"Function\",\n                71307,\n                71323,\n                [\n                  __node(\n                    \"Param\",\n                    71308,\n                    71312,\n                    __wrap(err, 426),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  )\n                ],\n                __wrap(rest, 426),\n                true,\n                true,\n                void 0,\n                false\n              )\n            ],\n            false,\n            false\n          )\n        ],\n        null\n      );\n    } else {\n      return __node(\n        \"Block\",\n        71344,\n        71460,\n        [\n          __wrap(init, 418),\n          __node(\n            \"Call\",\n            71366,\n            71460,\n            __node(\"Ident\", 71366, 71380, \"__asyncResult\"),\n            [\n              __node(\n                \"MacroAccess\",\n                71381,\n                71394,\n                47,\n                2217,\n                {\n                  op: \"+\",\n                  node: __wrap(parallelism, 418)\n                },\n                \"expression\",\n                false\n              ),\n              __wrap(length, 418),\n              __node(\n                \"Function\",\n                71406,\n                71431,\n                [\n                  __node(\n                    \"Param\",\n                    71407,\n                    71413,\n                    __wrap(index, 427),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  ),\n                  __node(\n                    \"Param\",\n                    71414,\n                    71420,\n                    __wrap(next, 427),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  )\n                ],\n                __wrap(body, 427),\n                true,\n                true,\n                void 0,\n                false\n              ),\n              __node(\n                \"Function\",\n                71434,\n                71459,\n                [\n                  __node(\n                    \"Param\",\n                    71435,\n                    71439,\n                    __wrap(err, 428),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  ),\n                  __node(\n                    \"Param\",\n                    71440,\n                    71448,\n                    __wrap(result, 428),\n                    void 0,\n                    false,\n                    false,\n                    void 0\n                  )\n                ],\n                __wrap(rest, 428),\n                true,\n                true,\n                void 0,\n                false\n              )\n            ],\n            false,\n            false\n          )\n        ],\n        null\n      );\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"parallelism","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"("},{"type":"this","asType":{"type":"ident","name":"Expression"}},{"type":"const","value":")"}]}}},{"type":"ident","name":"results","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"ident","name":"err","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"result","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}},{"type":"const","value":"<-"}]}}},{"type":"ident","name":"next","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":","},{"type":"ident","name":"value","asType":{"type":"ident","name":"Declarable"}},{"type":"ident","name":"index","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"ident","name":"value","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"length","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}}]}}},{"type":"const","value":"in"},{"type":"ident","name":"array"},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"rest","asType":{"type":"ident","name":"DedentedBody"}}],"names":["asyncfor"],"id":118},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, _ref, body, err, getKeys, index, init, key, keys, macroName, next, object, own, parallelism, rest, result, results, type, value;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    parallelism = _p2.parallelism;\n    results = _p2.results;\n    next = _p2.next;\n    key = _p2.key;\n    value = _p2.value;\n    type = _p2.type;\n    object = _p2.object;\n    body = _p2.body;\n    rest = _p2.rest;\n    err = (_ref = typeof results !== \"undefined\" && results !== null ? results : {}).err;\n    result = _ref.result;\n    own = type === \"of\";\n    init = [];\n    object = this.cache(object, init, \"obj\", true);\n    index = null;\n    if (value) {\n      index = value.index;\n      value = this.macroExpand1(value.value);\n    }\n    if (value) {\n      body = __node(\n        \"Block\",\n        72092,\n        72140,\n        [\n          __node(\n            \"MacroAccess\",\n            72100,\n            72126,\n            29,\n            2231,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  72103,\n                  72110,\n                  28,\n                  2231,\n                  __node(\n                    \"MacroAccess\",\n                    72103,\n                    72110,\n                    22,\n                    2231,\n                    { ident: __wrap(value, 429) },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\n                  \"Access\",\n                  72112,\n                  72126,\n                  __wrap(object, 429),\n                  __wrap(key, 429)\n                )\n              }\n            },\n            \"statement\",\n            false\n          ),\n          __wrap(body, 429)\n        ],\n        null\n      );\n    }\n    keys = this.tmp(\"keys\", true, \"stringArray\");\n    if (own) {\n      getKeys = __node(\n        \"MacroAccess\",\n        72228,\n        72272,\n        104,\n        2236,\n        {\n          macroName: \"for\",\n          macroData: {\n            key: __wrap(key, 429),\n            type: \"of\",\n            object: __wrap(object, 429),\n            body: __node(\n              \"Call\",\n              72257,\n              72272,\n              __node(\n                \"Access\",\n                72257,\n                72272,\n                __wrap(keys, 429),\n                __node(\"Const\", 72263, 72267, \"push\")\n              ),\n              [__wrap(key, 429)],\n              false,\n              false\n            )\n          }\n        },\n        \"statement\",\n        false\n      );\n    } else {\n      getKeys = __node(\n        \"MacroAccess\",\n        72291,\n        72338,\n        104,\n        2239,\n        {\n          macroName: \"for\",\n          macroData: {\n            key: __wrap(key, 429),\n            type: \"ofall\",\n            object: __wrap(object, 429),\n            body: __node(\n              \"Call\",\n              72323,\n              72338,\n              __node(\n                \"Access\",\n                72323,\n                72338,\n                __wrap(keys, 429),\n                __node(\"Const\", 72329, 72333, \"push\")\n              ),\n              [__wrap(key, 429)],\n              false,\n              false\n            )\n          }\n        },\n        \"statement\",\n        false\n      );\n    }\n    return __node(\n      \"Block\",\n      72347,\n      72496,\n      [\n        __wrap(init, 429),\n        __node(\n          \"MacroAccess\",\n          72365,\n          72379,\n          29,\n          2243,\n          {\n            macroName: \"let\",\n            macroData: {\n              declarable: __node(\n                \"MacroAccess\",\n                72368,\n                72374,\n                28,\n                2243,\n                __node(\n                  \"MacroAccess\",\n                  72368,\n                  72374,\n                  22,\n                  2243,\n                  { ident: __wrap(keys, 429) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              value: __node(\"Array\", 72376, 72379, [])\n            }\n          },\n          \"statement\",\n          false\n        ),\n        __wrap(getKeys, 429),\n        __node(\n          \"MacroAccess\",\n          72402,\n          72496,\n          118,\n          2245,\n          {\n            macroName: \"asyncfor\",\n            macroData: {\n              parallelism: __wrap(parallelism, 429),\n              results: {\n                err: __wrap(err, 429),\n                result: __wrap(result, 429)\n              },\n              next: __wrap(next, 429),\n              value: __node(\n                \"MacroAccess\",\n                72448,\n                72453,\n                28,\n                2245,\n                __node(\n                  \"MacroAccess\",\n                  72448,\n                  72453,\n                  22,\n                  2245,\n                  { ident: __wrap(key, 429) },\n                  \"statement\",\n                  false\n                ),\n                \"statement\",\n                false\n              ),\n              index: { value: __wrap(index, 429) },\n              array: __wrap(keys, 429),\n              body: __wrap(body, 429),\n              rest: __wrap(rest, 429)\n            }\n          },\n          \"statement\",\n          false\n        )\n      ],\n      null\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"parallelism","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"("},{"type":"this","asType":{"type":"ident","name":"Expression"}},{"type":"const","value":")"}]}}},{"type":"ident","name":"results","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"ident","name":"err","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"result","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}},{"type":"const","value":"<-"}]}}},{"type":"ident","name":"next","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":","},{"type":"ident","name":"key","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"value","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"ident","name":"value","asType":{"type":"ident","name":"Declarable"}},{"type":"ident","name":"index","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}}]}}},{"type":"ident","name":"type","asType":{"type":"choice","choices":[{"type":"const","value":"of"},{"type":"const","value":"ofall"}]}},{"type":"ident","name":"object"},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"rest","asType":{"type":"ident","name":"DedentedBody"}}],"names":["asyncfor"],"id":119},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, _ref, body, err, index, iterator, macroName, next, parallelism, rest, result, results, value;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    parallelism = _p2.parallelism;\n    results = _p2.results;\n    next = _p2.next;\n    value = _p2.value;\n    index = _p2.index;\n    iterator = _p2.iterator;\n    body = _p2.body;\n    rest = _p2.rest;\n    err = (_ref = typeof results !== \"undefined\" && results !== null ? results : {}).err;\n    result = _ref.result;\n    if (typeof index === \"undefined\" || index === null) {\n      index = this.tmp(\"i\", true);\n    }\n    if (err == null) {\n      err = this.tmp(\"err\", true);\n    }\n    if (typeof parallelism === \"undefined\" || parallelism === null) {\n      parallelism = __node(\"Const\", 72919, 72920, 1);\n    }\n    if (!result) {\n      return __node(\n        \"Call\",\n        72954,\n        73048,\n        __node(\"Ident\", 72954, 72967, \"__asyncIter\"),\n        [\n          __node(\n            \"MacroAccess\",\n            72968,\n            72981,\n            47,\n            2257,\n            {\n              op: \"+\",\n              node: __wrap(parallelism, 436)\n            },\n            \"expression\",\n            false\n          ),\n          __wrap(iterator, 436),\n          __node(\n            \"Function\",\n            72995,\n            73028,\n            [\n              __node(\n                \"Param\",\n                72996,\n                73002,\n                __wrap(value, 437),\n                void 0,\n                false,\n                false,\n                void 0\n              ),\n              __node(\n                \"Param\",\n                73003,\n                73010,\n                __wrap(index, 437),\n                void 0,\n                false,\n                false,\n                void 0\n              ),\n              __node(\n                \"Param\",\n                73011,\n                73017,\n                __wrap(next, 437),\n                void 0,\n                false,\n                false,\n                void 0\n              )\n            ],\n            __wrap(body, 437),\n            true,\n            true,\n            void 0,\n            false\n          ),\n          __node(\n            \"Function\",\n            73031,\n            73047,\n            [\n              __node(\n                \"Param\",\n                73032,\n                73036,\n                __wrap(err, 438),\n                void 0,\n                false,\n                false,\n                void 0\n              )\n            ],\n            __wrap(rest, 438),\n            true,\n            true,\n            void 0,\n            false\n          )\n        ],\n        false,\n        false\n      );\n    } else {\n      return __node(\n        \"Call\",\n        73068,\n        73178,\n        __node(\"Ident\", 73068, 73088, \"__asyncIterResult\"),\n        [\n          __node(\n            \"MacroAccess\",\n            73089,\n            73102,\n            47,\n            2259,\n            {\n              op: \"+\",\n              node: __wrap(parallelism, 436)\n            },\n            \"expression\",\n            false\n          ),\n          __wrap(iterator, 436),\n          __node(\n            \"Function\",\n            73116,\n            73149,\n            [\n              __node(\n                \"Param\",\n                73117,\n                73123,\n                __wrap(value, 439),\n                void 0,\n                false,\n                false,\n                void 0\n              ),\n              __node(\n                \"Param\",\n                73124,\n                73131,\n                __wrap(index, 439),\n                void 0,\n                false,\n                false,\n                void 0\n              ),\n              __node(\n                \"Param\",\n                73132,\n                73138,\n                __wrap(next, 439),\n                void 0,\n                false,\n                false,\n                void 0\n              )\n            ],\n            __wrap(body, 439),\n            true,\n            true,\n            void 0,\n            false\n          ),\n          __node(\n            \"Function\",\n            73152,\n            73177,\n            [\n              __node(\n                \"Param\",\n                73153,\n                73157,\n                __wrap(err, 440),\n                void 0,\n                false,\n                false,\n                void 0\n              ),\n              __node(\n                \"Param\",\n                73158,\n                73166,\n                __wrap(result, 440),\n                void 0,\n                false,\n                false,\n                void 0\n              )\n            ],\n            __wrap(rest, 440),\n            true,\n            true,\n            void 0,\n            false\n          )\n        ],\n        false,\n        false\n      );\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"parallelism","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"("},{"type":"this","asType":{"type":"ident","name":"Expression"}},{"type":"const","value":")"}]}}},{"type":"ident","name":"results","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"ident","name":"err","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"result","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}},{"type":"const","value":"<-"}]}}},{"type":"ident","name":"next","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":","},{"type":"ident","name":"value","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"index","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}},{"type":"const","value":"from"},{"type":"ident","name":"iterator"},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"rest","asType":{"type":"ident","name":"DedentedBody"}}],"names":["asyncfor"],"id":120},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, _ref, body, err, macroName, next, rest, result, results, step, test;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    results = _p2.results;\n    next = _p2.next;\n    test = _p2.test;\n    step = _p2.step;\n    body = _p2.body;\n    rest = _p2.rest;\n    if (macroName === \"asyncuntil\") {\n      test = __node(\n        \"MacroAccess\",\n        73485,\n        73495,\n        3,\n        2264,\n        {\n          op: \"not\",\n          node: __wrap(test, 441)\n        },\n        \"expression\",\n        false\n      );\n    }\n    err = (_ref = typeof results !== \"undefined\" && results !== null ? results : {}).err;\n    result = _ref.result;\n    return __node(\n      \"MacroAccess\",\n      73547,\n      73620,\n      117,\n      2267,\n      {\n        macroName: \"asyncfor\",\n        macroData: {\n          results: {\n            err: __wrap(err, 441),\n            result: __wrap(result, 441)\n          },\n          next: __wrap(next, 441),\n          test: __wrap(test, 441),\n          step: __wrap(step, 441),\n          body: __wrap(body, 441),\n          rest: __wrap(rest, 441)\n        }\n      },\n      \"statement\",\n      false\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"results","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"ident","name":"err","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"result","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}},{"type":"const","value":"<-"}]}}},{"type":"ident","name":"next","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":","},{"type":"ident","name":"test","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"step","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"rest","asType":{"type":"ident","name":"DedentedBody"}}],"names":["asyncwhile","asyncuntil"],"id":121},{"code":"return (function () {\n  \"use strict\";\n  var __num, __typeof;\n  __num = function (num) {\n    if (typeof num !== \"number\") {\n      throw TypeError(\"Expected a number, got \" + __typeof(num));\n    } else {\n      return num;\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var _p2, _ref, body, current, done, elseBody, elseIf, elseIfs, err, i, innerTest, macroName, rest, result, results, test;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    results = _p2.results;\n    done = _p2.done;\n    test = _p2.test;\n    body = _p2.body;\n    elseIfs = _p2.elseIfs;\n    elseBody = _p2.elseBody;\n    rest = _p2.rest;\n    if (macroName === \"asyncunless\") {\n      test = __node(\n        \"MacroAccess\",\n        74078,\n        74088,\n        3,\n        2274,\n        {\n          op: \"not\",\n          node: __wrap(test, 442)\n        },\n        \"expression\",\n        false\n      );\n    }\n    err = (_ref = typeof results !== \"undefined\" && results !== null ? results : {}).err;\n    result = _ref.result;\n    current = elseBody || __node(\n      \"Call\",\n      74174,\n      74182,\n      __wrap(done, 442),\n      [],\n      false,\n      false\n    );\n    i = __num(elseIfs.length) - 1;\n    for (; i >= 0; --i) {\n      elseIf = elseIfs[i];\n      innerTest = elseIf.test;\n      if (elseIf.type === \"unless\") {\n        innerTest = __node(\n          \"MacroAccess\",\n          74389,\n          74405,\n          3,\n          2284,\n          {\n            op: \"not\",\n            node: __wrap(innerTest, 442)\n          },\n          \"expression\",\n          false\n        );\n      }\n      current = this[\"if\"](innerTest, elseIf.body, current);\n    }\n    current = this[\"if\"](test, body, current);\n    if (!err && !result) {\n      return __node(\n        \"Block\",\n        74552,\n        74605,\n        [\n          __node(\n            \"MacroAccess\",\n            74560,\n            74588,\n            17,\n            2291,\n            {\n              macroName: \"let\",\n              macroData: {\n                ident: __wrap(done, 442),\n                func: __node(\n                  \"Function\",\n                  74569,\n                  74588,\n                  [],\n                  __wrap(rest, 444),\n                  true,\n                  true,\n                  void 0,\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          ),\n          __wrap(current, 442)\n        ],\n        null\n      );\n    } else if (!result) {\n      return __node(\n        \"Block\",\n        74639,\n        74696,\n        [\n          __node(\n            \"MacroAccess\",\n            74647,\n            74679,\n            17,\n            2296,\n            {\n              macroName: \"let\",\n              macroData: {\n                ident: __wrap(done, 442),\n                func: __node(\n                  \"Function\",\n                  74656,\n                  74679,\n                  [\n                    __node(\n                      \"Param\",\n                      74657,\n                      74661,\n                      __wrap(err, 445),\n                      void 0,\n                      false,\n                      false,\n                      void 0\n                    )\n                  ],\n                  __wrap(rest, 445),\n                  true,\n                  true,\n                  void 0,\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          ),\n          __wrap(current, 442)\n        ],\n        null\n      );\n    } else {\n      if (err == null) {\n        err = this.tmp(\"err\", true);\n      }\n      return __node(\n        \"Block\",\n        74745,\n        74811,\n        [\n          __node(\n            \"MacroAccess\",\n            74753,\n            74794,\n            17,\n            2302,\n            {\n              macroName: \"let\",\n              macroData: {\n                ident: __wrap(done, 442),\n                func: __node(\n                  \"Function\",\n                  74762,\n                  74794,\n                  [\n                    __node(\n                      \"Param\",\n                      74763,\n                      74767,\n                      __wrap(err, 446),\n                      void 0,\n                      false,\n                      false,\n                      void 0\n                    ),\n                    __node(\n                      \"Param\",\n                      74768,\n                      74776,\n                      __wrap(result, 446),\n                      void 0,\n                      false,\n                      false,\n                      void 0\n                    )\n                  ],\n                  __wrap(rest, 446),\n                  true,\n                  true,\n                  void 0,\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          ),\n          __wrap(current, 442)\n        ],\n        null\n      );\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"results","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"ident","name":"err","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"result","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"Identifier"}}]}}},{"type":"const","value":"<-"}]}}},{"type":"ident","name":"done","asType":{"type":"ident","name":"Identifier"}},{"type":"const","value":","},{"type":"ident","name":"test","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}},{"type":"ident","name":"elseIfs","asType":{"type":"many","multiplier":"*","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"else"},{"type":"ident","name":"type","asType":{"type":"choice","choices":[{"type":"const","value":"if"},{"type":"const","value":"unless"}]}},{"type":"ident","name":"test","asType":{"type":"ident","name":"Logic"}},{"type":"ident","name":"body","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}},{"type":"ident","name":"elseBody","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"\n"},{"type":"const","value":"else"},{"type":"this","asType":{"type":"choice","choices":[{"type":"ident","name":"Body"},{"type":"sequence","items":[{"type":"const","value":";"},{"type":"this","asType":{"type":"ident","name":"Statement"}}]}]}}]}}},{"type":"ident","name":"rest","asType":{"type":"ident","name":"DedentedBody"}}],"names":["asyncif","asyncunless"],"id":122},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, func, key, macroName;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    key = _p2.key;\n    func = _p2.func;\n    return this.def(key, func);\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"key","asType":{"type":"ident","name":"ObjectKey"}},{"type":"ident","name":"func","asType":{"type":"ident","name":"FunctionDeclaration"}}],"names":["def"],"id":123},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, key, macroName, value;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    key = _p2.key;\n    value = _p2.value;\n    return this.def(key, value);\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"key","asType":{"type":"ident","name":"ObjectKey"}},{"type":"const","value":"="},{"type":"ident","name":"value","asType":{"type":"ident","name":"ExpressionOrAssignment"}}],"names":["def"],"id":124},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, key, macroName;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    key = _p2.key;\n    return this.def(key, void 0);\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"key","asType":{"type":"ident","name":"ObjectKey"}}],"names":["def"],"id":125},{"code":"return (function () {\n  \"use strict\";\n  var __isArray, __slice, __strnum, __toArray, __typeof;\n  __isArray = typeof Array.isArray === \"function\" ? Array.isArray\n    : (function () {\n      var _toString;\n      _toString = Object.prototype.toString;\n      return function (x) {\n        return _toString.call(x) === \"[object Array]\";\n      };\n    }());\n  __slice = Array.prototype.slice;\n  __strnum = function (strnum) {\n    var type;\n    type = typeof strnum;\n    if (type === \"string\") {\n      return strnum;\n    } else if (type === \"number\") {\n      return String(strnum);\n    } else {\n      throw TypeError(\"Expected a string or number, got \" + __typeof(strnum));\n    }\n  };\n  __toArray = function (x) {\n    if (x == null) {\n      throw TypeError(\"Expected an object, got \" + __typeof(x));\n    } else if (__isArray(x)) {\n      return x;\n    } else if (typeof x === \"string\") {\n      return x.split(\"\");\n    } else {\n      return __slice.call(x);\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var _p2, _ref, _this, assignment, body, constructorCount, ctor, declaration, displayName, hasSuperclass, hasTopLevelConstructor, init, macroName, name, prototype, result, self, sup, superclass, superproto;\n    _this = this;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    name = _p2.name;\n    superclass = _p2.superclass;\n    body = _p2.body;\n    if (this.isIdent(name)) {\n      declaration = name;\n    } else if (this.isAccess(name)) {\n      assignment = name;\n      if (this.isConst(this.child(name)) && typeof this.value(this.child(name)) === \"string\") {\n        name = (_ref = this.ident(this.value(this.child(name)))) != null ? _ref : this.tmp(\"class\", false, \"function\");\n      } else {\n        name = this.tmp(\"class\", false, \"function\");\n      }\n    } else {\n      name = this.tmp(\"class\", false, \"function\");\n    }\n    hasSuperclass = !!superclass;\n    sup = superclass && (this.isIdent(superclass) ? superclass : this.tmp(\"super\", false, \"function\"));\n    init = [];\n    if (!superclass) {\n      superproto = __node(\n        \"Access\",\n        75785,\n        75802,\n        __node(\"Ident\", 75785, 75792, \"Object\"),\n        __node(\"Const\", 75793, 75802, \"prototype\")\n      );\n    } else {\n      superproto = this.tmp(\n        this.isIdent(sup) ? __strnum(this.name(sup)) + \"_prototype\" : \"super_prototype\",\n        false,\n        \"object\"\n      );\n    }\n    prototype = this.tmp(\n      this.isIdent(name) ? __strnum(this.name(name)) + \"_prototype\" : \"prototype\",\n      false,\n      \"object\"\n    );\n    if (superclass) {\n      init.push(__node(\n        \"MacroAccess\",\n        76057,\n        76090,\n        29,\n        2340,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              76061,\n              76073,\n              28,\n              2340,\n              __node(\n                \"MacroAccess\",\n                76061,\n                76073,\n                22,\n                2340,\n                { ident: __wrap(superproto, 450) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\n              \"Access\",\n              76075,\n              76090,\n              __wrap(sup, 450),\n              __node(\"Const\", 76081, 76090, \"prototype\")\n            )\n          }\n        },\n        \"statement\",\n        false\n      ));\n      init.push(__node(\n        \"MacroAccess\",\n        76110,\n        76170,\n        29,\n        2341,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              76114,\n              76125,\n              28,\n              2341,\n              __node(\n                \"MacroAccess\",\n                76114,\n                76125,\n                22,\n                2341,\n                { ident: __wrap(prototype, 450) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\n              \"Assign\",\n              76127,\n              76170,\n              __node(\n                \"Access\",\n                76133,\n                76143,\n                __wrap(name, 450),\n                __node(\"Const\", 76134, 76143, \"prototype\")\n              ),\n              \"=\",\n              __node(\n                \"Object\",\n                76146,\n                76170,\n                [],\n                __wrap(superproto, 450)\n              )\n            )\n          }\n        },\n        \"statement\",\n        false\n      ));\n      init.push(__node(\n        \"Assign\",\n        76191,\n        76223,\n        __node(\n          \"Access\",\n          76202,\n          76214,\n          __wrap(prototype, 450),\n          __node(\"Const\", 76203, 76214, \"constructor\")\n        ),\n        \"=\",\n        __wrap(name, 450)\n      ));\n    } else {\n      init.push(__node(\n        \"MacroAccess\",\n        76252,\n        76285,\n        29,\n        2344,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              76256,\n              76267,\n              28,\n              2344,\n              __node(\n                \"MacroAccess\",\n                76256,\n                76267,\n                22,\n                2344,\n                { ident: __wrap(prototype, 450) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\n              \"Access\",\n              76269,\n              76285,\n              __wrap(name, 450),\n              __node(\"Const\", 76276, 76285, \"prototype\")\n            )\n          }\n        },\n        \"statement\",\n        false\n      ));\n    }\n    if (this.isIdent(name)) {\n      displayName = this[\"const\"](this.name(name));\n    }\n    if (displayName != null) {\n      init.push(__node(\n        \"Assign\",\n        76399,\n        76435,\n        __node(\n          \"Access\",\n          76405,\n          76418,\n          __wrap(name, 450),\n          __node(\"Const\", 76406, 76418, \"displayName\")\n        ),\n        \"=\",\n        __wrap(displayName, 450)\n      ));\n    }\n    function fixSupers(node) {\n      return _this.walk(node, function (node) {\n        var _arr, _arr2, _i, _len, args, child, superArg;\n        if (_this.isSuper(node)) {\n          child = _this.superChild(node);\n          if (child != null) {\n            child = fixSupers(child);\n          }\n          for (_arr = [], _arr2 = __toArray(_this.superArgs(node)), _i = 0, _len = _arr2.length; _i < _len; ++_i) {\n            superArg = _arr2[_i];\n            _arr.push(fixSupers(superArg));\n          }\n          args = _arr;\n          return _this.call(\n            child != null\n              ? __node(\n                \"Access\",\n                76761,\n                76781,\n                __wrap(superproto, 461),\n                __wrap(child, 461)\n              )\n              : !superclass ? __node(\"Ident\", 76831, 76838, \"Object\")\n              : __wrap(sup, 461),\n            [__node(\"This\", 76891, 76896)].concat(args),\n            false,\n            true\n          );\n        }\n      });\n    }\n    body = fixSupers(this.macroExpandAll(body));\n    constructorCount = 0;\n    this.walk(body, function (node) {\n      var key;\n      if (_this.isDef(node)) {\n        key = _this.left(node);\n        if (_this.isConst(key) && _this.value(key) === \"constructor\") {\n          ++constructorCount;\n        }\n      }\n      return;\n    });\n    hasTopLevelConstructor = false;\n    if (constructorCount === 1) {\n      this.walk(body, function (node) {\n        var key;\n        if (_this.isDef(node)) {\n          key = _this.left(node);\n          if (_this.isConst(key) && _this.value(key) === \"constructor\" && _this.isFunc(_this.right(node))) {\n            hasTopLevelConstructor = true;\n          }\n          return node;\n        } else {\n          return node;\n        }\n      });\n    }\n    self = this.tmp(\"this\");\n    if (hasTopLevelConstructor) {\n      body = this.walk(body, function (node) {\n        var constructor, key, value;\n        if (_this.isDef(node)) {\n          key = _this.left(node);\n          if (_this.isConst(key) && _this.value(key) === \"constructor\") {\n            value = _this.right(node);\n            constructor = _this.func(_this.funcParams(value), _this.funcBody(value), false, __node(\n              \"MacroAccess\",\n              77955,\n              78034,\n              18,\n              2400,\n              {\n                macroName: \"if\",\n                macroData: {\n                  test: __node(\n                    \"MacroAccess\",\n                    77958,\n                    77988,\n                    61,\n                    2400,\n                    {\n                      left: __node(\"Eval\", 77958, 77971, __node(\"Const\", 77964, 77970, \"this\")),\n                      inverted: false,\n                      op: \"instanceof\",\n                      right: __wrap(name, 468)\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  body: __node(\"Eval\", 77993, 78006, __node(\"Const\", 77999, 78005, \"this\")),\n                  elseIfs: [],\n                  elseBody: __node(\n                    \"Object\",\n                    78011,\n                    78034,\n                    [],\n                    __wrap(prototype, 468)\n                  )\n                }\n              },\n              \"statement\",\n              false\n            ));\n            init.unshift(__node(\n              \"MacroAccess\",\n              78064,\n              78089,\n              29,\n              2401,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    78068,\n                    78074,\n                    28,\n                    2401,\n                    __node(\n                      \"MacroAccess\",\n                      78068,\n                      78074,\n                      22,\n                      2401,\n                      { ident: __wrap(name, 468) },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __wrap(constructor, 468)\n                }\n              },\n              \"statement\",\n              false\n            ));\n            return _this.noop();\n          }\n        } else {\n          return node;\n        }\n      });\n    } else if (constructorCount !== 0) {\n      ctor = this.tmp(\"ctor\", false, \"function\");\n      result = this.tmp(\"ref\");\n      init.push(__node(\n        \"Block\",\n        78268,\n        78752,\n        [\n          __node(\n            \"MacroAccess\",\n            78276,\n            78300,\n            29,\n            2409,\n            {\n              macroName: \"let\",\n              macroData: {\n                declarable: __node(\n                  \"MacroAccess\",\n                  78279,\n                  78293,\n                  28,\n                  2409,\n                  __node(\n                    \"MacroAccess\",\n                    78279,\n                    78293,\n                    22,\n                    2409,\n                    {\n                      isMutable: \"mutable\",\n                      ident: __wrap(ctor, 450)\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  \"statement\",\n                  false\n                ),\n                value: __node(\"Const\", 78295, 78300, void 0)\n              }\n            },\n            \"statement\",\n            false\n          ),\n          __node(\n            \"MacroAccess\",\n            78309,\n            78752,\n            17,\n            2410,\n            {\n              macroName: \"let\",\n              macroData: {\n                ident: __wrap(name, 450),\n                func: __node(\n                  \"Function\",\n                  78318,\n                  78752,\n                  [],\n                  __node(\n                    \"Block\",\n                    78321,\n                    78752,\n                    [\n                      __node(\n                        \"MacroAccess\",\n                        78331,\n                        78405,\n                        29,\n                        2411,\n                        {\n                          macroName: \"let\",\n                          macroData: {\n                            declarable: __node(\n                              \"MacroAccess\",\n                              78334,\n                              78340,\n                              28,\n                              2411,\n                              __node(\n                                \"MacroAccess\",\n                                78334,\n                                78340,\n                                22,\n                                2411,\n                                { ident: __wrap(self, 475) },\n                                \"statement\",\n                                false\n                              ),\n                              \"statement\",\n                              false\n                            ),\n                            value: __node(\n                              \"MacroAccess\",\n                              78342,\n                              78405,\n                              18,\n                              2411,\n                              {\n                                macroName: \"if\",\n                                macroData: {\n                                  test: __node(\n                                    \"MacroAccess\",\n                                    78345,\n                                    78367,\n                                    61,\n                                    2411,\n                                    {\n                                      left: __node(\"This\", 78345, 78350),\n                                      inverted: false,\n                                      op: \"instanceof\",\n                                      right: __wrap(name, 475)\n                                    },\n                                    \"expression\",\n                                    false\n                                  ),\n                                  body: __node(\"This\", 78372, 78377),\n                                  elseIfs: [],\n                                  elseBody: __node(\n                                    \"Object\",\n                                    78382,\n                                    78405,\n                                    [],\n                                    __wrap(prototype, 475)\n                                  )\n                                }\n                              },\n                              \"expression\",\n                              false\n                            )\n                          }\n                        },\n                        \"statement\",\n                        false\n                      ),\n                      __node(\n                        \"MacroAccess\",\n                        78427,\n                        78736,\n                        19,\n                        2413,\n                        {\n                          macroName: \"if\",\n                          macroData: {\n                            test: __node(\n                              \"MacroAccess\",\n                              78429,\n                              78455,\n                              5,\n                              2413,\n                              {\n                                left: __node(\n                                  \"MacroAccess\",\n                                  78429,\n                                  78442,\n                                  4,\n                                  2413,\n                                  {\n                                    op: \"typeof\",\n                                    node: __wrap(ctor, 475)\n                                  },\n                                  \"statement\",\n                                  false\n                                ),\n                                inverted: false,\n                                op: \"==\",\n                                right: __node(\"Const\", 78447, 78455, \"function\")\n                              },\n                              \"statement\",\n                              false\n                            ),\n                            body: __node(\n                              \"Block\",\n                              78456,\n                              78579,\n                              [\n                                __node(\n                                  \"MacroAccess\",\n                                  78468,\n                                  78508,\n                                  29,\n                                  2414,\n                                  {\n                                    macroName: \"let\",\n                                    macroData: {\n                                      declarable: __node(\n                                        \"MacroAccess\",\n                                        78471,\n                                        78479,\n                                        28,\n                                        2414,\n                                        __node(\n                                          \"MacroAccess\",\n                                          78471,\n                                          78479,\n                                          22,\n                                          2414,\n                                          { ident: __wrap(result, 475) },\n                                          \"statement\",\n                                          false\n                                        ),\n                                        \"statement\",\n                                        false\n                                      ),\n                                      value: __node(\n                                        \"Call\",\n                                        78481,\n                                        78508,\n                                        __wrap(ctor, 475),\n                                        [\n                                          __wrap(self, 475),\n                                          __node(\"Spread\", 78495, 78508, __node(\"Args\", 78499, 78508))\n                                        ],\n                                        false,\n                                        true\n                                      )\n                                    }\n                                  },\n                                  \"statement\",\n                                  false\n                                ),\n                                __node(\n                                  \"MacroAccess\",\n                                  78521,\n                                  78579,\n                                  19,\n                                  2415,\n                                  {\n                                    macroName: \"if\",\n                                    macroData: {\n                                      test: __node(\n                                        \"MacroAccess\",\n                                        78523,\n                                        78550,\n                                        5,\n                                        2415,\n                                        {\n                                          left: __node(\n                                            \"Call\",\n                                            78523,\n                                            78539,\n                                            __node(\"Ident\", 78523, 78530, \"Object\"),\n                                            [__wrap(result, 475)],\n                                            false,\n                                            false\n                                          ),\n                                          inverted: false,\n                                          op: \"==\",\n                                          right: __wrap(result, 475)\n                                        },\n                                        \"statement\",\n                                        false\n                                      ),\n                                      body: __node(\n                                        \"MacroAccess\",\n                                        78565,\n                                        78579,\n                                        30,\n                                        2416,\n                                        {\n                                          macroName: \"return\",\n                                          macroData: { node: __wrap(result, 475) }\n                                        },\n                                        \"statement\",\n                                        false\n                                      ),\n                                      elseIfs: []\n                                    }\n                                  },\n                                  \"statement\",\n                                  false\n                                )\n                              ],\n                              null\n                            ),\n                            elseIfs: [\n                              {\n                                type: \"if\",\n                                test: __wrap(hasSuperclass, 475),\n                                body: __node(\n                                  \"Block\",\n                                  78614,\n                                  78736,\n                                  [\n                                    __node(\n                                      \"MacroAccess\",\n                                      78626,\n                                      78665,\n                                      29,\n                                      2418,\n                                      {\n                                        macroName: \"let\",\n                                        macroData: {\n                                          declarable: __node(\n                                            \"MacroAccess\",\n                                            78629,\n                                            78637,\n                                            28,\n                                            2418,\n                                            __node(\n                                              \"MacroAccess\",\n                                              78629,\n                                              78637,\n                                              22,\n                                              2418,\n                                              { ident: __wrap(result, 475) },\n                                              \"statement\",\n                                              false\n                                            ),\n                                            \"statement\",\n                                            false\n                                          ),\n                                          value: __node(\n                                            \"Call\",\n                                            78639,\n                                            78665,\n                                            __wrap(sup, 475),\n                                            [\n                                              __wrap(self, 475),\n                                              __node(\"Spread\", 78652, 78665, __node(\"Args\", 78656, 78665))\n                                            ],\n                                            false,\n                                            true\n                                          )\n                                        }\n                                      },\n                                      \"statement\",\n                                      false\n                                    ),\n                                    __node(\n                                      \"MacroAccess\",\n                                      78678,\n                                      78736,\n                                      19,\n                                      2419,\n                                      {\n                                        macroName: \"if\",\n                                        macroData: {\n                                          test: __node(\n                                            \"MacroAccess\",\n                                            78680,\n                                            78707,\n                                            5,\n                                            2419,\n                                            {\n                                              left: __node(\n                                                \"Call\",\n                                                78680,\n                                                78696,\n                                                __node(\"Ident\", 78680, 78687, \"Object\"),\n                                                [__wrap(result, 475)],\n                                                false,\n                                                false\n                                              ),\n                                              inverted: false,\n                                              op: \"==\",\n                                              right: __wrap(result, 475)\n                                            },\n                                            \"statement\",\n                                            false\n                                          ),\n                                          body: __node(\n                                            \"MacroAccess\",\n                                            78722,\n                                            78736,\n                                            30,\n                                            2420,\n                                            {\n                                              macroName: \"return\",\n                                              macroData: { node: __wrap(result, 475) }\n                                            },\n                                            \"statement\",\n                                            false\n                                          ),\n                                          elseIfs: []\n                                        }\n                                      },\n                                      \"statement\",\n                                      false\n                                    )\n                                  ],\n                                  null\n                                )\n                              }\n                            ]\n                          }\n                        },\n                        \"statement\",\n                        false\n                      ),\n                      __wrap(self, 475)\n                    ],\n                    null\n                  ),\n                  true,\n                  false,\n                  void 0,\n                  false\n                )\n              }\n            },\n            \"statement\",\n            false\n          )\n        ],\n        null\n      ));\n      body = this.walk(body, function (node) {\n        var key, value;\n        if (_this.isDef(node)) {\n          key = _this.left(node);\n          if (_this.isConst(key) && _this.value(key) === \"constructor\") {\n            value = _this.right(node);\n            return __node(\n              \"Assign\",\n              78958,\n              78974,\n              __wrap(ctor, 479),\n              \"=\",\n              __wrap(value, 479)\n            );\n          }\n        }\n      });\n    } else if (!superclass) {\n      init.push(__node(\n        \"MacroAccess\",\n        79040,\n        79117,\n        17,\n        2431,\n        {\n          macroName: \"let\",\n          macroData: {\n            ident: __wrap(name, 450),\n            func: __node(\n              \"Function\",\n              79049,\n              79117,\n              [],\n              __node(\n                \"MacroAccess\",\n                79054,\n                79117,\n                18,\n                2431,\n                {\n                  macroName: \"if\",\n                  macroData: {\n                    test: __node(\n                      \"MacroAccess\",\n                      79057,\n                      79079,\n                      61,\n                      2431,\n                      {\n                        left: __node(\"This\", 79057, 79062),\n                        inverted: false,\n                        op: \"instanceof\",\n                        right: __wrap(name, 482)\n                      },\n                      \"statement\",\n                      false\n                    ),\n                    body: __node(\"This\", 79084, 79089),\n                    elseIfs: [],\n                    elseBody: __node(\n                      \"Object\",\n                      79094,\n                      79117,\n                      [],\n                      __wrap(prototype, 482)\n                    )\n                  }\n                },\n                \"statement\",\n                false\n              ),\n              true,\n              false,\n              void 0,\n              false\n            )\n          }\n        },\n        \"statement\",\n        false\n      ));\n    } else {\n      result = this.tmp(\"ref\");\n      init.push(__node(\n        \"MacroAccess\",\n        79192,\n        79443,\n        17,\n        2435,\n        {\n          macroName: \"let\",\n          macroData: {\n            ident: __wrap(name, 450),\n            func: __node(\n              \"Function\",\n              79201,\n              79443,\n              [],\n              __node(\n                \"Block\",\n                79204,\n                79443,\n                [\n                  __node(\n                    \"MacroAccess\",\n                    79216,\n                    79290,\n                    29,\n                    2436,\n                    {\n                      macroName: \"let\",\n                      macroData: {\n                        declarable: __node(\n                          \"MacroAccess\",\n                          79219,\n                          79225,\n                          28,\n                          2436,\n                          __node(\n                            \"MacroAccess\",\n                            79219,\n                            79225,\n                            22,\n                            2436,\n                            { ident: __wrap(self, 484) },\n                            \"statement\",\n                            false\n                          ),\n                          \"statement\",\n                          false\n                        ),\n                        value: __node(\n                          \"MacroAccess\",\n                          79227,\n                          79290,\n                          18,\n                          2436,\n                          {\n                            macroName: \"if\",\n                            macroData: {\n                              test: __node(\n                                \"MacroAccess\",\n                                79230,\n                                79252,\n                                61,\n                                2436,\n                                {\n                                  left: __node(\"This\", 79230, 79235),\n                                  inverted: false,\n                                  op: \"instanceof\",\n                                  right: __wrap(name, 484)\n                                },\n                                \"expression\",\n                                false\n                              ),\n                              body: __node(\"This\", 79257, 79262),\n                              elseIfs: [],\n                              elseBody: __node(\n                                \"Object\",\n                                79267,\n                                79290,\n                                [],\n                                __wrap(prototype, 484)\n                              )\n                            }\n                          },\n                          \"expression\",\n                          false\n                        )\n                      }\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  __node(\n                    \"MacroAccess\",\n                    79303,\n                    79342,\n                    29,\n                    2437,\n                    {\n                      macroName: \"let\",\n                      macroData: {\n                        declarable: __node(\n                          \"MacroAccess\",\n                          79306,\n                          79314,\n                          28,\n                          2437,\n                          __node(\n                            \"MacroAccess\",\n                            79306,\n                            79314,\n                            22,\n                            2437,\n                            { ident: __wrap(result, 484) },\n                            \"statement\",\n                            false\n                          ),\n                          \"statement\",\n                          false\n                        ),\n                        value: __node(\n                          \"Call\",\n                          79316,\n                          79342,\n                          __wrap(sup, 484),\n                          [\n                            __wrap(self, 484),\n                            __node(\"Spread\", 79329, 79342, __node(\"Args\", 79333, 79342))\n                          ],\n                          false,\n                          true\n                        )\n                      }\n                    },\n                    \"statement\",\n                    false\n                  ),\n                  __node(\n                    \"MacroAccess\",\n                    79355,\n                    79443,\n                    19,\n                    2438,\n                    {\n                      macroName: \"if\",\n                      macroData: {\n                        test: __node(\n                          \"MacroAccess\",\n                          79357,\n                          79384,\n                          5,\n                          2438,\n                          {\n                            left: __node(\n                              \"Call\",\n                              79357,\n                              79373,\n                              __node(\"Ident\", 79357, 79364, \"Object\"),\n                              [__wrap(result, 484)],\n                              false,\n                              false\n                            ),\n                            inverted: false,\n                            op: \"==\",\n                            right: __wrap(result, 484)\n                          },\n                          \"statement\",\n                          false\n                        ),\n                        body: __wrap(result, 484),\n                        elseIfs: [],\n                        elseBody: __wrap(self, 484)\n                      }\n                    },\n                    \"statement\",\n                    false\n                  )\n                ],\n                null\n              ),\n              true,\n              false,\n              void 0,\n              false\n            )\n          }\n        },\n        \"statement\",\n        false\n      ));\n    }\n    function changeDefs(node) {\n      return _this.walk(node, function (node) {\n        var _ref, key, value;\n        if (_this.isDef(node)) {\n          key = _this.left(node);\n          if ((_ref = _this.right(node)) != null) {\n            value = _ref;\n          } else {\n            value = __node(\n              \"Function\",\n              79594,\n              79687,\n              [],\n              __node(\n                \"MacroAccess\",\n                79596,\n                79687,\n                11,\n                2446,\n                {\n                  op: \"throw\",\n                  node: __node(\n                    \"Call\",\n                    79602,\n                    79687,\n                    __node(\"Ident\", 79602, 79608, \"Error\"),\n                    [\n                      __node(\n                        \"MacroAccess\",\n                        79609,\n                        79687,\n                        56,\n                        2446,\n                        {\n                          left: __node(\n                            \"MacroAccess\",\n                            79609,\n                            79687,\n                            56,\n                            2446,\n                            {\n                              left: __node(\n                                \"MacroAccess\",\n                                79609,\n                                79687,\n                                56,\n                                2446,\n                                {\n                                  left: __node(\n                                    \"MacroAccess\",\n                                    79609,\n                                    79687,\n                                    56,\n                                    2446,\n                                    {\n                                      left: __node(\"Const\", 79609, 79687, \"Not implemented: \"),\n                                      op: \"\",\n                                      right: __node(\n                                        \"MacroAccess\",\n                                        79629,\n                                        79675,\n                                        2,\n                                        2446,\n                                        {\n                                          left: __node(\n                                            \"Access\",\n                                            79629,\n                                            79654,\n                                            __node(\n                                              \"Access\",\n                                              79629,\n                                              79654,\n                                              __node(\"This\", 79629, 79630),\n                                              __node(\"Const\", 79630, 79641, \"constructor\")\n                                            ),\n                                            __node(\"Const\", 79642, 79654, \"displayName\")\n                                          ),\n                                          inverted: false,\n                                          op: \"or\",\n                                          right: __node(\n                                            \"Access\",\n                                            79657,\n                                            79675,\n                                            __node(\n                                              \"Access\",\n                                              79657,\n                                              79675,\n                                              __node(\"This\", 79657, 79659),\n                                              __node(\"Const\", 79659, 79670, \"constructor\")\n                                            ),\n                                            __node(\"Const\", 79671, 79675, \"name\")\n                                          )\n                                        },\n                                        \"expression\",\n                                        false\n                                      )\n                                    },\n                                    \"expression\",\n                                    false\n                                  ),\n                                  op: \"\",\n                                  right: __node(\"Const\", 79609, 79687, \".\")\n                                },\n                                \"expression\",\n                                false\n                              ),\n                              op: \"\",\n                              right: __wrap(key, 491)\n                            },\n                            \"expression\",\n                            false\n                          ),\n                          op: \"\",\n                          right: __node(\"Const\", 79609, 79687, \"()\")\n                        },\n                        \"expression\",\n                        false\n                      )\n                    ],\n                    false,\n                    false\n                  )\n                },\n                \"statement\",\n                false\n              ),\n              true,\n              false,\n              void 0,\n              false\n            );\n          }\n          return changeDefs(__node(\n            \"Assign\",\n            79712,\n            79739,\n            __node(\n              \"Access\",\n              79723,\n              79729,\n              __wrap(prototype, 488),\n              __wrap(key, 488)\n            ),\n            \"=\",\n            __wrap(value, 488)\n          ));\n        }\n      });\n    }\n    body = changeDefs(body);\n    body = this.walk(body, function (node) {\n      if (_this.isFunc(node)) {\n        if (!_this.funcIsBound(node)) {\n          return node;\n        }\n      } else if (_this.isThis(node)) {\n        return name;\n      }\n    });\n    result = __node(\n      \"MacroAccess\",\n      79957,\n      80022,\n      91,\n      2457,\n      {\n        macroName: \"do\",\n        macroData: {\n          locals: {\n            ident: __wrap(sup, 450),\n            value: __wrap(superclass, 450),\n            rest: []\n          },\n          body: __node(\n            \"Block\",\n            79980,\n            80022,\n            [\n              __wrap(init, 450),\n              __wrap(body, 450),\n              __node(\n                \"MacroAccess\",\n                80010,\n                80022,\n                30,\n                2460,\n                {\n                  macroName: \"return\",\n                  macroData: { node: __wrap(name, 450) }\n                },\n                \"statement\",\n                false\n              )\n            ],\n            null\n          )\n        }\n      },\n      \"statement\",\n      false\n    );\n    if (declaration != null) {\n      return __node(\n        \"MacroAccess\",\n        80057,\n        80084,\n        29,\n        2463,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              80061,\n              80074,\n              28,\n              2463,\n              __node(\n                \"MacroAccess\",\n                80061,\n                80074,\n                22,\n                2463,\n                { ident: __wrap(declaration, 450) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __wrap(result, 450)\n          }\n        },\n        \"statement\",\n        false\n      );\n    } else if (assignment != null) {\n      return __node(\n        \"Assign\",\n        80119,\n        80142,\n        __wrap(assignment, 450),\n        \"=\",\n        __wrap(result, 450)\n      );\n    } else {\n      return result;\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"name","asType":{"type":"many","multiplier":"?","inner":{"type":"ident","name":"SimpleAssignable"}}},{"type":"ident","name":"superclass","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"extends"},{"type":"this"}]}}},{"type":"ident","name":"body","asType":{"type":"many","multiplier":"?","inner":{"type":"ident","name":"Body"}}}],"names":["class"],"id":126},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, _ref, _this, assignment, body, declaration, index, macroName, name, result;\n    _this = this;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    name = _p2.name;\n    body = _p2.body;\n    if (this.isIdent(name)) {\n      declaration = name;\n    } else if (this.isAccess(name)) {\n      assignment = name;\n      if (this.isConst(this.child(name)) && typeof this.value(this.child(name)) === \"string\") {\n        name = (_ref = this.ident(this.value(this.child(name)))) != null ? _ref : this.tmp(\"enum\", false, \"object\");\n      } else {\n        name = this.tmp(\"enum\", false, \"object\");\n      }\n    } else {\n      name = this.tmp(\"enum\", false, \"object\");\n    }\n    index = 0;\n    body = this.walk(this.macroExpandAll(body), function (node) {\n      var key, value;\n      if (_this.isDef(node)) {\n        key = _this.left(node);\n        value = _this.right(node);\n        if (!_this.isConst(key)) {\n          throw Error(\"Cannot have non-const enum keys\");\n        }\n        if (!value) {\n          ++index;\n          value = index;\n        }\n        return __node(\n          \"Assign\",\n          80991,\n          81012,\n          __node(\n            \"Access\",\n            80991,\n            81002,\n            __node(\"This\", 80991, 80996),\n            __wrap(key, 495)\n          ),\n          \"=\",\n          __wrap(value, 495)\n        );\n      } else {\n        return node;\n      }\n    });\n    result = __node(\n      \"MacroAccess\",\n      81063,\n      81101,\n      92,\n      2498,\n      {\n        macroName: \"with\",\n        macroData: {\n          node: __node(\n            \"Object\",\n            81068,\n            81071,\n            [],\n            void 0\n          ),\n          body: __node(\n            \"Block\",\n            81072,\n            81101,\n            [\n              __wrap(body, 494),\n              __node(\n                \"MacroAccess\",\n                81090,\n                81101,\n                30,\n                2500,\n                {\n                  macroName: \"return\",\n                  macroData: { node: __node(\"This\", 81096, 81101) }\n                },\n                \"statement\",\n                false\n              )\n            ],\n            null\n          )\n        }\n      },\n      \"expression\",\n      false\n    );\n    if (declaration != null) {\n      return __node(\n        \"MacroAccess\",\n        81136,\n        81163,\n        29,\n        2503,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              81140,\n              81153,\n              28,\n              2503,\n              __node(\n                \"MacroAccess\",\n                81140,\n                81153,\n                22,\n                2503,\n                { ident: __wrap(declaration, 494) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __wrap(result, 494)\n          }\n        },\n        \"statement\",\n        false\n      );\n    } else if (assignment != null) {\n      return __node(\n        \"Assign\",\n        81198,\n        81221,\n        __wrap(assignment, 494),\n        \"=\",\n        __wrap(result, 494)\n      );\n    } else {\n      return result;\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"name","asType":{"type":"many","multiplier":"?","inner":{"type":"ident","name":"SimpleAssignable"}}},{"type":"ident","name":"body","asType":{"type":"many","multiplier":"?","inner":{"type":"ident","name":"Body"}}}],"names":["enum"],"id":127},{"code":"return (function () {\n  \"use strict\";\n  var __isArray, __slice, __toArray, __typeof;\n  __isArray = typeof Array.isArray === \"function\" ? Array.isArray\n    : (function () {\n      var _toString;\n      _toString = Object.prototype.toString;\n      return function (x) {\n        return _toString.call(x) === \"[object Array]\";\n      };\n    }());\n  __slice = Array.prototype.slice;\n  __toArray = function (x) {\n    if (x == null) {\n      throw TypeError(\"Expected an object, got \" + __typeof(x));\n    } else if (__isArray(x)) {\n      return x;\n    } else if (typeof x === \"string\") {\n      return x.split(\"\");\n    } else {\n      return __slice.call(x);\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var _p2, _ref, _this, assignment, body, declaration, init, macroName, name, result, sup, superobject;\n    _this = this;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    name = _p2.name;\n    superobject = _p2.superobject;\n    body = _p2.body;\n    if (this.isIdent(name)) {\n      declaration = name;\n    } else if (this.isAccess(name)) {\n      assignment = name;\n      if (this.isConst(this.child(name)) && typeof this.value(this.child(name)) === \"string\") {\n        name = (_ref = this.ident(this.value(this.child(name)))) != null ? _ref : this.tmp(\"ns\", false, \"object\");\n      } else {\n        name = this.tmp(\"ns\", false, \"object\");\n      }\n    } else {\n      name = this.tmp(\"ns\", false, \"object\");\n    }\n    sup = superobject && (this.isIdent(superobject) ? superobject : this.tmp(\"super\", false, \"object\"));\n    init = [];\n    if (!superobject) {\n      init.push(__node(\n        \"MacroAccess\",\n        81937,\n        81952,\n        29,\n        2527,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              81941,\n              81947,\n              28,\n              2527,\n              __node(\n                \"MacroAccess\",\n                81941,\n                81947,\n                22,\n                2527,\n                { ident: __wrap(name, 499) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\n              \"Object\",\n              81949,\n              81952,\n              [],\n              void 0\n            )\n          }\n        },\n        \"statement\",\n        false\n      ));\n    } else {\n      init.push(__node(\n        \"MacroAccess\",\n        81981,\n        82010,\n        29,\n        2529,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              81985,\n              81991,\n              28,\n              2529,\n              __node(\n                \"MacroAccess\",\n                81985,\n                81991,\n                22,\n                2529,\n                { ident: __wrap(name, 499) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __node(\n              \"Object\",\n              81993,\n              82010,\n              [],\n              __wrap(sup, 499)\n            )\n          }\n        },\n        \"statement\",\n        false\n      ));\n    }\n    function fixSupers(node) {\n      return _this.walk(node, function (node) {\n        var _arr, _arr2, _i, _len, args, child, parent, superArg;\n        if (_this.isSuper(node)) {\n          child = _this.superChild(node);\n          if (child != null) {\n            child = fixSupers(child);\n          }\n          for (_arr = [], _arr2 = __toArray(_this.superArgs(node)), _i = 0, _len = _arr2.length; _i < _len; ++_i) {\n            superArg = _arr2[_i];\n            _arr.push(fixSupers(superArg));\n          }\n          args = _arr;\n          if (!superobject) {\n            parent = __node(\n              \"Access\",\n              82330,\n              82347,\n              __node(\"Ident\", 82330, 82337, \"Object\"),\n              __node(\"Const\", 82338, 82347, \"prototype\")\n            );\n          } else {\n            parent = __wrap(sup, 505);\n          }\n          return _this.call(\n            child != null\n              ? __node(\n                \"Access\",\n                82432,\n                82448,\n                __wrap(parent, 505),\n                __wrap(child, 505)\n              )\n              : __wrap(parent, 505),\n            [__node(\"This\", 82504, 82509)].concat(args),\n            false,\n            true\n          );\n        }\n      });\n    }\n    body = fixSupers(this.macroExpandAll(body));\n    function changeDefs(node) {\n      return _this.walk(node, function (node) {\n        var key, value;\n        if (_this.isDef(node)) {\n          key = _this.left(node);\n          value = _this.right(node);\n          return changeDefs(__node(\n            \"Assign\",\n            82769,\n            82791,\n            __node(\n              \"Access\",\n              82775,\n              82781,\n              __wrap(name, 509),\n              __wrap(key, 509)\n            ),\n            \"=\",\n            __wrap(value, 509)\n          ));\n        }\n      });\n    }\n    body = changeDefs(body);\n    body = this.walk(body, function (node) {\n      if (_this.isFunc(node)) {\n        if (!_this.funcIsBound(node)) {\n          return node;\n        }\n      } else if (_this.isThis(node)) {\n        return name;\n      }\n    });\n    result = __node(\n      \"MacroAccess\",\n      83009,\n      83075,\n      91,\n      2566,\n      {\n        macroName: \"do\",\n        macroData: {\n          locals: {\n            ident: __wrap(sup, 499),\n            value: __wrap(superobject, 499),\n            rest: []\n          },\n          body: __node(\n            \"Block\",\n            83033,\n            83075,\n            [\n              __wrap(init, 499),\n              __wrap(body, 499),\n              __node(\n                \"MacroAccess\",\n                83063,\n                83075,\n                30,\n                2569,\n                {\n                  macroName: \"return\",\n                  macroData: { node: __wrap(name, 499) }\n                },\n                \"statement\",\n                false\n              )\n            ],\n            null\n          )\n        }\n      },\n      \"statement\",\n      false\n    );\n    if (declaration != null) {\n      return __node(\n        \"MacroAccess\",\n        83110,\n        83137,\n        29,\n        2572,\n        {\n          macroName: \"let\",\n          macroData: {\n            declarable: __node(\n              \"MacroAccess\",\n              83114,\n              83127,\n              28,\n              2572,\n              __node(\n                \"MacroAccess\",\n                83114,\n                83127,\n                22,\n                2572,\n                { ident: __wrap(declaration, 499) },\n                \"statement\",\n                false\n              ),\n              \"statement\",\n              false\n            ),\n            value: __wrap(result, 499)\n          }\n        },\n        \"statement\",\n        false\n      );\n    } else if (assignment != null) {\n      return __node(\n        \"Assign\",\n        83172,\n        83195,\n        __wrap(assignment, 499),\n        \"=\",\n        __wrap(result, 499)\n      );\n    } else {\n      return result;\n    }\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"name","asType":{"type":"many","multiplier":"?","inner":{"type":"ident","name":"SimpleAssignable"}}},{"type":"ident","name":"superobject","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"extends"},{"type":"this"}]}}},{"type":"ident","name":"body","asType":{"type":"many","multiplier":"?","inner":{"type":"ident","name":"Body"}}}],"names":["namespace"],"id":128},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, _this, macroName, node;\n    _this = this;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    node = _p2.node;\n    if (!this.inGenerator) {\n      throw Error(\"Can only use yield in a generator function\");\n    }\n    return this.mutateLast(\n      node || this.noop(),\n      function (n) {\n        return _this[\"yield\"](n);\n      },\n      true\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"node","asType":{"type":"ident","name":"Expression"}}],"names":["yield"],"id":129},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, item, macroName, node, yieldItem;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    node = _p2.node;\n    if (!this.inGenerator) {\n      throw Error(\"Can only use yield* in a generator function\");\n    }\n    item = this.tmp(\"item\");\n    yieldItem = this[\"yield\"](item);\n    return __node(\n      \"MacroAccess\",\n      83611,\n      83651,\n      108,\n      2591,\n      {\n        macroName: \"for\",\n        macroData: {\n          value: __wrap(item, 516),\n          iterable: __wrap(node, 516),\n          body: __wrap(yieldItem, 516)\n        }\n      },\n      \"statement\",\n      false\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"node","asType":{"type":"ident","name":"Expression"}}],"names":["yield*"],"id":130},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, macroName, node, rest;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    node = _p2.node;\n    rest = _p2.rest;\n    return __node(\n      \"Block\",\n      83727,\n      83757,\n      [\n        __wrap(rest, 519),\n        __node(\n          \"MacroAccess\",\n          83745,\n          83757,\n          30,\n          2598,\n          {\n            macroName: \"return\",\n            macroData: { node: __wrap(node, 519) }\n          },\n          \"statement\",\n          false\n        )\n      ],\n      null\n    );\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"node","asType":{"type":"ident","name":"Expression"}},{"type":"ident","name":"rest","asType":{"type":"ident","name":"DedentedBody"}}],"names":["returning"],"id":131},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _p2, label, macroName, node;\n    macroName = _p.macroName;\n    _p2 = _p.macroData;\n    label = _p2.label;\n    node = _p2.node;\n    return this.withLabel(node, label);\n  };\n}.call(this));\n","options":{},"params":[{"type":"ident","name":"label","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"node","asType":{"type":"choice","choices":[{"type":"ident","name":"Statement"},{"type":"ident","name":"Body"}]}}],"names":["label!"],"id":134}],"binaryOperator":[{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.binary(left, \"&&\", right);\n  };\n}.call(this));\n","operators":["and"],"options":{"precedence":0},"id":1},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.binary(left, \"||\", right);\n  };\n}.call(this));\n","operators":["or"],"options":{"precedence":0},"id":2},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.binary(left, \"===\", right);\n  };\n}.call(this));\n","operators":["=="],"options":{"precedence":1,"maximum":1,"type":"boolean"},"id":5},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"MacroAccess\",\n      644,\n      666,\n      3,\n      21,\n      {\n        op: \"not\",\n        node: __node(\n          \"MacroAccess\",\n          650,\n          665,\n          5,\n          21,\n          {\n            left: __wrap(left, 10),\n            inverted: false,\n            op: \"==\",\n            right: __wrap(right, 10)\n          },\n          \"expression\",\n          false\n        )\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["!="],"options":{"precedence":1,"maximum":1,"type":"boolean"},"id":6},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.binary(left, \"==\", right);\n  };\n}.call(this));\n","operators":["~="],"options":{"precedence":1,"maximum":1,"type":"boolean"},"id":7},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"MacroAccess\",\n      850,\n      872,\n      3,\n      27,\n      {\n        op: \"not\",\n        node: __node(\n          \"MacroAccess\",\n          856,\n          871,\n          7,\n          27,\n          {\n            left: __wrap(left, 12),\n            inverted: false,\n            op: \"~=\",\n            right: __wrap(right, 12)\n          },\n          \"expression\",\n          false\n        )\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["!~="],"options":{"precedence":1,"maximum":1,"type":"boolean"},"id":8},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.binary(left, op === \"~<\" && \"<\" || \"<=\", right);\n  };\n}.call(this));\n","operators":["~<","~<="],"options":{"precedence":1,"maximum":1,"type":"boolean"},"id":9},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return op === \"~>\" && __node(\n      \"MacroAccess\",\n      1175,\n      1198,\n      3,\n      35,\n      {\n        op: \"not\",\n        node: __node(\n          \"MacroAccess\",\n          1181,\n          1197,\n          9,\n          35,\n          {\n            left: __wrap(left, 14),\n            inverted: false,\n            op: \"~<=\",\n            right: __wrap(right, 14)\n          },\n          \"expression\",\n          false\n        )\n      },\n      \"expression\",\n      false\n    ) || __node(\n      \"MacroAccess\",\n      1207,\n      1229,\n      3,\n      35,\n      {\n        op: \"not\",\n        node: __node(\n          \"MacroAccess\",\n          1213,\n          1228,\n          9,\n          35,\n          {\n            left: __wrap(left, 14),\n            inverted: false,\n            op: \"~<\",\n            right: __wrap(right, 14)\n          },\n          \"expression\",\n          false\n        )\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["~>","~>="],"options":{"precedence":1,"maximum":1,"type":"boolean"},"id":10},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.hasType(left, \"numeric\") && this.hasType(right, \"numeric\")) {\n      left = this.binary(this[\"const\"](\"\"), \"+\", left);\n    }\n    return this.binary(left, \"+\", right);\n  };\n}.call(this));\n","operators":["~&"],"options":{"precedence":4,"type":"string"},"id":20},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (op === \"~\\\\\") {\n      return __node(\n        \"Call\",\n        7884,\n        7923,\n        __node(\n          \"Access\",\n          7884,\n          7923,\n          __node(\"Ident\", 7884, 7889, \"Math\"),\n          __node(\"Const\", 7890, 7895, \"floor\")\n        ),\n        [\n          __wrap(\n            this.binary(left, \"/\", right),\n            55\n          )\n        ],\n        false,\n        false\n      );\n    } else if (op === \"~*\") {\n      return this.binary(left, \"*\", right);\n    } else if (op === \"~/\") {\n      return this.binary(left, \"/\", right);\n    } else {\n      return this.binary(left, \"%\", right);\n    }\n  };\n}.call(this));\n","operators":["~*","~/","~%","~\\"],"options":{"precedence":8,"type":"number"},"id":34},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (op === \"~+\") {\n      if (!this.isType(right, \"numeric\")) {\n        return this.binary(left, \"-\", __node(\n          \"MacroAccess\",\n          9114,\n          9125,\n          37,\n          260,\n          {\n            op: \"~-\",\n            node: __wrap(right, 63)\n          },\n          \"expression\",\n          false\n        ));\n      } else {\n        if (!this.isType(left, \"numeric\")) {\n          left = __node(\n            \"MacroAccess\",\n            9192,\n            9202,\n            37,\n            263,\n            {\n              op: \"~+\",\n              node: __wrap(left, 63)\n            },\n            \"expression\",\n            false\n          );\n        }\n        return this.binary(left, \"+\", right);\n      }\n    } else {\n      return this.binary(left, \"-\", right);\n    }\n  };\n}.call(this));\n","operators":["~+","~-"],"options":{"precedence":7,"type":"number"},"id":38},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right, value;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.isConst(right)) {\n      value = this.value(right);\n      if (value === 0.5) {\n        return __node(\n          \"Call\",\n          9441,\n          9457,\n          __node(\n            \"Access\",\n            9441,\n            9457,\n            __node(\"Ident\", 9441, 9446, \"Math\"),\n            __node(\"Const\", 9447, 9451, \"sqrt\")\n          ),\n          [__wrap(left, 64)],\n          false,\n          false\n        );\n      } else if (value === 1) {\n        return __node(\n          \"MacroAccess\",\n          9498,\n          9506,\n          37,\n          274,\n          {\n            op: \"~+\",\n            node: __wrap(left, 64)\n          },\n          \"expression\",\n          false\n        );\n      } else if (value === 2) {\n        return this.maybeCache(left, function (setLeft, left) {\n          return __node(\n            \"MacroAccess\",\n            9592,\n            9611,\n            34,\n            277,\n            {\n              left: __wrap(setLeft, 66),\n              inverted: false,\n              op: \"~*\",\n              right: __wrap(left, 66)\n            },\n            \"expression\",\n            false\n          );\n        });\n      } else if (value === 3) {\n        return this.maybeCache(left, function (setLeft, left) {\n          return __node(\n            \"MacroAccess\",\n            9697,\n            9725,\n            34,\n            280,\n            {\n              left: __node(\n                \"MacroAccess\",\n                9697,\n                9725,\n                34,\n                280,\n                {\n                  left: __wrap(setLeft, 67),\n                  inverted: false,\n                  op: \"~*\",\n                  right: __wrap(left, 67)\n                },\n                \"expression\",\n                false\n              ),\n              inverted: false,\n              op: \"~*\",\n              right: __wrap(left, 67)\n            },\n            \"expression\",\n            false\n          );\n        });\n      }\n    }\n    return __node(\n      \"Call\",\n      9732,\n      9755,\n      __node(\n        \"Access\",\n        9732,\n        9755,\n        __node(\"Ident\", 9732, 9737, \"Math\"),\n        __node(\"Const\", 9738, 9741, \"pow\")\n      ),\n      [\n        __wrap(left, 64),\n        __wrap(right, 64)\n      ],\n      false,\n      false\n    );\n  };\n}.call(this));\n","operators":["~^"],"options":{"precedence":9,"rightToLeft":true,"type":"number"},"id":39},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (op === \"~bitlshift\") {\n      return this.binary(left, \"<<\", right);\n    } else if (op === \"~bitrshift\") {\n      return this.binary(left, \">>\", right);\n    } else {\n      return this.binary(left, \">>>\", right);\n    }\n  };\n}.call(this));\n","operators":["~bitlshift","~bitrshift","~biturshift"],"options":{"precedence":6,"maximum":1,"type":"number"},"id":43},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"MacroAccess\",\n      13839,\n      13857,\n      39,\n      414,\n      {\n        left: __node(\n          \"MacroAccess\",\n          13839,\n          13846,\n          47,\n          414,\n          {\n            op: \"+\",\n            node: __wrap(left, 93)\n          },\n          \"expression\",\n          false\n        ),\n        inverted: false,\n        op: \"~^\",\n        right: __node(\n          \"MacroAccess\",\n          13849,\n          13857,\n          47,\n          414,\n          {\n            op: \"+\",\n            node: __wrap(right, 93)\n          },\n          \"expression\",\n          false\n        )\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["^"],"options":{"precedence":9,"rightToLeft":true,"type":"number"},"id":49},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (op === \"*\") {\n      return __node(\n        \"MacroAccess\",\n        14080,\n        14098,\n        34,\n        422,\n        {\n          left: __node(\n            \"MacroAccess\",\n            14080,\n            14087,\n            47,\n            422,\n            {\n              op: \"+\",\n              node: __wrap(left, 96)\n            },\n            \"expression\",\n            false\n          ),\n          inverted: false,\n          op: \"~*\",\n          right: __node(\n            \"MacroAccess\",\n            14090,\n            14098,\n            47,\n            422,\n            {\n              op: \"+\",\n              node: __wrap(right, 96)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    } else if (op === \"/\") {\n      return __node(\n        \"MacroAccess\",\n        14127,\n        14145,\n        34,\n        424,\n        {\n          left: __node(\n            \"MacroAccess\",\n            14127,\n            14134,\n            47,\n            424,\n            {\n              op: \"+\",\n              node: __wrap(left, 96)\n            },\n            \"expression\",\n            false\n          ),\n          inverted: false,\n          op: \"~/\",\n          right: __node(\n            \"MacroAccess\",\n            14137,\n            14145,\n            47,\n            424,\n            {\n              op: \"+\",\n              node: __wrap(right, 96)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    } else if (op === \"%\") {\n      return __node(\n        \"MacroAccess\",\n        14174,\n        14192,\n        34,\n        426,\n        {\n          left: __node(\n            \"MacroAccess\",\n            14174,\n            14181,\n            47,\n            426,\n            {\n              op: \"+\",\n              node: __wrap(left, 96)\n            },\n            \"expression\",\n            false\n          ),\n          inverted: false,\n          op: \"~%\",\n          right: __node(\n            \"MacroAccess\",\n            14184,\n            14192,\n            47,\n            426,\n            {\n              op: \"+\",\n              node: __wrap(right, 96)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    } else {\n      return __node(\n        \"MacroAccess\",\n        14208,\n        14226,\n        34,\n        428,\n        {\n          left: __node(\n            \"MacroAccess\",\n            14208,\n            14215,\n            47,\n            428,\n            {\n              op: \"+\",\n              node: __wrap(left, 96)\n            },\n            \"expression\",\n            false\n          ),\n          inverted: false,\n          op: \"~\\\\\",\n          right: __node(\n            \"MacroAccess\",\n            14218,\n            14226,\n            47,\n            428,\n            {\n              op: \"+\",\n              node: __wrap(right, 96)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    }\n  };\n}.call(this));\n","operators":["*","/","%","\\"],"options":{"precedence":8,"type":"number"},"id":51},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (op === \"+\") {\n      return __node(\n        \"MacroAccess\",\n        14391,\n        14409,\n        38,\n        435,\n        {\n          left: __node(\n            \"MacroAccess\",\n            14391,\n            14398,\n            47,\n            435,\n            {\n              op: \"+\",\n              node: __wrap(left, 98)\n            },\n            \"expression\",\n            false\n          ),\n          inverted: false,\n          op: \"~+\",\n          right: __node(\n            \"MacroAccess\",\n            14401,\n            14409,\n            47,\n            435,\n            {\n              op: \"+\",\n              node: __wrap(right, 98)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    } else {\n      return __node(\n        \"MacroAccess\",\n        14425,\n        14443,\n        38,\n        437,\n        {\n          left: __node(\n            \"MacroAccess\",\n            14425,\n            14432,\n            47,\n            437,\n            {\n              op: \"+\",\n              node: __wrap(left, 98)\n            },\n            \"expression\",\n            false\n          ),\n          inverted: false,\n          op: \"~-\",\n          right: __node(\n            \"MacroAccess\",\n            14435,\n            14443,\n            47,\n            437,\n            {\n              op: \"+\",\n              node: __wrap(right, 98)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    }\n  };\n}.call(this));\n","operators":["+","-"],"options":{"precedence":7,"type":"number"},"id":53},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (op === \"bitlshift\") {\n      return __node(\n        \"MacroAccess\",\n        14578,\n        14604,\n        43,\n        441,\n        {\n          left: __node(\n            \"MacroAccess\",\n            14578,\n            14585,\n            47,\n            441,\n            {\n              op: \"+\",\n              node: __wrap(left, 99)\n            },\n            \"expression\",\n            false\n          ),\n          inverted: false,\n          op: \"~bitlshift\",\n          right: __node(\n            \"MacroAccess\",\n            14596,\n            14604,\n            47,\n            441,\n            {\n              op: \"+\",\n              node: __wrap(right, 99)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    } else if (op === \"bitrshift\") {\n      return __node(\n        \"MacroAccess\",\n        14641,\n        14667,\n        43,\n        443,\n        {\n          left: __node(\n            \"MacroAccess\",\n            14641,\n            14648,\n            47,\n            443,\n            {\n              op: \"+\",\n              node: __wrap(left, 99)\n            },\n            \"expression\",\n            false\n          ),\n          inverted: false,\n          op: \"~bitrshift\",\n          right: __node(\n            \"MacroAccess\",\n            14659,\n            14667,\n            47,\n            443,\n            {\n              op: \"+\",\n              node: __wrap(right, 99)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    } else {\n      return __node(\n        \"MacroAccess\",\n        14683,\n        14710,\n        43,\n        445,\n        {\n          left: __node(\n            \"MacroAccess\",\n            14683,\n            14690,\n            47,\n            445,\n            {\n              op: \"+\",\n              node: __wrap(left, 99)\n            },\n            \"expression\",\n            false\n          ),\n          inverted: false,\n          op: \"~biturshift\",\n          right: __node(\n            \"MacroAccess\",\n            14702,\n            14710,\n            47,\n            445,\n            {\n              op: \"+\",\n              node: __wrap(right, 99)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    }\n  };\n}.call(this));\n","operators":["bitlshift","bitrshift","biturshift"],"options":{"precedence":6,"maximum":1,"type":"number"},"id":54},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.isType(left, \"number\")) {\n      if (this.hasType(right, \"number\")) {\n        left = __node(\n          \"MacroAccess\",\n          15002,\n          15014,\n          20,\n          454,\n          {\n            left: __node(\"Const\", 15003, 15005, \"\"),\n            inverted: false,\n            op: \"~&\",\n            right: __wrap(left, 102)\n          },\n          \"expression\",\n          false\n        );\n      }\n    } else if (!this.isType(left, \"string\")) {\n      left = !this.hasType(left, \"number\")\n        ? __node(\n          \"Call\",\n          15105,\n          15117,\n          __node(\"Ident\", 15105, 15111, \"__str\"),\n          [__wrap(left, 102)],\n          false,\n          false\n        )\n        : __node(\n          \"Call\",\n          15137,\n          15152,\n          __node(\"Ident\", 15137, 15146, \"__strnum\"),\n          [__wrap(left, 102)],\n          false,\n          false\n        );\n    }\n    if (!this.isType(right, \"stringOrNumber\")) {\n      right = !this.hasType(right, \"number\")\n        ? __node(\n          \"Call\",\n          15251,\n          15264,\n          __node(\"Ident\", 15251, 15257, \"__str\"),\n          [__wrap(right, 102)],\n          false,\n          false\n        )\n        : __node(\n          \"Call\",\n          15284,\n          15300,\n          __node(\"Ident\", 15284, 15293, \"__strnum\"),\n          [__wrap(right, 102)],\n          false,\n          false\n        );\n    }\n    return __node(\n      \"MacroAccess\",\n      15307,\n      15323,\n      20,\n      465,\n      {\n        left: __wrap(left, 102),\n        inverted: false,\n        op: \"~&\",\n        right: __wrap(right, 102)\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["&"],"options":{"precedence":4,"type":"string","label":"stringConcat"},"id":56},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var elements, f, left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.isArray(right)) {\n      elements = this.elements(right);\n      if (elements.length === 0) {\n        if (this.isComplex(left)) {\n          return __node(\n            \"Block\",\n            15742,\n            15773,\n            [\n              __wrap(left, 105),\n              __node(\"Const\", 15768, 15773, false)\n            ],\n            null\n          );\n        } else {\n          return __node(\"Const\", 15797, 15803, false);\n        }\n      } else if (elements.length === 1) {\n        return __node(\n          \"MacroAccess\",\n          15847,\n          15871,\n          5,\n          483,\n          {\n            left: __wrap(left, 105),\n            inverted: false,\n            op: \"==\",\n            right: __wrap(elements[0], 105)\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        f = function (i, current, left) {\n          if (i < elements.length) {\n            return f(\n              +i + 1,\n              __node(\n                \"MacroAccess\",\n                15967,\n                16003,\n                2,\n                487,\n                {\n                  left: __wrap(current, 107),\n                  inverted: false,\n                  op: \"or\",\n                  right: __node(\n                    \"MacroAccess\",\n                    15979,\n                    16003,\n                    5,\n                    487,\n                    {\n                      left: __wrap(left, 107),\n                      inverted: false,\n                      op: \"==\",\n                      right: __wrap(elements[i], 107)\n                    },\n                    \"expression\",\n                    false\n                  )\n                },\n                \"expression\",\n                false\n              ),\n              left\n            );\n          } else {\n            return current;\n          }\n        };\n        return this.maybeCache(left, function (setLeft, left) {\n          return f(\n            1,\n            __node(\n              \"MacroAccess\",\n              16102,\n              16130,\n              5,\n              491,\n              {\n                left: __wrap(setLeft, 108),\n                inverted: false,\n                op: \"==\",\n                right: __wrap(elements[0], 108)\n              },\n              \"expression\",\n              false\n            ),\n            left\n          );\n        });\n      }\n    } else {\n      return __node(\n        \"Call\",\n        16153,\n        16173,\n        __node(\"Ident\", 16153, 16158, \"__in\"),\n        [\n          __wrap(left, 105),\n          __wrap(right, 105)\n        ],\n        false,\n        false\n      );\n    }\n  };\n}.call(this));\n","operators":["in"],"options":{"precedence":3,"maximum":1,"invertible":true,"type":"boolean"},"id":58},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.binary(right, \"in\", left);\n  };\n}.call(this));\n","operators":["haskey"],"options":{"precedence":3,"maximum":1,"invertible":true,"type":"boolean"},"id":59},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"Call\",\n      16477,\n      16500,\n      __node(\"Ident\", 16477, 16484, \"__owns\"),\n      [\n        __wrap(left, 110),\n        __wrap(right, 110)\n      ],\n      false,\n      true\n    );\n  };\n}.call(this));\n","operators":["ownskey"],"options":{"precedence":3,"maximum":1,"invertible":true,"type":"boolean","label":"ownership"},"id":60},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.binary(left, \"instanceof\", right);\n  };\n}.call(this));\n","operators":["instanceof"],"options":{"precedence":3,"maximum":1,"invertible":true,"type":"boolean"},"id":61},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"Call\",\n      17123,\n      17144,\n      __node(\"Ident\", 17123, 17129, \"__cmp\"),\n      [\n        __wrap(left, 114),\n        __wrap(right, 114)\n      ],\n      false,\n      false\n    );\n  };\n}.call(this));\n","operators":["<=>"],"options":{"precedence":2,"maximum":1,"type":"number"},"id":62},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"MacroAccess\",\n      17243,\n      17263,\n      5,\n      524,\n      {\n        left: __node(\n          \"MacroAccess\",\n          17243,\n          17258,\n          51,\n          524,\n          {\n            left: __wrap(left, 115),\n            inverted: false,\n            op: \"%\",\n            right: __wrap(right, 115)\n          },\n          \"expression\",\n          false\n        ),\n        inverted: false,\n        op: \"==\",\n        right: __node(\"Const\", 17262, 17263, 0)\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["%%"],"options":{"precedence":1,"maximum":1,"invertible":true,"type":"boolean"},"id":63},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"MacroAccess\",\n      17363,\n      17384,\n      5,\n      527,\n      {\n        left: __node(\n          \"MacroAccess\",\n          17363,\n          17379,\n          34,\n          527,\n          {\n            left: __wrap(left, 116),\n            inverted: false,\n            op: \"~%\",\n            right: __wrap(right, 116)\n          },\n          \"expression\",\n          false\n        ),\n        inverted: false,\n        op: \"==\",\n        right: __node(\"Const\", 17383, 17384, 0)\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["~%%"],"options":{"precedence":1,"maximum":1,"invertible":true,"type":"boolean"},"id":64},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.isType(left, \"number\")) {\n      if (this.isType(right, \"number\")) {\n        if (op === \"<\") {\n          return __node(\n            \"MacroAccess\",\n            18516,\n            18532,\n            9,\n            565,\n            {\n              left: __wrap(left, 123),\n              inverted: false,\n              op: \"~<\",\n              right: __wrap(right, 123)\n            },\n            \"expression\",\n            false\n          );\n        } else {\n          return __node(\n            \"MacroAccess\",\n            18556,\n            18573,\n            9,\n            567,\n            {\n              left: __wrap(left, 123),\n              inverted: false,\n              op: \"~<=\",\n              right: __wrap(right, 123)\n            },\n            \"expression\",\n            false\n          );\n        }\n      } else if (op === \"<\") {\n        return __node(\n          \"MacroAccess\",\n          18614,\n          18637,\n          9,\n          570,\n          {\n            left: __wrap(left, 123),\n            inverted: false,\n            op: \"~<\",\n            right: __node(\n              \"Call\",\n              18623,\n              18637,\n              __node(\"Ident\", 18623, 18629, \"__num\"),\n              [__wrap(right, 123)],\n              false,\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        return __node(\n          \"MacroAccess\",\n          18661,\n          18685,\n          9,\n          572,\n          {\n            left: __wrap(left, 123),\n            inverted: false,\n            op: \"~<=\",\n            right: __node(\n              \"Call\",\n              18671,\n              18685,\n              __node(\"Ident\", 18671, 18677, \"__num\"),\n              [__wrap(right, 123)],\n              false,\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      }\n    } else if (this.isType(left, \"string\")) {\n      if (this.isType(right, \"string\")) {\n        if (op === \"<\") {\n          return __node(\n            \"MacroAccess\",\n            18781,\n            18797,\n            9,\n            576,\n            {\n              left: __wrap(left, 123),\n              inverted: false,\n              op: \"~<\",\n              right: __wrap(right, 123)\n            },\n            \"expression\",\n            false\n          );\n        } else {\n          return __node(\n            \"MacroAccess\",\n            18821,\n            18838,\n            9,\n            578,\n            {\n              left: __wrap(left, 123),\n              inverted: false,\n              op: \"~<=\",\n              right: __wrap(right, 123)\n            },\n            \"expression\",\n            false\n          );\n        }\n      } else if (op === \"<\") {\n        return __node(\n          \"MacroAccess\",\n          18879,\n          18902,\n          9,\n          581,\n          {\n            left: __wrap(left, 123),\n            inverted: false,\n            op: \"~<\",\n            right: __node(\n              \"Call\",\n              18888,\n              18902,\n              __node(\"Ident\", 18888, 18894, \"__str\"),\n              [__wrap(right, 123)],\n              false,\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        return __node(\n          \"MacroAccess\",\n          18926,\n          18950,\n          9,\n          583,\n          {\n            left: __wrap(left, 123),\n            inverted: false,\n            op: \"~<=\",\n            right: __node(\n              \"Call\",\n              18936,\n              18950,\n              __node(\"Ident\", 18936, 18942, \"__str\"),\n              [__wrap(right, 123)],\n              false,\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      }\n    } else if (this.isType(right, \"number\")) {\n      if (op === \"<\") {\n        return __node(\n          \"MacroAccess\",\n          19012,\n          19035,\n          9,\n          586,\n          {\n            left: __node(\n              \"Call\",\n              19012,\n              19025,\n              __node(\"Ident\", 19012, 19018, \"__num\"),\n              [__wrap(left, 123)],\n              false,\n              false\n            ),\n            inverted: false,\n            op: \"~<\",\n            right: __wrap(right, 123)\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        return __node(\n          \"MacroAccess\",\n          19055,\n          19079,\n          9,\n          588,\n          {\n            left: __node(\n              \"Call\",\n              19055,\n              19068,\n              __node(\"Ident\", 19055, 19061, \"__num\"),\n              [__wrap(left, 123)],\n              false,\n              false\n            ),\n            inverted: false,\n            op: \"~<=\",\n            right: __wrap(right, 123)\n          },\n          \"expression\",\n          false\n        );\n      }\n    } else if (this.isType(right, \"string\")) {\n      if (op === \"<\") {\n        return __node(\n          \"MacroAccess\",\n          19141,\n          19164,\n          9,\n          591,\n          {\n            left: __node(\n              \"Call\",\n              19141,\n              19154,\n              __node(\"Ident\", 19141, 19147, \"__str\"),\n              [__wrap(left, 123)],\n              false,\n              false\n            ),\n            inverted: false,\n            op: \"~<\",\n            right: __wrap(right, 123)\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        return __node(\n          \"MacroAccess\",\n          19184,\n          19208,\n          9,\n          593,\n          {\n            left: __node(\n              \"Call\",\n              19184,\n              19197,\n              __node(\"Ident\", 19184, 19190, \"__str\"),\n              [__wrap(left, 123)],\n              false,\n              false\n            ),\n            inverted: false,\n            op: \"~<=\",\n            right: __wrap(right, 123)\n          },\n          \"expression\",\n          false\n        );\n      }\n    } else if (op === \"<\") {\n      return __node(\n        \"Call\",\n        19237,\n        19257,\n        __node(\"Ident\", 19237, 19242, \"__lt\"),\n        [\n          __wrap(left, 123),\n          __wrap(right, 123)\n        ],\n        false,\n        false\n      );\n    } else {\n      return __node(\n        \"Call\",\n        19273,\n        19294,\n        __node(\"Ident\", 19273, 19279, \"__lte\"),\n        [\n          __wrap(left, 123),\n          __wrap(right, 123)\n        ],\n        false,\n        false\n      );\n    }\n  };\n}.call(this));\n","operators":["<","<="],"options":{"precedence":1,"maximum":1,"type":"boolean"},"id":65},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (op === \">\") {\n      return __node(\n        \"MacroAccess\",\n        19395,\n        19417,\n        3,\n        601,\n        {\n          op: \"not\",\n          node: __node(\n            \"MacroAccess\",\n            19401,\n            19416,\n            65,\n            601,\n            {\n              left: __wrap(left, 124),\n              inverted: false,\n              op: \"<=\",\n              right: __wrap(right, 124)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    } else {\n      return __node(\n        \"MacroAccess\",\n        19433,\n        19454,\n        3,\n        603,\n        {\n          op: \"not\",\n          node: __node(\n            \"MacroAccess\",\n            19439,\n            19453,\n            65,\n            603,\n            {\n              left: __wrap(left, 124),\n              inverted: false,\n              op: \"<\",\n              right: __wrap(right, 124)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    }\n  };\n}.call(this));\n","operators":[">",">="],"options":{"precedence":1,"maximum":1,"type":"boolean"},"id":66},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCache(left, function (setLeft, left) {\n      return _this.maybeCache(right, function (setRight, right) {\n        return __node(\n          \"MacroAccess\",\n          19598,\n          19648,\n          18,\n          608,\n          {\n            macroName: \"if\",\n            macroData: {\n              test: __node(\n                \"MacroAccess\",\n                19601,\n                19625,\n                9,\n                608,\n                {\n                  left: __wrap(setLeft, 127),\n                  inverted: false,\n                  op: \"~<\",\n                  right: __wrap(setRight, 127)\n                },\n                \"expression\",\n                false\n              ),\n              body: __wrap(left, 127),\n              elseIfs: [],\n              elseBody: __wrap(right, 127)\n            }\n          },\n          \"expression\",\n          false\n        );\n      });\n    });\n  };\n}.call(this));\n","operators":["~min"],"options":{"precedence":5},"id":67},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCache(left, function (setLeft, left) {\n      return _this.maybeCache(right, function (setRight, right) {\n        return __node(\n          \"MacroAccess\",\n          19792,\n          19842,\n          18,\n          613,\n          {\n            macroName: \"if\",\n            macroData: {\n              test: __node(\n                \"MacroAccess\",\n                19795,\n                19819,\n                10,\n                613,\n                {\n                  left: __wrap(setLeft, 130),\n                  inverted: false,\n                  op: \"~>\",\n                  right: __wrap(setRight, 130)\n                },\n                \"expression\",\n                false\n              ),\n              body: __wrap(left, 130),\n              elseIfs: [],\n              elseBody: __wrap(right, 130)\n            }\n          },\n          \"expression\",\n          false\n        );\n      });\n    });\n  };\n}.call(this));\n","operators":["~max"],"options":{"precedence":5},"id":68},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCache(left, function (setLeft, left) {\n      return _this.maybeCache(right, function (setRight, right) {\n        return __node(\n          \"MacroAccess\",\n          19985,\n          20034,\n          18,\n          618,\n          {\n            macroName: \"if\",\n            macroData: {\n              test: __node(\n                \"MacroAccess\",\n                19988,\n                20011,\n                65,\n                618,\n                {\n                  left: __wrap(setLeft, 133),\n                  inverted: false,\n                  op: \"<\",\n                  right: __wrap(setRight, 133)\n                },\n                \"expression\",\n                false\n              ),\n              body: __wrap(left, 133),\n              elseIfs: [],\n              elseBody: __wrap(right, 133)\n            }\n          },\n          \"expression\",\n          false\n        );\n      });\n    });\n  };\n}.call(this));\n","operators":["min"],"options":{"precedence":5},"id":69},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCache(left, function (setLeft, left) {\n      return _this.maybeCache(right, function (setRight, right) {\n        return __node(\n          \"MacroAccess\",\n          20177,\n          20226,\n          18,\n          623,\n          {\n            macroName: \"if\",\n            macroData: {\n              test: __node(\n                \"MacroAccess\",\n                20180,\n                20203,\n                66,\n                623,\n                {\n                  left: __wrap(setLeft, 136),\n                  inverted: false,\n                  op: \">\",\n                  right: __wrap(setRight, 136)\n                },\n                \"expression\",\n                false\n              ),\n              body: __wrap(left, 136),\n              elseIfs: [],\n              elseBody: __wrap(right, 136)\n            }\n          },\n          \"expression\",\n          false\n        );\n      });\n    });\n  };\n}.call(this));\n","operators":["max"],"options":{"precedence":5},"id":70},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"Call\",\n      20280,\n      20301,\n      __node(\"Ident\", 20280, 20286, \"__xor\"),\n      [\n        __wrap(left, 137),\n        __wrap(right, 137)\n      ],\n      false,\n      false\n    );\n  };\n}.call(this));\n","operators":["xor"],"options":{"precedence":0},"id":71},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCache(left, function (setLeft, left) {\n      return __node(\n        \"MacroAccess\",\n        20395,\n        20432,\n        18,\n        630,\n        {\n          macroName: \"if\",\n          macroData: {\n            test: __node(\n              \"MacroAccess\",\n              20398,\n              20409,\n              21,\n              630,\n              {\n                op: \"?\",\n                node: __wrap(setLeft, 139)\n              },\n              \"expression\",\n              false\n            ),\n            body: __wrap(left, 139),\n            elseIfs: [],\n            elseBody: __wrap(right, 139)\n          }\n        },\n        \"expression\",\n        false\n      );\n    });\n  };\n}.call(this));\n","operators":["?"],"options":{"precedence":0},"id":72},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.binary(left, \"&\", right);\n  };\n}.call(this));\n","operators":["~bitand"],"options":{"precedence":0,"type":"number"},"id":79},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.binary(left, \"|\", right);\n  };\n}.call(this));\n","operators":["~bitor"],"options":{"precedence":0,"type":"number"},"id":80},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.binary(left, \"^\", right);\n  };\n}.call(this));\n","operators":["~bitxor"],"options":{"precedence":0,"type":"number"},"id":81},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"MacroAccess\",\n      22555,\n      22578,\n      79,\n      706,\n      {\n        left: __node(\n          \"MacroAccess\",\n          22555,\n          22562,\n          47,\n          706,\n          {\n            op: \"+\",\n            node: __wrap(left, 162)\n          },\n          \"expression\",\n          false\n        ),\n        inverted: false,\n        op: \"~bitand\",\n        right: __node(\n          \"MacroAccess\",\n          22570,\n          22578,\n          47,\n          706,\n          {\n            op: \"+\",\n            node: __wrap(right, 162)\n          },\n          \"expression\",\n          false\n        )\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["bitand"],"options":{"precedence":0,"type":"number"},"id":83},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"MacroAccess\",\n      22649,\n      22671,\n      80,\n      709,\n      {\n        left: __node(\n          \"MacroAccess\",\n          22649,\n          22656,\n          47,\n          709,\n          {\n            op: \"+\",\n            node: __wrap(left, 163)\n          },\n          \"expression\",\n          false\n        ),\n        inverted: false,\n        op: \"~bitor\",\n        right: __node(\n          \"MacroAccess\",\n          22663,\n          22671,\n          47,\n          709,\n          {\n            op: \"+\",\n            node: __wrap(right, 163)\n          },\n          \"expression\",\n          false\n        )\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["bitor"],"options":{"precedence":0,"type":"number"},"id":84},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"MacroAccess\",\n      22743,\n      22766,\n      81,\n      712,\n      {\n        left: __node(\n          \"MacroAccess\",\n          22743,\n          22750,\n          47,\n          712,\n          {\n            op: \"+\",\n            node: __wrap(left, 164)\n          },\n          \"expression\",\n          false\n        ),\n        inverted: false,\n        op: \"~bitxor\",\n        right: __node(\n          \"MacroAccess\",\n          22758,\n          22766,\n          47,\n          712,\n          {\n            op: \"+\",\n            node: __wrap(right, 164)\n          },\n          \"expression\",\n          false\n        )\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["bitxor"],"options":{"precedence":0,"type":"number"},"id":85},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"Call\",\n      31314,\n      31346,\n      __node(\"Ident\", 31314, 31322, \"__range\"),\n      [\n        __wrap(left, 215),\n        __wrap(right, 215),\n        __node(\"Const\", 31338, 31339, 1),\n        __node(\"Const\", 31340, 31345, true)\n      ],\n      false,\n      false\n    );\n  };\n}.call(this));\n","operators":["to"],"options":{"maximum":1,"precedence":2,"type":"array"},"id":99},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"Call\",\n      31426,\n      31459,\n      __node(\"Ident\", 31426, 31434, \"__range\"),\n      [\n        __wrap(left, 216),\n        __wrap(right, 216),\n        __node(\"Const\", 31450, 31451, 1),\n        __node(\"Const\", 31452, 31458, false)\n      ],\n      false,\n      false\n    );\n  };\n}.call(this));\n","operators":["til"],"options":{"maximum":1,"precedence":2,"type":"array"},"id":100},{"code":"return (function () {\n  \"use strict\";\n  var __num, __typeof;\n  __num = function (num) {\n    if (typeof num !== \"number\") {\n      throw TypeError(\"Expected a number, got \" + __typeof(num));\n    } else {\n      return num;\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var callArgs, left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (!this.hasType(right, \"number\")) {\n      throw Error(\"Must provide a number to the 'by' operator\");\n    }\n    if (this.isConst(right) && this.value(right) === 0) {\n      throw Error(\"'by' step must be non-zero\");\n    }\n    if (this.isCall(left) && this.isIdent(this.callFunc(left)) && this.name(this.callFunc(left)) === \"__range\" && !this.callIsApply(left)) {\n      callArgs = this.callArgs(left);\n      return __node(\n        \"Call\",\n        32818,\n        32885,\n        __node(\"Ident\", 32818, 32826, \"__range\"),\n        [\n          __wrap(callArgs[0], 222),\n          __wrap(callArgs[1], 222),\n          __wrap(right, 222),\n          __wrap(callArgs[3], 222)\n        ],\n        false,\n        false\n      );\n    } else {\n      if (this.isConst(right) && __num(this.value(right)) % 1 !== 0) {\n        throw Error(\"'by' step must be an integer\");\n      }\n      return __node(\n        \"Call\",\n        33001,\n        33023,\n        __node(\"Ident\", 33001, 33008, \"__step\"),\n        [\n          __wrap(left, 222),\n          __wrap(right, 222)\n        ],\n        false,\n        false\n      );\n    }\n  };\n}.call(this));\n","operators":["by"],"options":{"maximum":1,"precedence":1,"type":"array"},"id":101},{"code":"return (function () {\n  \"use strict\";\n  var __lt, __num, __typeof;\n  __lt = function (x, y) {\n    var type;\n    type = typeof x;\n    if (type !== \"number\" && type !== \"string\") {\n      throw TypeError(\"Cannot compare a non-number/string: \" + type);\n    } else if (type !== typeof y) {\n      throw TypeError(\"Cannot compare elements of different types: \" + type + \" vs \" + typeof y);\n    } else {\n      return x < y;\n    }\n  };\n  __num = function (num) {\n    if (typeof num !== \"number\") {\n      throw TypeError(\"Expected a number, got \" + __typeof(num));\n    } else {\n      return num;\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var element, elements, f, left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.isArray(right)) {\n      elements = this.elements(right);\n      if (elements.length === 0) {\n        if (this.isComplex(left)) {\n          return __node(\n            \"Block\",\n            51413,\n            51444,\n            [\n              __wrap(left, 301),\n              __node(\"Const\", 51439, 51444, false)\n            ],\n            null\n          );\n        } else {\n          return __node(\"Const\", 51468, 51474, false);\n        }\n      } else if (elements.length === 1) {\n        element = elements[0];\n        return __node(\n          \"MacroAccess\",\n          51550,\n          51576,\n          61,\n          1552,\n          {\n            left: __wrap(left, 301),\n            inverted: false,\n            op: \"instanceof\",\n            right: __wrap(element, 301)\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        f = function (i, current, left) {\n          var element;\n          if (__lt(i, elements.length)) {\n            element = elements[i];\n            return f(\n              __num(i) + 1,\n              __node(\n                \"MacroAccess\",\n                51706,\n                51744,\n                2,\n                1557,\n                {\n                  left: __wrap(current, 304),\n                  inverted: false,\n                  op: \"or\",\n                  right: __node(\n                    \"MacroAccess\",\n                    51718,\n                    51744,\n                    61,\n                    1557,\n                    {\n                      left: __wrap(left, 304),\n                      inverted: false,\n                      op: \"instanceof\",\n                      right: __wrap(element, 304)\n                    },\n                    \"expression\",\n                    false\n                  )\n                },\n                \"expression\",\n                false\n              ),\n              left\n            );\n          } else {\n            return current;\n          }\n        };\n        return this.maybeCache(left, function (setLeft, left) {\n          var element;\n          element = elements[0];\n          return f(\n            1,\n            __node(\n              \"MacroAccess\",\n              51877,\n              51907,\n              61,\n              1562,\n              {\n                left: __wrap(setLeft, 306),\n                inverted: false,\n                op: \"instanceof\",\n                right: __wrap(element, 306)\n              },\n              \"expression\",\n              false\n            ),\n            left\n          );\n        });\n      }\n    } else {\n      return __node(\n        \"Call\",\n        51930,\n        51962,\n        __node(\"Ident\", 51930, 51947, \"__instanceofsome\"),\n        [\n          __wrap(left, 301),\n          __wrap(right, 301)\n        ],\n        false,\n        false\n      );\n    }\n  };\n}.call(this));\n","operators":["instanceofsome"],"options":{"precedence":3,"maximum":1,"invertible":true,"type":"boolean"},"id":106},{"code":"return (function () {\n  \"use strict\";\n  var __is, __num, __typeof;\n  __is = typeof Object.is === \"function\" ? Object.is\n    : function (x, y) {\n      if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n      } else {\n        return x !== x && y !== y;\n      }\n    };\n  __num = function (num) {\n    if (typeof num !== \"number\") {\n      throw TypeError(\"Expected a number, got \" + __typeof(num));\n    } else {\n      return num;\n    }\n  };\n  __typeof = (function () {\n    var _toString;\n    _toString = Object.prototype.toString;\n    return function (o) {\n      if (o === void 0) {\n        return \"Undefined\";\n      } else if (o === null) {\n        return \"Null\";\n      } else {\n        return o.constructor && o.constructor.name || _toString.call(o).slice(8, -1);\n      }\n    };\n  }());\n  return function (_p, __wrap, __node) {\n    var _this, left, op, result, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.hasType(left, \"number\") && this.hasType(right, \"number\")) {\n      if (this.isConst(left)) {\n        if (this.isConst(right)) {\n          result = __is(this.value(left), this.value(right));\n          return __wrap(result, 521);\n        } else if (typeof this.value(left) === \"number\" && isNaN(this.value(left))) {\n          return this.maybeCache(right, function (setRight, right) {\n            return __node(\n              \"MacroAccess\",\n              84335,\n              84356,\n              6,\n              2618,\n              {\n                left: __wrap(setRight, 523),\n                inverted: false,\n                op: \"!=\",\n                right: __wrap(right, 523)\n              },\n              \"expression\",\n              false\n            );\n          });\n        } else if (this.value(left) === 0) {\n          return this.maybeCache(right, function (setRight, right) {\n            if (1 / __num(_this.value(left)) < 0) {\n              return __node(\n                \"MacroAccess\",\n                84496,\n                84532,\n                1,\n                2622,\n                {\n                  left: __node(\n                    \"MacroAccess\",\n                    84496,\n                    84512,\n                    5,\n                    2622,\n                    {\n                      left: __wrap(setRight, 524),\n                      inverted: false,\n                      op: \"==\",\n                      right: __node(\"Const\", 84511, 84512, 0)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  inverted: false,\n                  op: \"and\",\n                  right: __node(\n                    \"MacroAccess\",\n                    84516,\n                    84532,\n                    65,\n                    2622,\n                    {\n                      left: __node(\n                        \"MacroAccess\",\n                        84516,\n                        84528,\n                        34,\n                        2622,\n                        {\n                          left: __node(\"Const\", 84517, 84518, 1),\n                          inverted: false,\n                          op: \"~/\",\n                          right: __wrap(right, 524)\n                        },\n                        \"expression\",\n                        false\n                      ),\n                      inverted: false,\n                      op: \"<\",\n                      right: __node(\"Const\", 84531, 84532, 0)\n                    },\n                    \"expression\",\n                    false\n                  )\n                },\n                \"expression\",\n                false\n              );\n            } else {\n              return __node(\n                \"MacroAccess\",\n                84568,\n                84604,\n                1,\n                2624,\n                {\n                  left: __node(\n                    \"MacroAccess\",\n                    84568,\n                    84584,\n                    5,\n                    2624,\n                    {\n                      left: __wrap(setRight, 524),\n                      inverted: false,\n                      op: \"==\",\n                      right: __node(\"Const\", 84583, 84584, 0)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  inverted: false,\n                  op: \"and\",\n                  right: __node(\n                    \"MacroAccess\",\n                    84588,\n                    84604,\n                    66,\n                    2624,\n                    {\n                      left: __node(\n                        \"MacroAccess\",\n                        84588,\n                        84600,\n                        34,\n                        2624,\n                        {\n                          left: __node(\"Const\", 84589, 84590, 1),\n                          inverted: false,\n                          op: \"~/\",\n                          right: __wrap(right, 524)\n                        },\n                        \"expression\",\n                        false\n                      ),\n                      inverted: false,\n                      op: \">\",\n                      right: __node(\"Const\", 84603, 84604, 0)\n                    },\n                    \"expression\",\n                    false\n                  )\n                },\n                \"expression\",\n                false\n              );\n            }\n          });\n        } else {\n          return __node(\n            \"MacroAccess\",\n            84632,\n            84648,\n            5,\n            2626,\n            {\n              left: __wrap(left, 521),\n              inverted: false,\n              op: \"==\",\n              right: __wrap(right, 521)\n            },\n            \"expression\",\n            false\n          );\n        }\n      } else if (this.isConst(right)) {\n        if (typeof this.value(right) === \"number\" && isNaN(this.value(right))) {\n          return this.maybeCache(left, function (setLeft, left) {\n            return __node(\n              \"MacroAccess\",\n              84803,\n              84822,\n              6,\n              2630,\n              {\n                left: __wrap(setLeft, 525),\n                inverted: false,\n                op: \"!=\",\n                right: __wrap(left, 525)\n              },\n              \"expression\",\n              false\n            );\n          });\n        } else if (this.value(right) === 0) {\n          return this.maybeCache(left, function (setLeft, left) {\n            if (1 / __num(_this.value(right)) < 0) {\n              return __node(\n                \"MacroAccess\",\n                84953,\n                84987,\n                1,\n                2634,\n                {\n                  left: __node(\n                    \"MacroAccess\",\n                    84953,\n                    84968,\n                    5,\n                    2634,\n                    {\n                      left: __wrap(setLeft, 526),\n                      inverted: false,\n                      op: \"==\",\n                      right: __node(\"Const\", 84967, 84968, 0)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  inverted: false,\n                  op: \"and\",\n                  right: __node(\n                    \"MacroAccess\",\n                    84972,\n                    84987,\n                    65,\n                    2634,\n                    {\n                      left: __node(\n                        \"MacroAccess\",\n                        84972,\n                        84983,\n                        34,\n                        2634,\n                        {\n                          left: __node(\"Const\", 84973, 84974, 1),\n                          inverted: false,\n                          op: \"~/\",\n                          right: __wrap(left, 526)\n                        },\n                        \"expression\",\n                        false\n                      ),\n                      inverted: false,\n                      op: \"<\",\n                      right: __node(\"Const\", 84986, 84987, 0)\n                    },\n                    \"expression\",\n                    false\n                  )\n                },\n                \"expression\",\n                false\n              );\n            } else {\n              return __node(\n                \"MacroAccess\",\n                85019,\n                85053,\n                1,\n                2636,\n                {\n                  left: __node(\n                    \"MacroAccess\",\n                    85019,\n                    85034,\n                    5,\n                    2636,\n                    {\n                      left: __wrap(setLeft, 526),\n                      inverted: false,\n                      op: \"==\",\n                      right: __node(\"Const\", 85033, 85034, 0)\n                    },\n                    \"expression\",\n                    false\n                  ),\n                  inverted: false,\n                  op: \"and\",\n                  right: __node(\n                    \"MacroAccess\",\n                    85038,\n                    85053,\n                    66,\n                    2636,\n                    {\n                      left: __node(\n                        \"MacroAccess\",\n                        85038,\n                        85049,\n                        34,\n                        2636,\n                        {\n                          left: __node(\"Const\", 85039, 85040, 1),\n                          inverted: false,\n                          op: \"~/\",\n                          right: __wrap(left, 526)\n                        },\n                        \"expression\",\n                        false\n                      ),\n                      inverted: false,\n                      op: \">\",\n                      right: __node(\"Const\", 85052, 85053, 0)\n                    },\n                    \"expression\",\n                    false\n                  )\n                },\n                \"expression\",\n                false\n              );\n            }\n          });\n        } else {\n          return __node(\n            \"MacroAccess\",\n            85077,\n            85093,\n            5,\n            2638,\n            {\n              left: __wrap(left, 521),\n              inverted: false,\n              op: \"==\",\n              right: __wrap(right, 521)\n            },\n            \"expression\",\n            false\n          );\n        }\n      } else {\n        return __node(\n          \"Call\",\n          85113,\n          85132,\n          __node(\"Ident\", 85113, 85118, \"__is\"),\n          [\n            __wrap(left, 521),\n            __wrap(right, 521)\n          ],\n          false,\n          false\n        );\n      }\n    } else {\n      return __node(\n        \"MacroAccess\",\n        85148,\n        85164,\n        5,\n        2642,\n        {\n          left: __wrap(left, 521),\n          inverted: false,\n          op: \"==\",\n          right: __wrap(right, 521)\n        },\n        \"expression\",\n        false\n      );\n    }\n  };\n}.call(this));\n","operators":["is"],"options":{"precedence":1,"maximum":1,"type":"boolean"},"id":132},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return __node(\n      \"MacroAccess\",\n      85247,\n      85269,\n      3,\n      2645,\n      {\n        op: \"not\",\n        node: __node(\n          \"MacroAccess\",\n          85253,\n          85268,\n          132,\n          2645,\n          {\n            left: __wrap(left, 527),\n            inverted: false,\n            op: \"is\",\n            right: __wrap(right, 527)\n          },\n          \"expression\",\n          false\n        )\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["isnt"],"options":{"precedence":1,"maximum":1,"type":"boolean"},"id":133}],"unaryOperator":[{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, node, op;\n    _this = this;\n    op = _p.op;\n    node = _p.node;\n    return this.mutateLast(\n      node || this.noop(),\n      function (n) {\n        return _this.unary(\"!\", n);\n      },\n      true\n    );\n  };\n}.call(this));\n","operators":["not"],"options":{"type":"boolean"},"id":3},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, node, op;\n    _this = this;\n    op = _p.op;\n    node = _p.node;\n    return this.mutateLast(\n      node || this.noop(),\n      function (n) {\n        return _this.unary(\"typeof\", n);\n      },\n      true\n    );\n  };\n}.call(this));\n","operators":["typeof"],"options":{"type":"string"},"id":4},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, node, op;\n    _this = this;\n    op = _p.op;\n    node = _p.node;\n    return this.mutateLast(\n      node || this.noop(),\n      function (n) {\n        return _this[\"throw\"](n);\n      },\n      true\n    );\n  };\n}.call(this));\n","operators":["throw"],"options":{"type":"none"},"id":11},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var node, op;\n    op = _p.op;\n    node = _p.node;\n    return this.unary(\"++post\", node);\n  };\n}.call(this));\n","operators":["postInc!"],"options":{"type":"number"},"id":12},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var node, op;\n    op = _p.op;\n    node = _p.node;\n    return this.unary(\"--post\", node);\n  };\n}.call(this));\n","operators":["postDec!"],"options":{"type":"number"},"id":13},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var node, op;\n    op = _p.op;\n    node = _p.node;\n    if (this.isIdentOrTmp(node) && !this.hasVariable(node)) {\n      return __node(\n        \"MacroAccess\",\n        3301,\n        3346,\n        1,\n        87,\n        {\n          left: __node(\n            \"MacroAccess\",\n            3301,\n            3328,\n            6,\n            87,\n            {\n              left: __node(\n                \"MacroAccess\",\n                3301,\n                3314,\n                4,\n                87,\n                {\n                  op: \"typeof\",\n                  node: __wrap(node, 30)\n                },\n                \"expression\",\n                false\n              ),\n              inverted: false,\n              op: \"!=\",\n              right: __node(\"Const\", 3319, 3328, \"undefined\")\n            },\n            \"expression\",\n            false\n          ),\n          inverted: false,\n          op: \"and\",\n          right: __node(\n            \"MacroAccess\",\n            3332,\n            3346,\n            6,\n            87,\n            {\n              left: __wrap(node, 30),\n              inverted: false,\n              op: \"!=\",\n              right: __node(\"Const\", 3341, 3346, null)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    } else {\n      return __node(\n        \"MacroAccess\",\n        3362,\n        3377,\n        8,\n        89,\n        {\n          left: __wrap(node, 30),\n          inverted: false,\n          op: \"!~=\",\n          right: __node(\"Const\", 3372, 3377, null)\n        },\n        \"expression\",\n        false\n      );\n    }\n  };\n}.call(this));\n","operators":["?"],"options":{"postfix":true,"type":"boolean","label":"existential"},"id":21},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, negate, node, op, value;\n    _this = this;\n    op = _p.op;\n    node = _p.node;\n    if (this.isConst(node)) {\n      value = Number(this.value(node));\n      if (op === \"~-\") {\n        negate = function (x) {\n          return -x;\n        };\n        value = negate(value);\n      }\n      return this[\"const\"](value);\n    } else {\n      return this.mutateLast(\n        node || this.noop(),\n        function (n) {\n          return _this.unary(\n            op === \"~+\" ? \"+\" : \"-\",\n            n\n          );\n        },\n        true\n      );\n    }\n  };\n}.call(this));\n","operators":["~+","~-"],"options":{"type":"number"},"id":37},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, node, op;\n    _this = this;\n    op = _p.op;\n    node = _p.node;\n    if (this.isIdentOrTmp(node) && !this.hasVariable(node)) {\n      return __node(\n        \"MacroAccess\",\n        12690,\n        12758,\n        18,\n        373,\n        {\n          macroName: \"if\",\n          macroData: {\n            test: __node(\n              \"MacroAccess\",\n              12693,\n              12720,\n              5,\n              373,\n              {\n                left: __node(\n                  \"MacroAccess\",\n                  12693,\n                  12706,\n                  4,\n                  373,\n                  {\n                    op: \"typeof\",\n                    node: __wrap(node, 84)\n                  },\n                  \"expression\",\n                  false\n                ),\n                inverted: false,\n                op: \"==\",\n                right: __node(\"Const\", 12711, 12720, \"undefined\")\n              },\n              \"expression\",\n              false\n            ),\n            body: __node(\"Const\", 12726, 12737, \"Undefined\"),\n            elseIfs: [],\n            elseBody: __node(\n              \"Call\",\n              12742,\n              12758,\n              __node(\"Ident\", 12742, 12751, \"__typeof\"),\n              [__wrap(node, 84)],\n              false,\n              false\n            )\n          }\n        },\n        \"expression\",\n        false\n      );\n    } else {\n      return this.mutateLast(\n        node || this.noop(),\n        function (n) {\n          return __node(\n            \"Call\",\n            12814,\n            12827,\n            __node(\"Ident\", 12814, 12823, \"__typeof\"),\n            [__wrap(n, 85)],\n            false,\n            false\n          );\n        },\n        true\n      );\n    }\n  };\n}.call(this));\n","operators":["typeof!"],"options":{"type":"string"},"id":46},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, node, op;\n    _this = this;\n    op = _p.op;\n    node = _p.node;\n    return this.mutateLast(\n      node || this.noop(),\n      function (n) {\n        if (_this.isType(n, \"number\")) {\n          return n;\n        } else {\n          return __node(\n            \"Call\",\n            13580,\n            13590,\n            __node(\"Ident\", 13580, 13586, \"__num\"),\n            [__wrap(n, 91)],\n            false,\n            false\n          );\n        }\n      },\n      true\n    );\n  };\n}.call(this));\n","operators":["+"],"options":{"type":"number"},"id":47},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var node, op;\n    op = _p.op;\n    node = _p.node;\n    if (this.isConst(node) && typeof this.value(node) === \"number\") {\n      return this[\"const\"](-this.value(node));\n    } else {\n      return __node(\n        \"MacroAccess\",\n        13740,\n        13751,\n        37,\n        411,\n        {\n          op: \"~-\",\n          node: __node(\n            \"MacroAccess\",\n            13744,\n            13750,\n            47,\n            411,\n            {\n              op: \"+\",\n              node: __wrap(node, 92)\n            },\n            \"expression\",\n            false\n          )\n        },\n        \"expression\",\n        false\n      );\n    }\n  };\n}.call(this));\n","operators":["-"],"options":{"type":"number"},"id":48},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var node, op;\n    op = _p.op;\n    node = _p.node;\n    return __node(\n      \"MacroAccess\",\n      14292,\n      14304,\n      51,\n      431,\n      {\n        left: __wrap(node, 97),\n        inverted: false,\n        op: \"/\",\n        right: __node(\"Const\", 14301, 14304, 100)\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["%"],"options":{"postfix":true,"type":"number"},"id":52},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, node, op;\n    _this = this;\n    op = _p.op;\n    node = _p.node;\n    return this.mutateLast(\n      node || this.noop(),\n      function (n) {\n        return _this.unary(\"~\", n);\n      },\n      true\n    );\n  };\n}.call(this));\n","operators":["~bitnot"],"options":{"type":"number"},"id":86},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var node, op;\n    op = _p.op;\n    node = _p.node;\n    return __node(\n      \"MacroAccess\",\n      22935,\n      22950,\n      86,\n      718,\n      {\n        op: \"~bitnot\",\n        node: __node(\n          \"MacroAccess\",\n          22943,\n          22950,\n          47,\n          718,\n          {\n            op: \"+\",\n            node: __wrap(node, 167)\n          },\n          \"expression\",\n          false\n        )\n      },\n      \"expression\",\n      false\n    );\n  };\n}.call(this));\n","operators":["bitnot"],"options":{"type":"number"},"id":87},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, node, op;\n    _this = this;\n    op = _p.op;\n    node = _p.node;\n    if (!this.isAccess(node)) {\n      throw Error(\"Can only use delete on an access\");\n    }\n    if (this.position === \"expression\") {\n      return this.maybeCacheAccess(node, function (setNode, node) {\n        var del, tmp;\n        tmp = _this.tmp(\"ref\");\n        del = _this.unary(\"delete\", node);\n        return __node(\n          \"Block\",\n          23234,\n          23288,\n          [\n            __node(\n              \"MacroAccess\",\n              23242,\n              23262,\n              29,\n              728,\n              {\n                macroName: \"let\",\n                macroData: {\n                  declarable: __node(\n                    \"MacroAccess\",\n                    23245,\n                    23250,\n                    28,\n                    728,\n                    __node(\n                      \"MacroAccess\",\n                      23245,\n                      23250,\n                      22,\n                      728,\n                      { ident: __wrap(tmp, 169) },\n                      \"statement\",\n                      false\n                    ),\n                    \"statement\",\n                    false\n                  ),\n                  value: __wrap(setNode, 169)\n                }\n              },\n              \"statement\",\n              false\n            ),\n            __wrap(del, 169),\n            __wrap(tmp, 169)\n          ],\n          null\n        );\n      });\n    } else {\n      return this.unary(\"delete\", node);\n    }\n  };\n}.call(this));\n","operators":["delete"],"options":{"standalone":false},"id":88},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var node, op;\n    op = _p.op;\n    node = _p.node;\n    return this.maybeCache(node, function (setNode, node) {\n      return __node(\n        \"MacroAccess\",\n        23421,\n        23452,\n        18,\n        736,\n        {\n          macroName: \"if\",\n          macroData: {\n            test: __node(\n              \"MacroAccess\",\n              23424,\n              23435,\n              21,\n              736,\n              {\n                op: \"?\",\n                node: __wrap(setNode, 174)\n              },\n              \"expression\",\n              false\n            ),\n            body: __node(\n              \"MacroAccess\",\n              23440,\n              23452,\n              11,\n              736,\n              {\n                op: \"throw\",\n                node: __wrap(node, 174)\n              },\n              \"expression\",\n              false\n            ),\n            elseIfs: []\n          }\n        },\n        \"expression\",\n        false\n      );\n    });\n  };\n}.call(this));\n","operators":["throw?"],"options":{"type":"undefined"},"id":89},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, node, op;\n    _this = this;\n    op = _p.op;\n    node = _p.node;\n    return this.mutateLast(\n      node || this.noop(),\n      function (n) {\n        return __node(\n          \"Call\",\n          26306,\n          26321,\n          __node(\"Ident\", 26306, 26317, \"__isArray\"),\n          [__wrap(n, 190)],\n          false,\n          false\n        );\n      },\n      true\n    );\n  };\n}.call(this));\n","operators":["isArray!"],"options":{"type":"boolean"},"id":93},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, node, op;\n    _this = this;\n    op = _p.op;\n    node = _p.node;\n    return this.mutateLast(\n      node || this.noop(),\n      function (n) {\n        return __node(\n          \"Call\",\n          26511,\n          26527,\n          __node(\"Ident\", 26511, 26523, \"__isObject\"),\n          [__wrap(n, 193)],\n          false,\n          false\n        );\n      },\n      true\n    );\n  };\n}.call(this));\n","operators":["isObject!"],"options":{"type":"boolean"},"id":94},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var node, op;\n    op = _p.op;\n    node = _p.node;\n    return __node(\n      \"Call\",\n      59693,\n      59707,\n      __node(\"Ident\", 59693, 59700, \"__keys\"),\n      [__wrap(node, 348)],\n      false,\n      false\n    );\n  };\n}.call(this));\n","operators":["keys!"],"options":{},"id":112},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var node, op;\n    op = _p.op;\n    node = _p.node;\n    return __node(\n      \"Call\",\n      59849,\n      59866,\n      __node(\"Ident\", 59849, 59859, \"__allkeys\"),\n      [__wrap(node, 351)],\n      false,\n      false\n    );\n  };\n}.call(this));\n","operators":["allkeys!"],"options":{},"id":113}],"defineSyntax":[{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var asType, ident, isMutable;\n    isMutable = _p.isMutable;\n    ident = _p.ident;\n    asType = _p.asType;\n    if (this.isIdent(ident) || this.isTmp(ident)) {\n      return { type: \"ident\", isMutable: isMutable === \"mutable\", ident: ident, asType: asType };\n    } else {\n      return ident;\n    }\n  };\n}.call(this));\n","options":{"name":"DeclarableIdent"},"params":[{"type":"ident","name":"isMutable","asType":{"type":"many","multiplier":"?","inner":{"type":"const","value":"mutable"}}},{"type":"ident","name":"ident","asType":{"type":"ident","name":"Identifier"}},{"type":"ident","name":"asType","asType":{"type":"many","multiplier":"?","inner":{"type":"sequence","items":[{"type":"const","value":"as"},{"type":"this","asType":{"type":"ident","name":"Type"}}]}}}],"id":22},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var head, tail;\n    head = _p.head;\n    tail = _p.tail;\n    return { type: \"array\", elements: [head].concat(tail) };\n  };\n}.call(this));\n","options":{"name":"DeclarableArray"},"params":[{"type":"const","value":"["},{"type":"ident","name":"head","asType":{"type":"choice","choices":[{"type":"ident","name":"Declarable"},{"type":"const","value":""}]}},{"type":"ident","name":"tail","asType":{"type":"many","multiplier":"*","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"choice","choices":[{"type":"ident","name":"Declarable"},{"type":"const","value":""}]}}]}}},{"type":"const","value":"]"}],"id":23},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var value;\n    value = _p.value;\n    value = this.macroExpand1(value);\n    return { key: this.name(value.ident), value: value };\n  };\n}.call(this));\n","options":{"name":"DeclarableObjectSingularPair"},"params":[{"type":"ident","name":"value","asType":{"type":"ident","name":"DeclarableIdent"}}],"id":24},{"options":{"name":"DeclarableObjectDualPair"},"params":[{"type":"this","asType":{"type":"sequence","items":[{"type":"ident","name":"key","asType":{"type":"ident","name":"ObjectKey"}},{"type":"const","value":":"},{"type":"ident","name":"value","asType":{"type":"ident","name":"Declarable"}}]}}],"id":25},{"options":{"name":"DeclarableObjectPair"},"params":[{"type":"this","asType":{"type":"choice","choices":[{"type":"ident","name":"DeclarableObjectDualPair"},{"type":"ident","name":"DeclarableObjectSingularPair"}]}}],"id":26},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var head, tail;\n    head = _p.head;\n    tail = _p.tail;\n    return { type: \"object\", pairs: [head].concat(tail) };\n  };\n}.call(this));\n","options":{"name":"DeclarableObject"},"params":[{"type":"const","value":"{"},{"type":"ident","name":"head","asType":{"type":"ident","name":"DeclarableObjectPair"}},{"type":"ident","name":"tail","asType":{"type":"many","multiplier":"*","inner":{"type":"sequence","items":[{"type":"const","value":","},{"type":"this","asType":{"type":"ident","name":"DeclarableObjectPair"}}]}}},{"type":"const","value":"}"}],"id":27},{"options":{"name":"Declarable"},"params":[{"type":"this","asType":{"type":"choice","choices":[{"type":"ident","name":"DeclarableArray"},{"type":"ident","name":"DeclarableObject"},{"type":"ident","name":"DeclarableIdent"}]}}],"id":28}],"assignOperator":[{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      if (_this.position === \"expression\") {\n        return __node(\n          \"MacroAccess\",\n          7393,\n          7425,\n          1,\n          198,\n          {\n            left: __wrap(setLeft, 52),\n            inverted: false,\n            op: \"and\",\n            right: __node(\n              \"Assign\",\n              7409,\n              7424,\n              __wrap(left, 52),\n              \"=\",\n              __wrap(right, 52)\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        return __node(\n          \"MacroAccess\",\n          7444,\n          7506,\n          19,\n          200,\n          {\n            macroName: \"if\",\n            macroData: {\n              test: __wrap(setLeft, 52),\n              body: __node(\n                \"Assign\",\n                7466,\n                7481,\n                __wrap(left, 52),\n                \"=\",\n                __wrap(right, 52)\n              ),\n              elseIfs: [],\n              elseBody: __wrap(left, 52)\n            }\n          },\n          \"statement\",\n          false\n        );\n      }\n    });\n  };\n}.call(this));\n","operators":["and="],"options":{},"id":32},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      if (_this.position === \"expression\") {\n        return __node(\n          \"MacroAccess\",\n          7624,\n          7655,\n          2,\n          208,\n          {\n            left: __wrap(setLeft, 54),\n            inverted: false,\n            op: \"or\",\n            right: __node(\n              \"Assign\",\n              7639,\n              7654,\n              __wrap(left, 54),\n              \"=\",\n              __wrap(right, 54)\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        return __node(\n          \"MacroAccess\",\n          7674,\n          7740,\n          19,\n          210,\n          {\n            macroName: \"if\",\n            macroData: {\n              test: __node(\n                \"MacroAccess\",\n                7677,\n                7691,\n                3,\n                210,\n                {\n                  op: \"not\",\n                  node: __wrap(setLeft, 54)\n                },\n                \"statement\",\n                false\n              ),\n              body: __node(\n                \"Assign\",\n                7700,\n                7715,\n                __wrap(left, 54),\n                \"=\",\n                __wrap(right, 54)\n              ),\n              elseIfs: [],\n              elseBody: __wrap(left, 54)\n            }\n          },\n          \"statement\",\n          false\n        );\n      }\n    });\n  };\n}.call(this));\n","operators":["or="],"options":{},"id":33},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.canMutateLast(right) && this.isIdentOrTmp(left)) {\n      return this.mutateLast(\n        right || this.noop(),\n        function (n) {\n          if (op === \"~*=\") {\n            return _this.assign(left, \"*=\", n);\n          } else if (op === \"~/=\") {\n            return _this.assign(left, \"/=\", n);\n          } else {\n            return _this.assign(left, \"%=\", n);\n          }\n        },\n        true\n      );\n    } else if (op === \"~*=\") {\n      return this.assign(left, \"*=\", right);\n    } else if (op === \"~/=\") {\n      return this.assign(left, \"/=\", right);\n    } else {\n      return this.assign(left, \"%=\", right);\n    }\n  };\n}.call(this));\n","operators":["~*=","~/=","~%="],"options":{"type":"number"},"id":35},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      return __node(\n        \"Assign\",\n        8626,\n        8655,\n        __wrap(setLeft, 59),\n        \"=\",\n        __node(\n          \"MacroAccess\",\n          8639,\n          8655,\n          34,\n          245,\n          {\n            left: __wrap(left, 59),\n            inverted: false,\n            op: \"~\\\\\",\n            right: __wrap(right, 59)\n          },\n          \"expression\",\n          false\n        )\n      );\n    });\n  };\n}.call(this));\n","operators":["~\\="],"options":{"type":"number"},"id":36},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var left, op, right;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      return __node(\n        \"Assign\",\n        9857,\n        9886,\n        __wrap(setLeft, 69),\n        \"=\",\n        __node(\n          \"MacroAccess\",\n          9870,\n          9886,\n          39,\n          285,\n          {\n            left: __wrap(left, 69),\n            inverted: false,\n            op: \"~^\",\n            right: __wrap(right, 69)\n          },\n          \"expression\",\n          false\n        )\n      );\n    });\n  };\n}.call(this));\n","operators":["~^="],"options":{"type":"number"},"id":40},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right, value;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.isConst(right)) {\n      value = this.value(right);\n      if (value === 1) {\n        return this.unary(\"++\", left);\n      } else if (value === -1) {\n        return this.unary(\"--\", left);\n      } else if (typeof value === \"number\" && !this.isType(left, \"numeric\")) {\n        return this.assign(left, \"-=\", this[\"const\"](-value));\n      }\n    }\n    if (this.isType(left, \"numeric\")) {\n      if (this.canMutateLast(right) && this.isIdentOrTmp(left)) {\n        return this.mutateLast(\n          right || this.noop(),\n          function (n) {\n            if (!_this.isType(n, \"numeric\")) {\n              n = __node(\n                \"MacroAccess\",\n                10405,\n                10410,\n                37,\n                301,\n                {\n                  op: \"~+\",\n                  node: __wrap(n, 72)\n                },\n                \"expression\",\n                false\n              );\n            }\n            return _this.assign(left, \"+=\", n);\n          },\n          true\n        );\n      } else {\n        if (!this.isType(right, \"numeric\")) {\n          right = __node(\n            \"MacroAccess\",\n            10516,\n            10525,\n            37,\n            305,\n            {\n              op: \"~+\",\n              node: __wrap(right, 70)\n            },\n            \"expression\",\n            false\n          );\n        }\n        return this.assign(left, \"+=\", right);\n      }\n    } else if (this.canMutateLast(right) && this.isIdentOrTmp(left)) {\n      return this.mutateLast(\n        right || this.noop(),\n        function (n) {\n          return _this.assign(left, \"-=\", __node(\n            \"MacroAccess\",\n            10694,\n            10699,\n            37,\n            309,\n            {\n              op: \"~-\",\n              node: __wrap(n, 73)\n            },\n            \"expression\",\n            false\n          ));\n        },\n        true\n      );\n    } else {\n      return this.assign(left, \"-=\", __node(\n        \"MacroAccess\",\n        10746,\n        10755,\n        37,\n        311,\n        {\n          op: \"~-\",\n          node: __wrap(right, 70)\n        },\n        \"expression\",\n        false\n      ));\n    }\n  };\n}.call(this));\n","operators":["~+="],"options":{"type":"number"},"id":41},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right, value;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.isConst(right)) {\n      value = this.value(right);\n      if (value === 1) {\n        return this.unary(\"--\", left);\n      } else if (value === -1) {\n        return this.unary(\"++\", left);\n      }\n    }\n    if (this.canMutateLast(right) && this.isIdentOrTmp(left)) {\n      return this.mutateLast(\n        right || this.noop(),\n        function (n) {\n          return _this.assign(left, \"-=\", n);\n        },\n        true\n      );\n    } else {\n      return this.assign(left, \"-=\", right);\n    }\n  };\n}.call(this));\n","operators":["~-="],"options":{"type":"number"},"id":42},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.canMutateLast(right) && this.isIdentOrTmp(left)) {\n      return this.mutateLast(\n        right || this.noop(),\n        function (n) {\n          if (op === \"~bitlshift=\") {\n            return _this.assign(left, \"<<=\", n);\n          } else if (op === \"~bitrshift=\") {\n            return _this.assign(left, \">>=\", n);\n          } else {\n            return _this.assign(left, \">>>=\", n);\n          }\n        },\n        true\n      );\n    } else if (op === \"~bitlshift=\") {\n      return this.assign(left, \"<<=\", right);\n    } else if (op === \"~bitrshift=\") {\n      return this.assign(left, \">>=\", right);\n    } else {\n      return this.assign(left, \">>>=\", right);\n    }\n  };\n}.call(this));\n","operators":["~bitlshift=","~bitrshift=","~biturshift="],"options":{"type":"number"},"id":44},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.canMutateLast(right) && this.isIdentOrTmp(left)) {\n      return this.mutateLast(\n        right || this.noop(),\n        function (n) {\n          if (_this.hasType(left, \"numeric\") && _this.hasType(n, \"numeric\")) {\n            n = __node(\n              \"MacroAccess\",\n              12146,\n              12154,\n              20,\n              354,\n              {\n                left: __node(\"Const\", 12147, 12149, \"\"),\n                inverted: false,\n                op: \"~&\",\n                right: __node(\"Ident\", 12152, 12154, \"n\")\n              },\n              \"expression\",\n              false\n            );\n          }\n          return _this.assign(left, \"+=\", n);\n        },\n        true\n      );\n    } else {\n      if (this.hasType(left, \"numeric\") && this.hasType(right, \"numeric\")) {\n        right = __node(\n          \"MacroAccess\",\n          12280,\n          12292,\n          20,\n          358,\n          {\n            left: __node(\"Const\", 12281, 12283, \"\"),\n            inverted: false,\n            op: \"~&\",\n            right: __node(\"Ident\", 12286, 12292, \"right\")\n          },\n          \"expression\",\n          false\n        );\n      }\n      return this.assign(left, \"+=\", right);\n    }\n  };\n}.call(this));\n","operators":["~&="],"options":{"type":"string"},"id":45},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      return __node(\n        \"Assign\",\n        13959,\n        13987,\n        __wrap(setLeft, 95),\n        \"=\",\n        __node(\n          \"MacroAccess\",\n          13972,\n          13987,\n          49,\n          418,\n          {\n            left: __wrap(left, 95),\n            inverted: false,\n            op: \"^\",\n            right: __wrap(right, 95)\n          },\n          \"expression\",\n          false\n        )\n      );\n    });\n  };\n}.call(this));\n","operators":["^="],"options":{"type":"number"},"id":50},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      return __node(\n        \"Assign\",\n        14812,\n        14840,\n        __wrap(setLeft, 101),\n        \"=\",\n        __node(\n          \"MacroAccess\",\n          14825,\n          14840,\n          51,\n          449,\n          {\n            left: __wrap(left, 101),\n            inverted: false,\n            op: \"\\\\\",\n            right: __wrap(right, 101)\n          },\n          \"expression\",\n          false\n        )\n      );\n    });\n  };\n}.call(this));\n","operators":["\\="],"options":{"type":"number"},"id":55},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      return __node(\n        \"Assign\",\n        15496,\n        15524,\n        __wrap(setLeft, 104),\n        \"=\",\n        __node(\n          \"MacroAccess\",\n          15509,\n          15524,\n          56,\n          470,\n          {\n            left: __wrap(left, 104),\n            inverted: false,\n            op: \"&\",\n            right: __wrap(right, 104)\n          },\n          \"expression\",\n          false\n        )\n      );\n    });\n  };\n}.call(this));\n","operators":["&="],"options":{"type":"string"},"id":57},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      return _this.maybeCache(right, function (setRight, right) {\n        return __node(\n          \"MacroAccess\",\n          20565,\n          20641,\n          19,\n          635,\n          {\n            macroName: \"if\",\n            macroData: {\n              test: __node(\n                \"MacroAccess\",\n                20568,\n                20592,\n                10,\n                635,\n                {\n                  left: __wrap(setLeft, 142),\n                  inverted: false,\n                  op: \"~>\",\n                  right: __wrap(setRight, 142)\n                },\n                \"expression\",\n                false\n              ),\n              body: __node(\n                \"Assign\",\n                20601,\n                20616,\n                __wrap(left, 142),\n                \"=\",\n                __wrap(right, 142)\n              ),\n              elseIfs: [],\n              elseBody: __wrap(left, 142)\n            }\n          },\n          \"expression\",\n          false\n        );\n      });\n    });\n  };\n}.call(this));\n","operators":["~min="],"options":{},"id":73},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      return _this.maybeCache(right, function (setRight, right) {\n        return __node(\n          \"MacroAccess\",\n          20774,\n          20850,\n          19,\n          643,\n          {\n            macroName: \"if\",\n            macroData: {\n              test: __node(\n                \"MacroAccess\",\n                20777,\n                20801,\n                9,\n                643,\n                {\n                  left: __wrap(setLeft, 145),\n                  inverted: false,\n                  op: \"~<\",\n                  right: __wrap(setRight, 145)\n                },\n                \"expression\",\n                false\n              ),\n              body: __node(\n                \"Assign\",\n                20810,\n                20825,\n                __wrap(left, 145),\n                \"=\",\n                __wrap(right, 145)\n              ),\n              elseIfs: [],\n              elseBody: __wrap(left, 145)\n            }\n          },\n          \"expression\",\n          false\n        );\n      });\n    });\n  };\n}.call(this));\n","operators":["~max="],"options":{},"id":74},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      return _this.maybeCache(right, function (setRight, right) {\n        return __node(\n          \"MacroAccess\",\n          20982,\n          21057,\n          19,\n          651,\n          {\n            macroName: \"if\",\n            macroData: {\n              test: __node(\n                \"MacroAccess\",\n                20985,\n                21008,\n                66,\n                651,\n                {\n                  left: __wrap(setLeft, 148),\n                  inverted: false,\n                  op: \">\",\n                  right: __wrap(setRight, 148)\n                },\n                \"expression\",\n                false\n              ),\n              body: __node(\n                \"Assign\",\n                21017,\n                21032,\n                __wrap(left, 148),\n                \"=\",\n                __wrap(right, 148)\n              ),\n              elseIfs: [],\n              elseBody: __wrap(left, 148)\n            }\n          },\n          \"expression\",\n          false\n        );\n      });\n    });\n  };\n}.call(this));\n","operators":["min="],"options":{},"id":75},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      return _this.maybeCache(right, function (setRight, right) {\n        return __node(\n          \"MacroAccess\",\n          21189,\n          21264,\n          19,\n          659,\n          {\n            macroName: \"if\",\n            macroData: {\n              test: __node(\n                \"MacroAccess\",\n                21192,\n                21215,\n                65,\n                659,\n                {\n                  left: __wrap(setLeft, 151),\n                  inverted: false,\n                  op: \"<\",\n                  right: __wrap(setRight, 151)\n                },\n                \"expression\",\n                false\n              ),\n              body: __node(\n                \"Assign\",\n                21224,\n                21239,\n                __wrap(left, 151),\n                \"=\",\n                __wrap(right, 151)\n              ),\n              elseIfs: [],\n              elseBody: __wrap(left, 151)\n            }\n          },\n          \"expression\",\n          false\n        );\n      });\n    });\n  };\n}.call(this));\n","operators":["max="],"options":{},"id":76},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      return __node(\n        \"Assign\",\n        21349,\n        21379,\n        __wrap(setLeft, 153),\n        \"=\",\n        __node(\n          \"MacroAccess\",\n          21362,\n          21379,\n          71,\n          666,\n          {\n            left: __wrap(left, 153),\n            inverted: false,\n            op: \"xor\",\n            right: __wrap(right, 153)\n          },\n          \"expression\",\n          false\n        )\n      );\n    });\n  };\n}.call(this));\n","operators":["xor="],"options":{},"id":77},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    return this.maybeCacheAccess(left, function (setLeft, left) {\n      return _this.maybeCache(setLeft, function (setLeft, leftValue) {\n        if (_this.position === \"expression\") {\n          return __node(\n            \"MacroAccess\",\n            21552,\n            21606,\n            18,\n            672,\n            {\n              macroName: \"if\",\n              macroData: {\n                test: __node(\n                  \"MacroAccess\",\n                  21555,\n                  21566,\n                  21,\n                  672,\n                  {\n                    op: \"?\",\n                    node: __wrap(setLeft, 156)\n                  },\n                  \"expression\",\n                  false\n                ),\n                body: __wrap(leftValue, 156),\n                elseIfs: [],\n                elseBody: __node(\n                  \"Assign\",\n                  21590,\n                  21605,\n                  __wrap(left, 156),\n                  \"=\",\n                  __wrap(right, 156)\n                )\n              }\n            },\n            \"expression\",\n            false\n          );\n        } else {\n          return __node(\n            \"MacroAccess\",\n            21629,\n            21708,\n            19,\n            674,\n            {\n              macroName: \"if\",\n              macroData: {\n                test: __node(\n                  \"MacroAccess\",\n                  21632,\n                  21647,\n                  3,\n                  674,\n                  {\n                    op: \"not\",\n                    node: __node(\n                      \"MacroAccess\",\n                      21636,\n                      21647,\n                      21,\n                      674,\n                      {\n                        op: \"?\",\n                        node: __wrap(setLeft, 156)\n                      },\n                      \"statement\",\n                      false\n                    )\n                  },\n                  \"statement\",\n                  false\n                ),\n                body: __node(\n                  \"Assign\",\n                  21658,\n                  21673,\n                  __wrap(left, 156),\n                  \"=\",\n                  __wrap(right, 156)\n                ),\n                elseIfs: [],\n                elseBody: __wrap(leftValue, 156)\n              }\n            },\n            \"statement\",\n            false\n          );\n        }\n      });\n    });\n  };\n}.call(this));\n","operators":["?="],"options":{},"id":78},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.canMutateLast(right) && this.isIdentOrTmp(left)) {\n      return this.mutateLast(\n        right || this.noop(),\n        function (n) {\n          if (op === \"~bitand=\") {\n            return _this.assign(left, \"&=\", n);\n          } else if (op === \"~bitor=\") {\n            return _this.assign(left, \"|=\", n);\n          } else {\n            return _this.assign(left, \"^=\", n);\n          }\n        },\n        true\n      );\n    } else if (op === \"~bitand=\") {\n      return this.assign(left, \"&=\", right);\n    } else if (op === \"~bitor=\") {\n      return this.assign(left, \"|=\", right);\n    } else {\n      return this.assign(left, \"^=\", right);\n    }\n  };\n}.call(this));\n","operators":["~bitand=","~bitor=","~bitxor="],"options":{"type":"number"},"id":82},{"code":"return (function () {\n  \"use strict\";\n  return function (_p, __wrap, __node) {\n    var _this, left, op, right;\n    _this = this;\n    left = _p.left;\n    op = _p.op;\n    right = _p.right;\n    if (this.isType(left, \"number\")) {\n      if (op === \"*=\") {\n        return __node(\n          \"MacroAccess\",\n          23634,\n          23652,\n          35,\n          741,\n          {\n            left: __wrap(left, 175),\n            op: \"~*=\",\n            right: __node(\n              \"MacroAccess\",\n              23644,\n              23652,\n              47,\n              741,\n              {\n                op: \"+\",\n                node: __wrap(right, 175)\n              },\n              \"expression\",\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else if (op === \"/=\") {\n        return __node(\n          \"MacroAccess\",\n          23686,\n          23704,\n          35,\n          743,\n          {\n            left: __wrap(left, 175),\n            op: \"~/=\",\n            right: __node(\n              \"MacroAccess\",\n              23696,\n              23704,\n              47,\n              743,\n              {\n                op: \"+\",\n                node: __wrap(right, 175)\n              },\n              \"expression\",\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else if (op === \"%=\") {\n        return __node(\n          \"MacroAccess\",\n          23738,\n          23756,\n          35,\n          745,\n          {\n            left: __wrap(left, 175),\n            op: \"~%=\",\n            right: __node(\n              \"MacroAccess\",\n              23748,\n              23756,\n              47,\n              745,\n              {\n                op: \"+\",\n                node: __wrap(right, 175)\n              },\n              \"expression\",\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else if (op === \"+=\") {\n        return __node(\n          \"MacroAccess\",\n          23790,\n          23808,\n          41,\n          747,\n          {\n            left: __wrap(left, 175),\n            op: \"~+=\",\n            right: __node(\n              \"MacroAccess\",\n              23800,\n              23808,\n              47,\n              747,\n              {\n                op: \"+\",\n                node: __wrap(right, 175)\n              },\n              \"expression\",\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else if (op === \"-=\") {\n        return __node(\n          \"MacroAccess\",\n          23842,\n          23860,\n          42,\n          749,\n          {\n            left: __wrap(left, 175),\n            op: \"~-=\",\n            right: __node(\n              \"MacroAccess\",\n              23852,\n              23860,\n              47,\n              749,\n              {\n                op: \"+\",\n                node: __wrap(right, 175)\n              },\n              \"expression\",\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else if (op === \"bitlshift=\") {\n        return __node(\n          \"MacroAccess\",\n          23902,\n          23928,\n          44,\n          751,\n          {\n            left: __wrap(left, 175),\n            op: \"~bitlshift=\",\n            right: __node(\n              \"MacroAccess\",\n              23920,\n              23928,\n              47,\n              751,\n              {\n                op: \"+\",\n                node: __wrap(right, 175)\n              },\n              \"expression\",\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else if (op === \"bitrshift=\") {\n        return __node(\n          \"MacroAccess\",\n          23970,\n          23996,\n          44,\n          753,\n          {\n            left: __wrap(left, 175),\n            op: \"~bitrshift=\",\n            right: __node(\n              \"MacroAccess\",\n              23988,\n              23996,\n              47,\n              753,\n              {\n                op: \"+\",\n                node: __wrap(right, 175)\n              },\n              \"expression\",\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else if (op === \"biturshift=\") {\n        return __node(\n          \"MacroAccess\",\n          24039,\n          24066,\n          44,\n          755,\n          {\n            left: __wrap(left, 175),\n            op: \"~biturshift=\",\n            right: __node(\n              \"MacroAccess\",\n              24058,\n              24066,\n              47,\n              755,\n              {\n                op: \"+\",\n                node: __wrap(right, 175)\n              },\n              \"expression\",\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else if (op === \"bitand=\") {\n        return __node(\n          \"MacroAccess\",\n          24105,\n          24128,\n          82,\n          757,\n          {\n            left: __wrap(left, 175),\n            op: \"~bitand=\",\n            right: __node(\n              \"MacroAccess\",\n              24120,\n              24128,\n              47,\n              757,\n              {\n                op: \"+\",\n                node: __wrap(right, 175)\n              },\n              \"expression\",\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else if (op === \"bitor=\") {\n        return __node(\n          \"MacroAccess\",\n          24166,\n          24188,\n          82,\n          759,\n          {\n            left: __wrap(left, 175),\n            op: \"~bitor=\",\n            right: __node(\n              \"MacroAccess\",\n              24180,\n              24188,\n              47,\n              759,\n              {\n                op: \"+\",\n                node: __wrap(right, 175)\n              },\n              \"expression\",\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else if (op === \"bitxor=\") {\n        return __node(\n          \"MacroAccess\",\n          24227,\n          24250,\n          82,\n          761,\n          {\n            left: __wrap(left, 175),\n            op: \"~bitxor=\",\n            right: __node(\n              \"MacroAccess\",\n              24242,\n              24250,\n              47,\n              761,\n              {\n                op: \"+\",\n                node: __wrap(right, 175)\n              },\n              \"expression\",\n              false\n            )\n          },\n          \"expression\",\n          false\n        );\n      } else {\n        throw Error();\n      }\n    } else {\n      return this.maybeCacheAccess(left, function (setLeft, left) {\n        var action;\n        if (op === \"*=\") {\n          action = __node(\n            \"MacroAccess\",\n            24381,\n            24396,\n            51,\n            767,\n            {\n              left: __wrap(left, 176),\n              inverted: false,\n              op: \"*\",\n              right: __wrap(right, 176)\n            },\n            \"expression\",\n            false\n          );\n        } else if (op === \"/=\") {\n          action = __node(\n            \"MacroAccess\",\n            24434,\n            24449,\n            51,\n            769,\n            {\n              left: __wrap(left, 176),\n              inverted: false,\n              op: \"/\",\n              right: __wrap(right, 176)\n            },\n            \"expression\",\n            false\n          );\n        } else if (op === \"%=\") {\n          action = __node(\n            \"MacroAccess\",\n            24487,\n            24502,\n            51,\n            771,\n            {\n              left: __wrap(left, 176),\n              inverted: false,\n              op: \"%\",\n              right: __wrap(right, 176)\n            },\n            \"expression\",\n            false\n          );\n        } else if (op === \"+=\") {\n          action = __node(\n            \"MacroAccess\",\n            24540,\n            24555,\n            53,\n            773,\n            {\n              left: __wrap(left, 176),\n              inverted: false,\n              op: \"+\",\n              right: __wrap(right, 176)\n            },\n            \"expression\",\n            false\n          );\n        } else if (op === \"-=\") {\n          action = __node(\n            \"MacroAccess\",\n            24593,\n            24608,\n            53,\n            775,\n            {\n              left: __wrap(left, 176),\n              inverted: false,\n              op: \"-\",\n              right: __wrap(right, 176)\n            },\n            \"expression\",\n            false\n          );\n        } else if (op === \"bitlshift=\") {\n          action = __node(\n            \"MacroAccess\",\n            24654,\n            24677,\n            54,\n            777,\n            {\n              left: __wrap(left, 176),\n              inverted: false,\n              op: \"bitlshift\",\n              right: __wrap(right, 176)\n            },\n            \"expression\",\n            false\n          );\n        } else if (op === \"bitrshift=\") {\n          action = __node(\n            \"MacroAccess\",\n            24723,\n            24746,\n            54,\n            779,\n            {\n              left: __wrap(left, 176),\n              inverted: false,\n              op: \"bitrshift\",\n              right: __wrap(right, 176)\n            },\n            \"expression\",\n            false\n          );\n        } else if (op === \"biturshift=\") {\n          action = __node(\n            \"MacroAccess\",\n            24793,\n            24817,\n            54,\n            781,\n            {\n              left: __wrap(left, 176),\n              inverted: false,\n              op: \"biturshift\",\n              right: __wrap(right, 176)\n            },\n            \"expression\",\n            false\n          );\n        } else if (op === \"bitand=\") {\n          action = __node(\n            \"MacroAccess\",\n            24860,\n            24880,\n            83,\n            783,\n            {\n              left: __wrap(left, 176),\n              inverted: false,\n              op: \"bitand\",\n              right: __wrap(right, 176)\n            },\n            \"expression\",\n            false\n          );\n        } else if (op === \"bitor=\") {\n          action = __node(\n            \"MacroAccess\",\n            24922,\n            24941,\n            84,\n            785,\n            {\n              left: __wrap(left, 176),\n              inverted: false,\n              op: \"bitor\",\n              right: __wrap(right, 176)\n            },\n            \"expression\",\n            false\n          );\n        } else if (op === \"bitxor=\") {\n          action = __node(\n            \"MacroAccess\",\n            24984,\n            25004,\n            85,\n            787,\n            {\n              left: __wrap(left, 176),\n              inverted: false,\n              op: \"bitxor\",\n              right: __wrap(right, 176)\n            },\n            \"expression\",\n            false\n          );\n        } else {\n          throw Error();\n        }\n        return __node(\n          \"Assign\",\n          25048,\n          25069,\n          __wrap(setLeft, 176),\n          \"=\",\n          __wrap(action, 176)\n        );\n      });\n    }\n  };\n}.call(this));\n","operators":["*=","/=","%=","+=","-=","bitlshift=","bitrshift=","biturshift=","bitand=","bitor=","bitxor="],"options":{"type":"number"},"id":90}],"helpers":{"__typeof":{"helper":{"type":"Call","func":{"type":"Func","variables":["_toString"],"body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"_toString"},"op":"=","right":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"Object"},"op":".","right":{"type":"Const","value":"prototype"}},"op":".","right":{"type":"Const","value":"toString"}}},{"type":"Return","node":{"type":"Func","params":[{"type":"Ident","name":"o"}],"body":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"o"},"op":"===","right":{"type":"Const"}},"whenTrue":{"type":"Return","node":{"type":"Const","value":"Undefined"}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"o"},"op":"===","right":{"type":"Const","value":null}},"whenTrue":{"type":"Return","node":{"type":"Const","value":"Null"}},"whenFalse":{"type":"Return","node":{"type":"Binary","left":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"o"},"op":".","right":{"type":"Const","value":"constructor"}},"op":"&&","right":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"o"},"op":".","right":{"type":"Const","value":"constructor"}},"op":".","right":{"type":"Const","value":"name"}}},"op":"||","right":{"type":"Call","func":{"type":"Binary","left":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"_toString"},"op":".","right":{"type":"Const","value":"call"}},"args":[{"type":"Ident","name":"o"}]},"op":".","right":{"type":"Const","value":"slice"}},"args":[{"type":"Const","value":8},{"type":"Const","value":-1}]}}}}}}}]}}},"type":{"type":"function","returnType":{"type":"simple","name":"string"}},"dependencies":["__typeof"]},"__num":{"helper":{"type":"Func","params":[{"type":"Ident","name":"num"}],"body":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"num"}},"op":"!==","right":{"type":"Const","value":"number"}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected a number, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"__typeof"},"args":[{"type":"Ident","name":"num"}]}}]}},"whenFalse":{"type":"Return","node":{"type":"Ident","name":"num"}}}},"type":{"type":"function","returnType":{"type":"simple","name":"number"}},"dependencies":["__num","__typeof"]},"__str":{"helper":{"type":"Func","params":[{"type":"Ident","name":"str"}],"body":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"str"}},"op":"!==","right":{"type":"Const","value":"string"}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected a string, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"__typeof"},"args":[{"type":"Ident","name":"str"}]}}]}},"whenFalse":{"type":"Return","node":{"type":"Ident","name":"str"}}}},"type":{"type":"function","returnType":{"type":"simple","name":"string"}},"dependencies":["__str","__typeof"]},"__strnum":{"helper":{"type":"Func","params":[{"type":"Ident","name":"strnum"}],"variables":["type"],"body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"=","right":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"strnum"}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"===","right":{"type":"Const","value":"string"}},"whenTrue":{"type":"Return","node":{"type":"Ident","name":"strnum"}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"===","right":{"type":"Const","value":"number"}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"String"},"args":[{"type":"Ident","name":"strnum"}]}},"whenFalse":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected a string or number, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"__typeof"},"args":[{"type":"Ident","name":"strnum"}]}}]}}}}]}},"type":{"type":"function","returnType":{"type":"simple","name":"string"}},"dependencies":["__strnum","__typeof"]},"__owns":{"helper":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"Object"},"op":".","right":{"type":"Const","value":"prototype"}},"op":".","right":{"type":"Const","value":"hasOwnProperty"}},"type":{"type":"any"},"dependencies":["__owns"]},"__cmp":{"helper":{"type":"Func","params":[{"type":"Ident","name":"left"},{"type":"Ident","name":"right"}],"variables":["type"],"body":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"left"},"op":"===","right":{"type":"Ident","name":"right"}},"whenTrue":{"type":"Return","node":{"type":"Const","value":0,"sign":1}},"whenFalse":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"=","right":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"left"}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"!==","right":{"type":"Const","value":"number"}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"!==","right":{"type":"Const","value":"string"}}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Cannot compare a non-number/string: "},"op":"+","right":{"type":"Ident","name":"type"}}]}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"!==","right":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"right"}}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Binary","left":{"type":"Binary","left":{"type":"Const","value":"Cannot compare elements of different types: "},"op":"+","right":{"type":"Ident","name":"type"}},"op":"+","right":{"type":"Const","value":" vs "}},"op":"+","right":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"right"}}}]}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"left"},"op":"<","right":{"type":"Ident","name":"right"}},"whenTrue":{"type":"Return","node":{"type":"Const","value":-1}},"whenFalse":{"type":"Return","node":{"type":"Const","value":1}}}}}]}}},"type":{"type":"function","returnType":{"type":"simple","name":"number"}},"dependencies":["__cmp"]},"__int":{"helper":{"type":"Func","params":[{"type":"Ident","name":"num"}],"body":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"num"}},"op":"!==","right":{"type":"Const","value":"number"}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected a number, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"__typeof"},"args":[{"type":"Ident","name":"num"}]}}]}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"num"},"op":"%","right":{"type":"Const","value":1}},"op":"!==","right":{"type":"Const","value":0,"sign":1}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected an integer, got "},"op":"+","right":{"type":"Ident","name":"num"}}]}},"whenFalse":{"type":"Return","node":{"type":"Ident","name":"num"}}}}},"type":{"type":"function","returnType":{"type":"simple","name":"number"}},"dependencies":["__int","__typeof"]},"__nonzero":{"helper":{"type":"Func","params":[{"type":"Ident","name":"num"}],"body":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"num"},"op":"===","right":{"type":"Const","value":0,"sign":1}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"RangeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected non-zero, got "},"op":"+","right":{"type":"Ident","name":"num"}}]}},"whenFalse":{"type":"Return","node":{"type":"Ident","name":"num"}}}},"type":{"type":"function","returnType":{"type":"any"}},"dependencies":["__nonzero"]},"__lt":{"helper":{"type":"Func","params":[{"type":"Ident","name":"x"},{"type":"Ident","name":"y"}],"variables":["type"],"body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"=","right":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"x"}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"!==","right":{"type":"Const","value":"number"}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"!==","right":{"type":"Const","value":"string"}}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Cannot compare a non-number/string: "},"op":"+","right":{"type":"Ident","name":"type"}}]}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"!==","right":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"y"}}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Binary","left":{"type":"Binary","left":{"type":"Const","value":"Cannot compare elements of different types: "},"op":"+","right":{"type":"Ident","name":"type"}},"op":"+","right":{"type":"Const","value":" vs "}},"op":"+","right":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"y"}}}]}},"whenFalse":{"type":"Return","node":{"type":"Binary","left":{"type":"Ident","name":"x"},"op":"<","right":{"type":"Ident","name":"y"}}}}}]}},"type":{"type":"function","returnType":{"type":"simple","name":"boolean"}},"dependencies":["__lt"]},"__lte":{"helper":{"type":"Func","params":[{"type":"Ident","name":"x"},{"type":"Ident","name":"y"}],"variables":["type"],"body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"=","right":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"x"}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"!==","right":{"type":"Const","value":"number"}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"!==","right":{"type":"Const","value":"string"}}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Cannot compare a non-number/string: "},"op":"+","right":{"type":"Ident","name":"type"}}]}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"type"},"op":"!==","right":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"y"}}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Binary","left":{"type":"Binary","left":{"type":"Const","value":"Cannot compare elements of different types: "},"op":"+","right":{"type":"Ident","name":"type"}},"op":"+","right":{"type":"Const","value":" vs "}},"op":"+","right":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"y"}}}]}},"whenFalse":{"type":"Return","node":{"type":"Binary","left":{"type":"Ident","name":"x"},"op":"<=","right":{"type":"Ident","name":"y"}}}}}]}},"type":{"type":"function","returnType":{"type":"simple","name":"boolean"}},"dependencies":["__lte"]},"__slice":{"helper":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"Array"},"op":".","right":{"type":"Const","value":"prototype"}},"op":".","right":{"type":"Const","value":"slice"}},"type":{"type":"any"},"dependencies":["__slice"]},"__freeze":{"helper":{"type":"IfExpression","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Binary","left":{"type":"Ident","name":"Object"},"op":".","right":{"type":"Const","value":"freeze"}}},"op":"===","right":{"type":"Const","value":"function"}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"Object"},"op":".","right":{"type":"Const","value":"freeze"}},"whenFalse":{"type":"Func","params":[{"type":"Ident","name":"x"}],"body":{"type":"Return","node":{"type":"Ident","name":"x"}}}},"type":{"type":"any"},"dependencies":["__freeze"]},"__freezeFunc":{"helper":{"type":"Func","params":[{"type":"Ident","name":"x"}],"body":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"x"},"op":".","right":{"type":"Const","value":"prototype"}},"op":"!=","right":{"type":"Const","value":null}},"whenTrue":{"type":"Call","func":{"type":"Ident","name":"__freeze"},"args":[{"type":"Binary","left":{"type":"Ident","name":"x"},"op":".","right":{"type":"Const","value":"prototype"}}]}},{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"__freeze"},"args":[{"type":"Ident","name":"x"}]}}]}},"type":{"type":"function","returnType":{"type":"any"}},"dependencies":["__freeze","__freezeFunc"]},"__isArray":{"helper":{"type":"IfExpression","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Binary","left":{"type":"Ident","name":"Array"},"op":".","right":{"type":"Const","value":"isArray"}}},"op":"===","right":{"type":"Const","value":"function"}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"Array"},"op":".","right":{"type":"Const","value":"isArray"}},"whenFalse":{"type":"Call","func":{"type":"Func","variables":["_toString"],"body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"_toString"},"op":"=","right":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"Object"},"op":".","right":{"type":"Const","value":"prototype"}},"op":".","right":{"type":"Const","value":"toString"}}},{"type":"Return","node":{"type":"Func","params":[{"type":"Ident","name":"x"}],"body":{"type":"Return","node":{"type":"Binary","left":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"_toString"},"op":".","right":{"type":"Const","value":"call"}},"args":[{"type":"Ident","name":"x"}]},"op":"===","right":{"type":"Const","value":"[object Array]"}}}}}]}}}},"type":{"type":"any"},"dependencies":["__isArray"]},"__isObject":{"helper":{"type":"Func","params":[{"type":"Ident","name":"x"}],"body":{"type":"Return","node":{"type":"Binary","left":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"x"}},"op":"===","right":{"type":"Const","value":"object"}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"x"},"op":"!==","right":{"type":"Const","value":null}}}}},"type":{"type":"function","returnType":{"type":"simple","name":"boolean"}},"dependencies":["__isObject"]},"__toArray":{"helper":{"type":"Func","params":[{"type":"Ident","name":"x"}],"body":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"x"},"op":"==","right":{"type":"Const","value":null}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected an object, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"__typeof"},"args":[{"type":"Ident","name":"x"}]}}]}},"whenFalse":{"type":"IfStatement","test":{"type":"Call","func":{"type":"Ident","name":"__isArray"},"args":[{"type":"Ident","name":"x"}]},"whenTrue":{"type":"Return","node":{"type":"Ident","name":"x"}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"x"}},"op":"===","right":{"type":"Const","value":"string"}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"x"},"op":".","right":{"type":"Const","value":"split"}},"args":[{"type":"Const","value":""}]}},"whenFalse":{"type":"Return","node":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"__slice"},"op":".","right":{"type":"Const","value":"call"}},"args":[{"type":"Ident","name":"x"}]}}}}}},"type":{"type":"function","returnType":{"type":"array","subtype":{"type":"any"}}},"dependencies":["__isArray","__slice","__toArray","__typeof"]},"__create":{"helper":{"type":"IfExpression","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Binary","left":{"type":"Ident","name":"Object"},"op":".","right":{"type":"Const","value":"create"}}},"op":"===","right":{"type":"Const","value":"function"}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"Object"},"op":".","right":{"type":"Const","value":"create"}},"whenFalse":{"type":"Func","params":[{"type":"Ident","name":"x"}],"body":{"type":"BlockStatement","body":[{"type":"Func","name":{"type":"Ident","name":"F"}},{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"F"},"op":".","right":{"type":"Const","value":"prototype"}},"op":"=","right":{"type":"Ident","name":"x"}},{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"F"},"isNew":true}}]}}},"type":{"type":"any"},"dependencies":["__create"]},"__pow":{"helper":{"type":"Binary","left":{"type":"Ident","name":"Math"},"op":".","right":{"type":"Const","value":"pow"}},"type":{"type":"any"},"dependencies":["__pow"]},"__floor":{"helper":{"type":"Binary","left":{"type":"Ident","name":"Math"},"op":".","right":{"type":"Const","value":"floor"}},"type":{"type":"any"},"dependencies":["__floor"]},"__sqrt":{"helper":{"type":"Binary","left":{"type":"Ident","name":"Math"},"op":".","right":{"type":"Const","value":"sqrt"}},"type":{"type":"any"},"dependencies":["__sqrt"]},"__log":{"helper":{"type":"Binary","left":{"type":"Ident","name":"Math"},"op":".","right":{"type":"Const","value":"log"}},"type":{"type":"any"},"dependencies":["__log"]},"__range":{"helper":{"type":"Func","params":[{"type":"Ident","name":"start"},{"type":"Ident","name":"end"},{"type":"Ident","name":"step"},{"type":"Ident","name":"inclusive"}],"variables":["i","result"],"body":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"start"}},"op":"!==","right":{"type":"Const","value":"number"}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected start to be a Number, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"__typeof"},"args":[{"type":"Ident","name":"start"}]}}]}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"end"}},"op":"!==","right":{"type":"Const","value":"number"}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected end to be a Number, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"__typeof"},"args":[{"type":"Ident","name":"end"}]}}]}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"step"}},"op":"!==","right":{"type":"Const","value":"number"}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected step to be a Number, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"__typeof"},"args":[{"type":"Ident","name":"step"}]}}]}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"inclusive"},"op":"==","right":{"type":"Const","value":null}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"inclusive"},"op":"=","right":{"type":"Const","value":false}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"inclusive"}},"op":"!==","right":{"type":"Const","value":"boolean"}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected inclusive to be a Boolean, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"__typeof"},"args":[{"type":"Ident","name":"inclusive"}]}}]}}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"step"},"op":"===","right":{"type":"Const","value":0,"sign":1}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"RangeError"},"args":[{"type":"Const","value":"step cannot be zero"}]}},"whenFalse":{"type":"IfStatement","test":{"type":"Unary","op":"!","node":{"type":"Call","func":{"type":"Ident","name":"isFinite"},"args":[{"type":"Ident","name":"start"}]}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"RangeError"},"args":[{"type":"Const","value":"start must be finite"}]}},"whenFalse":{"type":"IfStatement","test":{"type":"Unary","op":"!","node":{"type":"Call","func":{"type":"Ident","name":"isFinite"},"args":[{"type":"Ident","name":"end"}]}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"RangeError"},"args":[{"type":"Const","value":"end must be finite"}]}}}}},{"type":"Binary","left":{"type":"Ident","name":"result"},"op":"=","right":{"type":"Arr"}},{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"=","right":{"type":"Ident","name":"start"}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"step"},"op":">","right":{"type":"Const","value":0,"sign":1}},"whenTrue":{"type":"BlockStatement","body":[{"type":"For","test":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"<","right":{"type":"Ident","name":"end"}},"step":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"+=","right":{"type":"Ident","name":"step"}},"body":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"result"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Ident","name":"i"}]}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"inclusive"},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"<=","right":{"type":"Ident","name":"end"}}},"whenTrue":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"result"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Ident","name":"i"}]}}]},"whenFalse":{"type":"BlockStatement","body":[{"type":"For","test":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":">","right":{"type":"Ident","name":"end"}},"step":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"+=","right":{"type":"Ident","name":"step"}},"body":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"result"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Ident","name":"i"}]}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"inclusive"},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":">=","right":{"type":"Ident","name":"end"}}},"whenTrue":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"result"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Ident","name":"i"}]}}]}},{"type":"Return","node":{"type":"Ident","name":"result"}}]}},"type":{"type":"function","returnType":{"type":"array","subtype":{"type":"simple","name":"number"}}},"dependencies":["__range","__typeof"]},"__step":{"helper":{"type":"Func","params":[{"type":"Ident","name":"array"},{"type":"Ident","name":"step"}],"variables":["i","len","result"],"body":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"step"}},"op":"!==","right":{"type":"Const","value":"number"}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected step to be a Number, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"__typeof"},"args":[{"type":"Ident","name":"step"}]}}]}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"step"},"op":"===","right":{"type":"Const","value":0,"sign":1}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"RangeError"},"args":[{"type":"Const","value":"step cannot be zero"}]}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"step"},"op":"===","right":{"type":"Const","value":1}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"__toArray"},"args":[{"type":"Ident","name":"array"}]}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"step"},"op":"===","right":{"type":"Const","value":-1}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Binary","left":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"__slice"},"op":".","right":{"type":"Const","value":"call"}},"args":[{"type":"Ident","name":"array"}]},"op":".","right":{"type":"Const","value":"reverse"}}}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"step"},"op":"%","right":{"type":"Const","value":1}},"op":"!==","right":{"type":"Const","value":0,"sign":1}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"RangeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"step must be an integer, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"String"},"args":[{"type":"Ident","name":"step"}]}}]}},"whenFalse":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"result"},"op":"=","right":{"type":"Arr"}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"step"},"op":">","right":{"type":"Const","value":0,"sign":1}},"whenTrue":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"=","right":{"type":"Const","value":0,"sign":1}},{"type":"Binary","left":{"type":"Ident","name":"len"},"op":"=","right":{"type":"Call","func":{"type":"Ident","name":"__num"},"args":[{"type":"Binary","left":{"type":"Ident","name":"array"},"op":".","right":{"type":"Const","value":"length"}}]}},{"type":"For","test":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"<","right":{"type":"Ident","name":"len"}},"step":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"+=","right":{"type":"Ident","name":"step"}},"body":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"result"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Binary","left":{"type":"Ident","name":"array"},"op":".","right":{"type":"Ident","name":"i"}}]}}]},"whenFalse":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"=","right":{"type":"Binary","left":{"type":"Call","func":{"type":"Ident","name":"__num"},"args":[{"type":"Binary","left":{"type":"Ident","name":"array"},"op":".","right":{"type":"Const","value":"length"}}]},"op":"-","right":{"type":"Const","value":1}}},{"type":"For","test":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":">=","right":{"type":"Const","value":0,"sign":1}},"step":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"+=","right":{"type":"Ident","name":"step"}},"body":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"result"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Binary","left":{"type":"Ident","name":"array"},"op":".","right":{"type":"Ident","name":"i"}}]}}]}},{"type":"Return","node":{"type":"Ident","name":"result"}}]}}}}}]}},"type":{"type":"function","returnType":{"type":"array","subtype":{"type":"any"}}},"dependencies":["__num","__slice","__step","__toArray","__typeof"]},"__sliceStep":{"helper":{"type":"Func","params":[{"type":"Ident","name":"array"},{"type":"Ident","name":"start"},{"type":"Ident","name":"end"},{"type":"Ident","name":"step"},{"type":"Ident","name":"inclusive"}],"variables":["arr"],"body":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"step"},"op":"<","right":{"type":"Const","value":0,"sign":1}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"arr"},"op":"=","right":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"__slice"},"op":".","right":{"type":"Const","value":"call"}},"args":[{"type":"Ident","name":"array"},{"type":"IfExpression","test":{"type":"Ident","name":"inclusive"},"whenTrue":{"type":"Ident","name":"end"},"whenFalse":{"type":"Binary","left":{"type":"Unary","op":"+","node":{"type":"Ident","name":"end"}},"op":"+","right":{"type":"Const","value":1}}},{"type":"Binary","left":{"type":"Binary","left":{"type":"Unary","op":"+","node":{"type":"Ident","name":"start"}},"op":"+","right":{"type":"Const","value":1}},"op":"||","right":{"type":"Const","infinite":true,"value":1}}]}},"whenFalse":{"type":"Binary","left":{"type":"Ident","name":"arr"},"op":"=","right":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"__slice"},"op":".","right":{"type":"Const","value":"call"}},"args":[{"type":"Ident","name":"array"},{"type":"Ident","name":"start"},{"type":"IfExpression","test":{"type":"Ident","name":"inclusive"},"whenTrue":{"type":"Binary","left":{"type":"Binary","left":{"type":"Unary","op":"+","node":{"type":"Ident","name":"end"}},"op":"+","right":{"type":"Const","value":1}},"op":"||","right":{"type":"Const","infinite":true,"value":1}},"whenFalse":{"type":"Ident","name":"end"}}]}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"step"},"op":"===","right":{"type":"Const","value":1}},"whenTrue":{"type":"Return","node":{"type":"Ident","name":"arr"}},"whenFalse":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"step"},"op":"===","right":{"type":"Const","value":-1}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"arr"},"op":".","right":{"type":"Const","value":"reverse"}}}},"whenFalse":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"__step"},"args":[{"type":"Ident","name":"arr"},{"type":"Ident","name":"step"}]}}}}]}},"type":{"type":"function","returnType":{"type":"array","subtype":{"type":"any"}}},"dependencies":["__slice","__sliceStep","__step"]},"__in":{"helper":{"type":"IfExpression","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"Array"},"op":".","right":{"type":"Const","value":"prototype"}},"op":".","right":{"type":"Const","value":"indexOf"}}},"op":"===","right":{"type":"Const","value":"function"}},"whenTrue":{"type":"Call","func":{"type":"Func","variables":["indexOf"],"body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"indexOf"},"op":"=","right":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"Array"},"op":".","right":{"type":"Const","value":"prototype"}},"op":".","right":{"type":"Const","value":"indexOf"}}},{"type":"Return","node":{"type":"Func","params":[{"type":"Ident","name":"child"},{"type":"Ident","name":"parent"}],"body":{"type":"Return","node":{"type":"Binary","left":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"indexOf"},"op":".","right":{"type":"Const","value":"call"}},"args":[{"type":"Ident","name":"parent"},{"type":"Ident","name":"child"}]},"op":"!==","right":{"type":"Const","value":-1}}}}}]}}},"whenFalse":{"type":"Func","params":[{"type":"Ident","name":"child"},{"type":"Ident","name":"parent"}],"variables":["i","len"],"body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"len"},"op":"=","right":{"type":"Unary","op":"+","node":{"type":"Binary","left":{"type":"Ident","name":"parent"},"op":".","right":{"type":"Const","value":"length"}}}},{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"=","right":{"type":"Const","value":-1}},{"type":"For","test":{"type":"Binary","left":{"type":"Unary","op":"++","node":{"type":"Ident","name":"i"}},"op":"<","right":{"type":"Ident","name":"len"}},"body":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"child"},"op":"===","right":{"type":"Binary","left":{"type":"Ident","name":"parent"},"op":".","right":{"type":"Ident","name":"i"}}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"in","right":{"type":"Ident","name":"parent"}}},"whenTrue":{"type":"Return","node":{"type":"Const","value":true}}}},{"type":"Return","node":{"type":"Const","value":false}}]}}},"type":{"type":"function","returnType":{"type":"simple","name":"boolean"}},"dependencies":["__in"]},"__keys":{"helper":{"type":"IfExpression","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Binary","left":{"type":"Ident","name":"Object"},"op":".","right":{"type":"Const","value":"keys"}}},"op":"===","right":{"type":"Const","value":"function"}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"Object"},"op":".","right":{"type":"Const","value":"keys"}},"whenFalse":{"type":"Func","params":[{"type":"Ident","name":"x"}],"variables":["key","keys"],"body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"keys"},"op":"=","right":{"type":"Arr"}},{"type":"ForIn","key":{"type":"Ident","name":"key"},"object":{"type":"Ident","name":"x"},"body":{"type":"IfStatement","test":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"__owns"},"op":".","right":{"type":"Const","value":"call"}},"args":[{"type":"Ident","name":"x"},{"type":"Ident","name":"key"}]},"whenTrue":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"keys"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Ident","name":"key"}]}}},{"type":"Return","node":{"type":"Ident","name":"keys"}}]}}},"type":{"type":"any"},"dependencies":["__keys","__owns"]},"__allkeys":{"helper":{"type":"Func","params":[{"type":"Ident","name":"x"}],"variables":["key","keys"],"body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"keys"},"op":"=","right":{"type":"Arr"}},{"type":"ForIn","key":{"type":"Ident","name":"key"},"object":{"type":"Ident","name":"x"},"body":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"keys"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Ident","name":"key"}]}},{"type":"Return","node":{"type":"Ident","name":"keys"}}]}},"type":{"type":"function","returnType":{"type":"array","subtype":{"type":"simple","name":"string"}}},"dependencies":["__allkeys"]},"__new":{"helper":{"type":"Call","func":{"type":"Func","variables":["newCreators"],"body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"newCreators"},"op":"=","right":{"type":"Arr"}},{"type":"Return","node":{"type":"Func","params":[{"type":"Ident","name":"Ctor"},{"type":"Ident","name":"args"}],"variables":["creator","func","i","length"],"body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"length"},"op":"=","right":{"type":"Binary","left":{"type":"Ident","name":"args"},"op":".","right":{"type":"Const","value":"length"}}},{"type":"Binary","left":{"type":"Ident","name":"creator"},"op":"=","right":{"type":"Binary","left":{"type":"Ident","name":"newCreators"},"op":".","right":{"type":"Ident","name":"length"}}},{"type":"IfStatement","test":{"type":"Unary","op":"!","node":{"type":"Ident","name":"creator"}},"whenTrue":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"func"},"op":"=","right":{"type":"Arr","elements":[{"type":"Const","value":"return new C("}]}},{"type":"For","init":{"type":"BlockExpression","body":[{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"=","right":{"type":"Const","value":0,"sign":1}},{"type":"Call","func":{"type":"Ident","name":"__num"},"args":[{"type":"Ident","name":"length"}]}]},"test":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"<","right":{"type":"Ident","name":"length"}},"step":{"type":"Unary","op":"++","node":{"type":"Ident","name":"i"}},"body":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"i"},"op":">","right":{"type":"Const","value":0,"sign":1}},"whenTrue":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"func"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Const","value":", "}]}},{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"func"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Const","value":"a["},{"type":"Ident","name":"i"},{"type":"Const","value":"]"}]}]}},{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"func"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Const","value":");"}]},{"type":"Binary","left":{"type":"Ident","name":"creator"},"op":"=","right":{"type":"Call","func":{"type":"Ident","name":"Function"},"args":[{"type":"Const","value":"C"},{"type":"Const","value":"a"},{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"func"},"op":".","right":{"type":"Const","value":"join"}},"args":[{"type":"Const","value":""}]}]}},{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"newCreators"},"op":".","right":{"type":"Ident","name":"length"}},"op":"=","right":{"type":"Ident","name":"creator"}}]}},{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"creator"},"args":[{"type":"Ident","name":"Ctor"},{"type":"Ident","name":"args"}]}}]}}}]}}},"type":{"type":"function","returnType":{"type":"any"}},"dependencies":["__new","__num"]},"__instanceofsome":{"helper":{"type":"Func","params":[{"type":"Ident","name":"value"},{"type":"Ident","name":"array"}],"body":{"type":"Return","node":{"type":"Call","func":{"type":"Func","variables":["_arr","_i","item"],"body":{"type":"BlockStatement","body":[{"type":"For","init":{"type":"BlockExpression","body":[{"type":"Binary","left":{"type":"Ident","name":"_arr"},"op":"=","right":{"type":"Call","func":{"type":"Ident","name":"__toArray"},"args":[{"type":"Ident","name":"array"}]}},{"type":"Binary","left":{"type":"Ident","name":"_i"},"op":"=","right":{"type":"Binary","left":{"type":"Ident","name":"_arr"},"op":".","right":{"type":"Const","value":"length"}}}]},"test":{"type":"Unary","op":"--post","node":{"type":"Ident","name":"_i"}},"body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"item"},"op":"=","right":{"type":"Binary","left":{"type":"Ident","name":"_arr"},"op":".","right":{"type":"Ident","name":"_i"}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"value"},"op":"instanceof","right":{"type":"Ident","name":"item"}},"whenTrue":{"type":"Return","node":{"type":"Const","value":true}}}]}},{"type":"Return","node":{"type":"Const","value":false}}]}}}}},"type":{"type":"function","returnType":{"type":"simple","name":"boolean"}},"dependencies":["__instanceofsome","__toArray"]},"__xor":{"helper":{"type":"Func","params":[{"type":"Ident","name":"x"},{"type":"Ident","name":"y"}],"body":{"type":"IfStatement","test":{"type":"Ident","name":"x"},"whenTrue":{"type":"IfStatement","test":{"type":"Ident","name":"y"},"whenTrue":{"type":"Return","node":{"type":"Const","value":false}},"whenFalse":{"type":"Return","node":{"type":"Ident","name":"x"}}},"whenFalse":{"type":"Return","node":{"type":"Binary","left":{"type":"Ident","name":"y"},"op":"||","right":{"type":"Ident","name":"x"}}}}},"type":{"type":"function","returnType":{"type":"any"}},"dependencies":["__xor"]},"__once":{"helper":{"type":"Func","params":[{"type":"Ident","name":"func"}],"body":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"func"}},"op":"!==","right":{"type":"Const","value":"function"}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"Error"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected func to be a Function, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"__typeof"},"args":[{"type":"Ident","name":"func"}]}}]}}},{"type":"Return","node":{"type":"Func","variables":["f"],"body":{"type":"IfStatement","test":{"type":"Ident","name":"func"},"whenTrue":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"f"},"op":"=","right":{"type":"Ident","name":"func"}},{"type":"Binary","left":{"type":"Ident","name":"func"},"op":"=","right":{"type":"Const","value":null}},{"type":"Return","node":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"f"},"op":".","right":{"type":"Const","value":"apply"}},"args":[{"type":"This"},{"type":"Arguments"}]}}]},"whenFalse":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"Error"},"args":[{"type":"Const","value":"Attempted to call function more than once"}]}}}}}]}},"type":{"type":"function","returnType":{"type":"function","returnType":{"type":"any"}}},"dependencies":["__once","__toArray","__typeof"]},"__async":{"helper":{"type":"Func","params":[{"type":"Ident","name":"limit"},{"type":"Ident","name":"length"},{"type":"Ident","name":"onValue"},{"type":"Ident","name":"onComplete"}],"variables":["broken","index","slotsUsed","sync"],"body":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"length"},"op":"<=","right":{"type":"Const","value":0,"sign":1}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"onComplete"},"args":[{"type":"Const","value":null}]}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"limit"},"op":"<","right":{"type":"Const","value":1}},"op":"||","right":{"type":"Binary","left":{"type":"Ident","name":"limit"},"op":"!==","right":{"type":"Ident","name":"limit"}}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"limit"},"op":"=","right":{"type":"Const","infinite":true,"value":1}}},{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"=","right":{"type":"Const","value":null}},{"type":"Binary","left":{"type":"Ident","name":"slotsUsed"},"op":"=","right":{"type":"Const","value":0,"sign":1}},{"type":"Binary","left":{"type":"Ident","name":"sync"},"op":"=","right":{"type":"Const","value":false}},{"type":"Func","name":{"type":"Ident","name":"onValueCallback"},"params":[{"type":"Ident","name":"err"}],"body":{"type":"BlockStatement","body":[{"type":"Unary","op":"--","node":{"type":"Ident","name":"slotsUsed"}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"err"},"op":"!=","right":{"type":"Const","value":null}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"==","right":{"type":"Const","value":null}}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"=","right":{"type":"Ident","name":"err"}}},{"type":"IfStatement","test":{"type":"Unary","op":"!","node":{"type":"Ident","name":"sync"}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"next"}}}}]}},{"type":"Binary","left":{"type":"Ident","name":"index"},"op":"=","right":{"type":"Const","value":0,"sign":1}},{"type":"Func","name":{"type":"Ident","name":"next"},"variables":["f","i"],"body":{"type":"BlockStatement","body":[{"type":"For","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"==","right":{"type":"Const","value":null}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"slotsUsed"},"op":"<","right":{"type":"Ident","name":"limit"}}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"index"},"op":"<","right":{"type":"Ident","name":"length"}}},"body":{"type":"BlockStatement","body":[{"type":"Unary","op":"++","node":{"type":"Ident","name":"slotsUsed"}},{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"=","right":{"type":"Ident","name":"index"}},{"type":"Unary","op":"++","node":{"type":"Ident","name":"index"}},{"type":"Binary","left":{"type":"Ident","name":"sync"},"op":"=","right":{"type":"Const","value":true}},{"type":"Call","func":{"type":"Ident","name":"onValue"},"args":[{"type":"Ident","name":"i"},{"type":"Call","func":{"type":"Ident","name":"__once"},"args":[{"type":"Ident","name":"onValueCallback"}]}]},{"type":"Binary","left":{"type":"Ident","name":"sync"},"op":"=","right":{"type":"Const","value":false}}]}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"!=","right":{"type":"Const","value":null}},"op":"||","right":{"type":"Binary","left":{"type":"Ident","name":"slotsUsed"},"op":"===","right":{"type":"Const","value":0,"sign":1}}},"whenTrue":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"f"},"op":"=","right":{"type":"Ident","name":"onComplete"}},{"type":"Binary","left":{"type":"Ident","name":"onComplete"},"op":"=","right":{"type":"Const"}},{"type":"IfStatement","test":{"type":"Ident","name":"f"},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"f"},"args":[{"type":"Ident","name":"broken"}]}}}]}}]}},{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"next"}}}]}},"type":{"type":"function","returnType":{"type":"any"}},"dependencies":["__async","__once"]},"__asyncResult":{"helper":{"type":"Func","params":[{"type":"Ident","name":"limit"},{"type":"Ident","name":"length"},{"type":"Ident","name":"onValue"},{"type":"Ident","name":"onComplete"}],"variables":["broken","index","result","slotsUsed","sync"],"body":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"length"},"op":"<=","right":{"type":"Const","value":0,"sign":1}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"onComplete"},"args":[{"type":"Const","value":null},{"type":"Arr"}]}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"limit"},"op":"<","right":{"type":"Const","value":1}},"op":"||","right":{"type":"Binary","left":{"type":"Ident","name":"limit"},"op":"!==","right":{"type":"Ident","name":"limit"}}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"limit"},"op":"=","right":{"type":"Const","infinite":true,"value":1}}},{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"=","right":{"type":"Const","value":null}},{"type":"Binary","left":{"type":"Ident","name":"slotsUsed"},"op":"=","right":{"type":"Const","value":0,"sign":1}},{"type":"Binary","left":{"type":"Ident","name":"sync"},"op":"=","right":{"type":"Const","value":false}},{"type":"Binary","left":{"type":"Ident","name":"result"},"op":"=","right":{"type":"Arr"}},{"type":"Func","name":{"type":"Ident","name":"onValueCallback"},"params":[{"type":"Ident","name":"err"},{"type":"Ident","name":"value"}],"body":{"type":"BlockStatement","body":[{"type":"Unary","op":"--","node":{"type":"Ident","name":"slotsUsed"}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"err"},"op":"!=","right":{"type":"Const","value":null}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"==","right":{"type":"Const","value":null}}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"=","right":{"type":"Ident","name":"err"}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"==","right":{"type":"Const","value":null}},"op":"&&","right":{"type":"Binary","left":{"type":"Binary","left":{"type":"Arguments"},"op":".","right":{"type":"Const","value":"length"}},"op":">","right":{"type":"Const","value":1}}},"whenTrue":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"result"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Ident","name":"value"}]}},{"type":"IfStatement","test":{"type":"Unary","op":"!","node":{"type":"Ident","name":"sync"}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"next"}}}}]}},{"type":"Binary","left":{"type":"Ident","name":"index"},"op":"=","right":{"type":"Const","value":0,"sign":1}},{"type":"Func","name":{"type":"Ident","name":"next"},"variables":["f","i"],"body":{"type":"BlockStatement","body":[{"type":"For","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"==","right":{"type":"Const","value":null}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"slotsUsed"},"op":"<","right":{"type":"Ident","name":"limit"}}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"index"},"op":"<","right":{"type":"Ident","name":"length"}}},"body":{"type":"BlockStatement","body":[{"type":"Unary","op":"++","node":{"type":"Ident","name":"slotsUsed"}},{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"=","right":{"type":"Ident","name":"index"}},{"type":"Unary","op":"++","node":{"type":"Ident","name":"index"}},{"type":"Binary","left":{"type":"Ident","name":"sync"},"op":"=","right":{"type":"Const","value":true}},{"type":"Call","func":{"type":"Ident","name":"onValue"},"args":[{"type":"Ident","name":"i"},{"type":"Call","func":{"type":"Ident","name":"__once"},"args":[{"type":"Ident","name":"onValueCallback"}]}]},{"type":"Binary","left":{"type":"Ident","name":"sync"},"op":"=","right":{"type":"Const","value":false}}]}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"!=","right":{"type":"Const","value":null}},"op":"||","right":{"type":"Binary","left":{"type":"Ident","name":"slotsUsed"},"op":"===","right":{"type":"Const","value":0,"sign":1}}},"whenTrue":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"f"},"op":"=","right":{"type":"Ident","name":"onComplete"}},{"type":"Binary","left":{"type":"Ident","name":"onComplete"},"op":"=","right":{"type":"Const"}},{"type":"IfStatement","test":{"type":"Ident","name":"f"},"whenTrue":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"!=","right":{"type":"Const","value":null}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"f"},"args":[{"type":"Ident","name":"broken"}]}},"whenFalse":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"f"},"args":[{"type":"Const","value":null},{"type":"Ident","name":"result"}]}}}}]}}]}},{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"next"}}}]}},"type":{"type":"function","returnType":{"type":"any"}},"dependencies":["__asyncResult","__once"]},"__asyncIter":{"helper":{"type":"Func","params":[{"type":"Ident","name":"limit"},{"type":"Ident","name":"iterator"},{"type":"Ident","name":"onValue"},{"type":"Ident","name":"onComplete"}],"variables":["broken","close","done","index","slotsUsed","sync"],"body":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"limit"},"op":"<","right":{"type":"Const","value":1}},"op":"||","right":{"type":"Binary","left":{"type":"Ident","name":"limit"},"op":"!==","right":{"type":"Ident","name":"limit"}}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"limit"},"op":"=","right":{"type":"Const","infinite":true,"value":1}}},{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"=","right":{"type":"Const","value":null}},{"type":"Binary","left":{"type":"Ident","name":"slotsUsed"},"op":"=","right":{"type":"Const","value":0,"sign":1}},{"type":"Binary","left":{"type":"Ident","name":"sync"},"op":"=","right":{"type":"Const","value":false}},{"type":"Func","name":{"type":"Ident","name":"onValueCallback"},"params":[{"type":"Ident","name":"err"}],"body":{"type":"BlockStatement","body":[{"type":"Unary","op":"--","node":{"type":"Ident","name":"slotsUsed"}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"err"},"op":"!=","right":{"type":"Const","value":null}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"==","right":{"type":"Const","value":null}}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"=","right":{"type":"Ident","name":"err"}}},{"type":"IfStatement","test":{"type":"Unary","op":"!","node":{"type":"Ident","name":"sync"}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"next"}}}}]}},{"type":"Binary","left":{"type":"Ident","name":"index"},"op":"=","right":{"type":"Const","value":0,"sign":1}},{"type":"Binary","left":{"type":"Ident","name":"done"},"op":"=","right":{"type":"Const","value":false}},{"type":"Binary","left":{"type":"Ident","name":"close"},"op":"=","right":{"type":"Func","body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"close"},"op":"=","right":{"type":"Const","value":null}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"iterator"},"op":"!=","right":{"type":"Const","value":null}},"op":"&&","right":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Binary","left":{"type":"Ident","name":"iterator"},"op":".","right":{"type":"Const","value":"close"}}},"op":"===","right":{"type":"Const","value":"function"}}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"iterator"},"op":".","right":{"type":"Const","value":"close"}}}}}]}}},{"type":"Func","name":{"type":"Ident","name":"next"},"variables":["f","i","value"],"body":{"type":"BlockStatement","body":[{"type":"For","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"==","right":{"type":"Const","value":null}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"slotsUsed"},"op":"<","right":{"type":"Ident","name":"limit"}}},"op":"&&","right":{"type":"Unary","op":"!","node":{"type":"Ident","name":"done"}}},"body":{"type":"BlockStatement","body":[{"type":"TryCatch","tryBody":{"type":"Binary","left":{"type":"Ident","name":"value"},"op":"=","right":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"iterator"},"op":".","right":{"type":"Const","value":"next"}}}},"catchIdent":{"type":"Ident","name":"e"},"catchBody":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"e"},"op":"===","right":{"type":"Ident","name":"StopIteration"}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"done"},"op":"=","right":{"type":"Const","value":true}},"whenFalse":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"=","right":{"type":"Ident","name":"e"}}},{"type":"Break"}]}},{"type":"Unary","op":"++","node":{"type":"Ident","name":"slotsUsed"}},{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"=","right":{"type":"Ident","name":"index"}},{"type":"Unary","op":"++","node":{"type":"Ident","name":"index"}},{"type":"Binary","left":{"type":"Ident","name":"sync"},"op":"=","right":{"type":"Const","value":true}},{"type":"TryCatch","tryBody":{"type":"Call","func":{"type":"Ident","name":"onValue"},"args":[{"type":"Ident","name":"value"},{"type":"Ident","name":"i"},{"type":"Call","func":{"type":"Ident","name":"__once"},"args":[{"type":"Ident","name":"onValueCallback"}]}]},"catchIdent":{"type":"Ident","name":"e"},"catchBody":{"type":"BlockStatement","body":[{"type":"Ident","name":"close"},{"type":"Call","func":{"type":"Ident","name":"close"}},{"type":"Throw","node":{"type":"Ident","name":"e"}}]}},{"type":"Binary","left":{"type":"Ident","name":"sync"},"op":"=","right":{"type":"Const","value":false}}]}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"!=","right":{"type":"Const","value":null}},"op":"||","right":{"type":"Binary","left":{"type":"Ident","name":"slotsUsed"},"op":"===","right":{"type":"Const","value":0,"sign":1}}},"whenTrue":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"f"},"op":"=","right":{"type":"Ident","name":"onComplete"}},{"type":"Binary","left":{"type":"Ident","name":"onComplete"},"op":"=","right":{"type":"Const"}},{"type":"Ident","name":"close"},{"type":"Call","func":{"type":"Ident","name":"close"}},{"type":"IfStatement","test":{"type":"Ident","name":"f"},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"f"},"args":[{"type":"Ident","name":"broken"}]}}}]}}]}},{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"next"}}}]}},"type":{"type":"function","returnType":{"type":"any"}},"dependencies":["__asyncIter","__once"]},"__asyncIterResult":{"helper":{"type":"Func","params":[{"type":"Ident","name":"limit"},{"type":"Ident","name":"iterator"},{"type":"Ident","name":"onValue"},{"type":"Ident","name":"onComplete"}],"variables":["broken","close","done","index","result","slotsUsed","sync"],"body":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"limit"},"op":"<","right":{"type":"Const","value":1}},"op":"||","right":{"type":"Binary","left":{"type":"Ident","name":"limit"},"op":"!==","right":{"type":"Ident","name":"limit"}}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"limit"},"op":"=","right":{"type":"Const","infinite":true,"value":1}}},{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"=","right":{"type":"Const","value":null}},{"type":"Binary","left":{"type":"Ident","name":"slotsUsed"},"op":"=","right":{"type":"Const","value":0,"sign":1}},{"type":"Binary","left":{"type":"Ident","name":"sync"},"op":"=","right":{"type":"Const","value":false}},{"type":"Binary","left":{"type":"Ident","name":"result"},"op":"=","right":{"type":"Arr"}},{"type":"Func","name":{"type":"Ident","name":"onValueCallback"},"params":[{"type":"Ident","name":"err"},{"type":"Ident","name":"value"}],"body":{"type":"BlockStatement","body":[{"type":"Unary","op":"--","node":{"type":"Ident","name":"slotsUsed"}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"err"},"op":"!=","right":{"type":"Const","value":null}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"==","right":{"type":"Const","value":null}}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"=","right":{"type":"Ident","name":"err"}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"==","right":{"type":"Const","value":null}},"op":"&&","right":{"type":"Binary","left":{"type":"Binary","left":{"type":"Arguments"},"op":".","right":{"type":"Const","value":"length"}},"op":">","right":{"type":"Const","value":1}}},"whenTrue":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"result"},"op":".","right":{"type":"Const","value":"push"}},"args":[{"type":"Ident","name":"value"}]}},{"type":"IfStatement","test":{"type":"Unary","op":"!","node":{"type":"Ident","name":"sync"}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"next"}}}}]}},{"type":"Binary","left":{"type":"Ident","name":"index"},"op":"=","right":{"type":"Const","value":0,"sign":1}},{"type":"Binary","left":{"type":"Ident","name":"done"},"op":"=","right":{"type":"Const","value":false}},{"type":"Binary","left":{"type":"Ident","name":"close"},"op":"=","right":{"type":"Func","body":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"close"},"op":"=","right":{"type":"Const","value":null}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"iterator"},"op":"!=","right":{"type":"Const","value":null}},"op":"&&","right":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Binary","left":{"type":"Ident","name":"iterator"},"op":".","right":{"type":"Const","value":"close"}}},"op":"===","right":{"type":"Const","value":"function"}}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"iterator"},"op":".","right":{"type":"Const","value":"close"}}}}}]}}},{"type":"Func","name":{"type":"Ident","name":"next"},"variables":["f","i","value"],"body":{"type":"BlockStatement","body":[{"type":"For","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"==","right":{"type":"Const","value":null}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"slotsUsed"},"op":"<","right":{"type":"Ident","name":"limit"}}},"op":"&&","right":{"type":"Unary","op":"!","node":{"type":"Ident","name":"done"}}},"body":{"type":"BlockStatement","body":[{"type":"TryCatch","tryBody":{"type":"Binary","left":{"type":"Ident","name":"value"},"op":"=","right":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"iterator"},"op":".","right":{"type":"Const","value":"next"}}}},"catchIdent":{"type":"Ident","name":"e"},"catchBody":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"e"},"op":"===","right":{"type":"Ident","name":"StopIteration"}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"done"},"op":"=","right":{"type":"Const","value":true}},"whenFalse":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"=","right":{"type":"Ident","name":"e"}}},{"type":"Break"}]}},{"type":"Unary","op":"++","node":{"type":"Ident","name":"slotsUsed"}},{"type":"Binary","left":{"type":"Ident","name":"i"},"op":"=","right":{"type":"Ident","name":"index"}},{"type":"Unary","op":"++","node":{"type":"Ident","name":"index"}},{"type":"Binary","left":{"type":"Ident","name":"sync"},"op":"=","right":{"type":"Const","value":true}},{"type":"TryCatch","tryBody":{"type":"Call","func":{"type":"Ident","name":"onValue"},"args":[{"type":"Ident","name":"value"},{"type":"Ident","name":"i"},{"type":"Call","func":{"type":"Ident","name":"__once"},"args":[{"type":"Ident","name":"onValueCallback"}]}]},"catchIdent":{"type":"Ident","name":"e"},"catchBody":{"type":"BlockStatement","body":[{"type":"Ident","name":"close"},{"type":"Call","func":{"type":"Ident","name":"close"}},{"type":"Throw","node":{"type":"Ident","name":"e"}}]}},{"type":"Binary","left":{"type":"Ident","name":"sync"},"op":"=","right":{"type":"Const","value":false}}]}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"!=","right":{"type":"Const","value":null}},"op":"||","right":{"type":"Binary","left":{"type":"Ident","name":"slotsUsed"},"op":"===","right":{"type":"Const","value":0,"sign":1}}},"whenTrue":{"type":"BlockStatement","body":[{"type":"Binary","left":{"type":"Ident","name":"f"},"op":"=","right":{"type":"Ident","name":"onComplete"}},{"type":"Binary","left":{"type":"Ident","name":"onComplete"},"op":"=","right":{"type":"Const"}},{"type":"Ident","name":"close"},{"type":"Call","func":{"type":"Ident","name":"close"}},{"type":"IfStatement","test":{"type":"Ident","name":"f"},"whenTrue":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"broken"},"op":"!=","right":{"type":"Const","value":null}},"whenTrue":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"f"},"args":[{"type":"Ident","name":"broken"}]}},"whenFalse":{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"f"},"args":[{"type":"Const","value":null},{"type":"Ident","name":"result"}]}}}}]}}]}},{"type":"Return","node":{"type":"Call","func":{"type":"Ident","name":"next"}}}]}},"type":{"type":"function","returnType":{"type":"any"}},"dependencies":["__asyncIterResult","__once"]},"__is":{"helper":{"type":"IfExpression","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Binary","left":{"type":"Ident","name":"Object"},"op":".","right":{"type":"Const","value":"is"}}},"op":"===","right":{"type":"Const","value":"function"}},"whenTrue":{"type":"Binary","left":{"type":"Ident","name":"Object"},"op":".","right":{"type":"Const","value":"is"}},"whenFalse":{"type":"Func","params":[{"type":"Ident","name":"x"},{"type":"Ident","name":"y"}],"body":{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"x"},"op":"===","right":{"type":"Ident","name":"y"}},"whenTrue":{"type":"Return","node":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"x"},"op":"!==","right":{"type":"Const","value":0,"sign":1}},"op":"||","right":{"type":"Binary","left":{"type":"Binary","left":{"type":"Const","value":1},"op":"/","right":{"type":"Ident","name":"x"}},"op":"===","right":{"type":"Binary","left":{"type":"Const","value":1},"op":"/","right":{"type":"Ident","name":"y"}}}}},"whenFalse":{"type":"Return","node":{"type":"Binary","left":{"type":"Binary","left":{"type":"Ident","name":"x"},"op":"!==","right":{"type":"Ident","name":"x"}},"op":"&&","right":{"type":"Binary","left":{"type":"Ident","name":"y"},"op":"!==","right":{"type":"Ident","name":"y"}}}}}}},"type":{"type":"any"},"dependencies":["__is"]},"__bind":{"helper":{"type":"Func","params":[{"type":"Ident","name":"parent"},{"type":"Ident","name":"child"}],"variables":["func"],"body":{"type":"BlockStatement","body":[{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Ident","name":"parent"},"op":"==","right":{"type":"Const","value":null}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"TypeError"},"args":[{"type":"Binary","left":{"type":"Const","value":"Expected parent to be an object, got "},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"__typeof"},"args":[{"type":"Ident","name":"parent"}]}}]}}},{"type":"Binary","left":{"type":"Ident","name":"func"},"op":"=","right":{"type":"Binary","left":{"type":"Ident","name":"parent"},"op":".","right":{"type":"Ident","name":"child"}}},{"type":"IfStatement","test":{"type":"Binary","left":{"type":"Unary","op":"typeof","node":{"type":"Ident","name":"func"}},"op":"!==","right":{"type":"Const","value":"function"}},"whenTrue":{"type":"Throw","node":{"type":"Call","func":{"type":"Ident","name":"Error"},"args":[{"type":"Binary","left":{"type":"Binary","left":{"type":"Const","value":"Trying to bind child '"},"op":"+","right":{"type":"Call","func":{"type":"Ident","name":"String"},"args":[{"type":"Ident","name":"child"}]}},"op":"+","right":{"type":"Const","value":"' which is not a function"}}]}}},{"type":"Return","node":{"type":"Func","body":{"type":"Return","node":{"type":"Call","func":{"type":"Binary","left":{"type":"Ident","name":"func"},"op":".","right":{"type":"Const","value":"apply"}},"args":[{"type":"Ident","name":"parent"},{"type":"Arguments"}]}}}}]}},"type":{"type":"function","returnType":{"type":"function","returnType":{"type":"any"}}},"dependencies":["__bind","__toArray","__typeof"]},"__defProp":{"helper":{"type":"Binary","left":{"type":"Ident","name":"Object"},"op":".","right":{"type":"Const","value":"defineProperty"}},"type":{"type":"any"},"dependencies":["__defProp"]}}});
  }());

  if (typeof define === "function" && define.amd) {
    define(function () { return GorillaScript; });
  } else {
    root.GorillaScript = GorillaScript;
  }
}(this));