require! fs
require! path
let {exec} = require 'child_process'
let {string-repeat, pad-left, pad-right} = require './lib/utils'

option \uglify, "u", "Use UglifyJS2 to minify the result"
option \minify, null, "Minimize the use of unnecessary whitespace"
option \file, "f", "Build a specific file", "file"
option \prefix, null, "Path to install to (/usr/local by default)"
option \reporter, null, "Reporter to use with tests", "string"
//option \js, null, "Compile to JavaScript (default)"

let get-lang(options) -> "js"

command \install, "Install GorillaScript to /usr/local or --prefix", #(options, cb)
  async! cb, filename-path <- fs.realpath __filename
  let install-path = options.prefix or "/usr/local"
  let bin = path.join install-path, "bin"
  let files = ["gorilla", "gork", "gjs-gorilla"]
  let cmds = [
    "mkdir -p $bin"
    ...for file in files
      "ln -sfn $(path.join filename-path, '..', 'bin', file) $bin/$file"
  ]
  exec cmds.join(" && "), #(err, stdout, stderr)
    if err
      console.error stderr.trim()
    else
      output "done\n"
    cb()

command \build, "Build GorillaScript from source", #(options, cb)
  async! cb, filename-path <- fs.realpath __filename
  let src-path = path.join(path.dirname(filename-path), "src")
  async! cb, filenames <- fs.readdir src-path
  
  let mutable files = for filter file in filenames
    not r'prelude\.gs$'.test(file)
  if options.file
    let file-filter = options.file.split ","
    for file in file-filter
      if file not in files
        return cb "Cannot build unknown file: $file"
    files := for filter file in files
      file in file-filter
  
  if files.length == 0
    return cb("No files to build")
  
  let gorilla = require('./lib/gorilla')
  async! cb <- (from-promise! gorilla.init(lang: get-lang(options)))()
  
  files.sort #(a, b) -> a.to-lower-case() <=> b.to-lower-case()
  let inputs = {}
  asyncfor(0) next, file in files
    async! cb, text <- fs.read-file path.join(src-path, file), "utf-8"
    inputs[file] := text
    next()
  
  let longest-name-len = for reduce file in files, current = 0; current max file.length
  
  output string-repeat(" ", longest-name-len)
  output "     parse     macro     reduce    translate compile $(if options.uglify then '  uglify  ' else '')|  total\n"
  let totals = {}
  let mutable total-time = 0
  let results = {}
  let gorilla = require('./lib/gorilla')
  asyncfor err <- next, file in files
    let code = inputs[file]
    output "$(pad-right file & ':', longest-name-len + 1, ' ') "
    let start-file-time = Date.now()
    let progress = #(name, time)!
      totals[name] := (totals[name] or 0) + time
      output "  $(pad-left ((time / 1000_ms).to-fixed 3), 6, ' ') s"
    async err, compiled <- (from-promise! gorilla.compile code, { extends options, filename: file, progress: progress })()
    if err?
      output "\n"
      return next(err)
    results[file] := compiled.code
    let end-file-time = Date.now()
    let file-time = end-file-time - start-file-time
    output " | $(pad-left ((file-time / 1000_ms).to-fixed 3), 6, ' ') s\n"
    total-time += file-time
    gc?()
    next()
  if err?
    return cb(err)
  if files.length > 1
    output string-repeat "-", longest-name-len + 53
    if options.uglify
      output string-repeat "-", 10
    output "+"
    output string-repeat "-", 9
    output "\n"
    output pad-right "total: ", longest-name-len + 2, ' '
    for part in [\parse, \macro-expand, \reduce, \translate, \compile, ...if options.uglify then [\uglify] else []]
      output "  $(pad-left ((totals[part] / 1000_ms).to-fixed 3), 6, ' ') s"
    output " | $(pad-left ((total-time / 1000_ms).to-fixed 3), 6, ' ') s\n"

  asyncfor(0) err <- next, file in files
    let compiled = results[file]
    let output-file = path.join "./lib", file.replace r"\.gs\$", ".js"
    async err <- fs.rename output-file, "$(output-file).bak"
    if err? and err.code != \ENOENT
      return next(err)
    async! next <- fs.write-file output-file, compiled, "utf8"
    next()
  cb(err)

command "build:full", "Build GorillaScript twice and run tests", #(options, cb)
  delete options.file
  console.log "running build"
  async! cb <- invoke \build
  console.log "running build (again)"
  async! cb <- invoke \build
  console.log "running build:browser"
  async! cb <- invoke "build:browser"
  invoke "test:full", cb

command "build:browser", "Merge GorillaScript for use in the browser", #(options, cb)
  async! cb, filename-path <- fs.realpath __filename
  let lib-path = path.join(path.dirname(filename-path), "lib")
  let parts = []
  asyncfor next, file in ["utils", "jsutils", "types", "jsast", "parser", "parser-utils", "parser-scope", "parser-nodes", "parser-macroholder", "parser-macrocontext", "jstranslator", "gorilla", "browser"]
    async! cb, text <- fs.read-file path.join(lib-path, file & ".js"), "utf8"
    parts.push """
      require['./$file'] = function () {
        var module = { exports: this };
        var exports = this;
        $(text.split("\n").join("\n  "))
        return module.exports;
      };
      """
    next()
  
  let gorilla = require('./lib/gorilla')
  async! cb, serialized-prelude <- gorilla.get-serialized-prelude("js")
  let mutable deserialized-prelude = JSON.parse serialized-prelude
  if options.uglify
    for k, v of deserialized-prelude
      if is-array! v
        for item, i in v
          if typeof item.code == \string and item.code.substring(0, 7) == "return "
            let mutable minified = require("uglify-js").minify(item.code.substring(7), from-string: true).code
            if minified.char-at(0) == "("
              minified := "return$minified"
            else
              minified := "return $minified"
            item.code := minified
  let full-serialized-prelude = require('./lib/jsutils').to-JS-source deserialized-prelude, null, indent: 2
  let mutable code = """
    ;(function (root) {
      var GorillaScript = (function (realRequire) {
        function require(path) {
          var has = Object.prototype.hasOwnProperty;
          if (has.call(require._cache, path)) {
            return require._cache[path];
          } else if (has.call(require, path)) {
            var func = require[path];
            delete require[path];
            return require._cache[path] = func.call({});
          } else if (realRequire) {
            return realRequire(path);
          }
        }
        require._cache = {};
        $(parts.join("\n").split("\n").join("\n  "))
        
        require("./browser");
        return require("./gorilla").withPrelude("js", $full-serialized-prelude);
      }(typeof module !== "undefined" && typeof require === "function" ? require : void 0));
      
      if (typeof define === "function" && define.amd) {
        define(function () { return GorillaScript; });
      } else {
        root.GorillaScript = GorillaScript;
      }
    }(this));
    """
  if options.uglify
    output "Built gorillascript.js, uglifying... "
    let start-time = new Date().get-time()
    code := require("uglify-js").minify(code, from-string: true).code
    output "$(((new Date().get-time() - start-time) / 1000_ms).to-fixed 3) s\n"
  else
    output "Built gorillascript.js\n"
  async! cb <- fs.write-file path.join(path.join(path.dirname(filename-path), "extras"), "gorillascript.js"), code, "utf8"
  cb()

command "test", "Run the GorillaScript test suite", #(options, cb)
  async! cb, filename-path <- fs.realpath __filename
  let tests-path = path.join(path.dirname(filename-path), "tests")
  async! cb, filenames <- fs.readdir tests-path
  
  let files = if options.file
    let file-filter = options.file.split ","
    for file in file-filter
      if file not in filenames
        return cb "Cannot build unknown file: $file"
    for filter file in filenames
      file in file-filter
  else
    for filter file in filenames
      path.extname(file) == ".gs"
  
  if files.length == 0
    return cb("No files to test")
  
  let gorilla = require('./lib/gorilla')
  let sandbox = {
    gorilla
  }
  
  let longest-name-len = for reduce file in files, current = 0; current max file.length
  
  async! cb <- (from-promise! gorilla.init(lang: get-lang(options)))()
  
  output string-repeat(" ", longest-name-len)
  output "     parse     macro     reduce    translate compile |  total\n"
  
  let mutable total-time = 0
  let totals = {}
  let compilations = {}
  asyncfor next, file in files
    let filename = path.join tests-path, file
    async! cb, code <- fs.read-file filename, "utf8"
    
    let basename = path.basename filename
    output "$(pad-right basename & ':', longest-name-len + 1, ' ') "
    let start = Date.now()
    let mutable failure = false
    let start-time = Date.now()
    let progress = #(name, time)
      totals[name] := (totals[name] or 0) + time
      output "  $(pad-left ((time / 1000_ms).to-fixed 3), 6, ' ') s"
    async err, result <- (from-promise! gorilla.compile code.to-string(), { extends options, filename, include-globals: true, no-prelude: options["no-prelude"], progress })()
    throw? err // TODO: better handling
    
    compilations[file] := Function(result.code)

    let end-time = Date.now()
    total-time += end-time - start-time

    output " | $(pad-left ((end-time - start-time) / 1000_ms).to-fixed(3), 6, ' ') s\n"
    gc?()
    next()
  if files.length > 1
    output string-repeat("-", longest-name-len + 53)
    output "+---------\n"
    output "$(pad-right 'total:', longest-name-len + 1, ' ') "
    for part in [\parse, \macro-expand, \reduce, \translate, \compile]
      output "  $(pad-left (((totals[part] or 0) / 1000_ms).to-fixed 3), 6, ' ') s"
    output " | $(pad-left (total-time / 1000_ms).to-fixed(3), 6, ' ') s\n"
  
  GLOBAL.gorilla := gorilla
  GLOBAL.require := require
  let mocha = new (require('mocha'))({reporter: options.reporter or "dot"})
  require! chai
  GLOBAL.expect := chai.expect
  require! sinon
  GLOBAL.sinon := sinon
  GLOBAL.spy := sinon.spy
  GLOBAL.stub := sinon.stub
  GLOBAL.mock := sinon.mock
  chai.use require("sinon-chai")
  let suite = mocha.suite
  for k, v of compilations
    suite.emit 'pre-require', GLOBAL, k, mocha
    try
      suite.emit 'require', describe("$k:", #-> v@(GLOBAL)), k, mocha
    catch e
      console.log "Error loading $k: $(e.stack)"
    suite.emit 'post-require', GLOBAL, k, mocha
  mocha.run #(count)
    if count
      cb Error("failed $(count) tests")
    else
      cb null

command "test:promise", "Test for compliance with Promises/A+", #(options, cb)
  let promises-aplus-tests = require "promises-aplus-tests"
  
  promises-aplus-tests {pending: __defer}, {reporter: options.reporter or "dot"}, cb

command "test:full", "Run all tests", #(options, cb)  
  console.log "running test:promise"
  async! cb <- invoke "test:promise"
  console.log "running test"
  async! cb <- invoke \test
  cb()
